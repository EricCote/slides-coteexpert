---
title: hooks
description: DÃ©crits les rÃ¨gles des hooks
---

# RÃ¨gles des Hooks

---

## Hooks

- Les Hooks permettent d'appeler des fonctionnalitÃ©s de React
- Les Hooks peuvent Ãªtre utilisÃ©s sous certaines conditions
  - Ces conditions sont appelÃ©es les **rÃ¨gles des hooks** (Rules of Hooks)
- On peut crÃ©er nos propres hooks personnalisÃ©s
  - Les hooks doivent Ãªtre des fonctions pures, sans effets de bord
- Tous les hooks dÃ©butent avec le prÃ©fixe use (ex: useState, useRef)

---

## Les hooks sont purs

- Les hooks sont appelÃ©s par des composants, pendant leurs rendus
- Il faut respecter les rÃ¨gles de puretÃ©
  - Pas d'effet de bord, pas de modification de DOM, pas d'appel d'API
- L'Ã©tat et les props sont "read-only"
  - Il est possible de muter des donnÃ©es locales ou des clones

---

## Hooks placÃ©s au top niveau

- On appelle un hook au top niveau d'un composant
- Ou encore au top niveau d'un hook personnalisÃ©

```js
function Counter() {
  // âœ… bien: top-niveau dans un composant fonctionnel
  const [count, setCount] = useState(0);
  // ...
}

function useWindowWidth() {
  // âœ… bien: top niveau dans un hook personnalisÃ© (custom hook)
  const [width, setWidth] = useState(window.innerWidth);
  // ...
}
```

---

## Top niveau seulement

On ne tolÃ¨re pas un appel de hook qui n'est pas top niveau

- ğŸ”´ Pas de Hooks dans des boucles ou conditions
- ğŸ”´ Pas de Hooks aprÃ¨s un return conditionnel
- ğŸ”´ Pas de Hooks dans les gestionnaires d'Ã©vÃ©nements
- ğŸ”´ Pas de Hooks dans composants classes
- ğŸ”´ Pas de Hooks dans les fonctions passÃ©es Ã  `useMemo`, `useReducer`, ou `useEffect`
- ğŸ”´ Pas de Hooks dans des blocs `try`/`catch`/`finally`

---

## Pas de Hooks dans des boucles ou conditions

```js
function Bad({ cond }) {
  if (cond) {
    // ğŸ”´ Mauvais: appel de Hook dans une condition
    //(Il faut dÃ©placer au top niveau)
    const theme = useContext(ThemeContext);
  }
  // ...
}
```

```js
function Bad() {
  for (let i = 0; i < 10; i++) {
    // ğŸ”´ Mauvais: appel de Hook dans une boucle
    //(Il faut dÃ©placer au top niveau)
    const theme = useContext(ThemeContext);
  }
  // ...
}
```

---

## Pas de Hooks aprÃ¨s un return conditionnel

```js
function Bad({ cond }) {
  if (cond) {
    return;
  }
  // ğŸ”´ Mauvais: aprÃ¨s un return conditional
  //(Il faut dÃ©placer au top niveau, avant le return)
  const theme = useContext(ThemeContext);
  // ...
}
```

---

## Pas de Hooks dans les gestionnaires d'Ã©vÃ©nements

```js
function Bad() {
  function handleClick() {
    // ğŸ”´ Mauvais: dans un gestionnaire d'Ã©vÃ©nement
    //(Il faut dÃ©placer au top niveau)
    const theme = useContext(ThemeContext);
  }
  // ...
}
```

---

## Pas de Hooks dans les fonctions flÃ¨ches

Pas de Hooks dans les fonctions passÃ©es Ã  `useMemo`, `useReducer`, ou `useEffect`

```js
function Bad() {
  const style = useMemo(() => {
    // ğŸ”´ Mauvais: dans useMemo
    //(Il faut dÃ©placer au top niveau)
    const theme = useContext(ThemeContext);
    return createStyle(theme);
  });
  // ...
}
```

---

## ğŸ”´ Pas de Hooks dans composants classes

```js
class Bad extends React.Component {
  render() {
    // ğŸ”´ Mauvais: dans un composant classe
    //(Utiliser un composant fonctionnel plutÃ´t qu'une classe)
    useEffect(() => {});
    // ...
  }
}
```

---

## Pas de Hooks dans des blocs `try`/`catch`/`finally`

```js
function Bad() {
  try {
    // ğŸ”´ Mauvais: dans un bloc  try/catch/finally
    //(Il faut dÃ©placer au top niveau)
    const [x, setX] = useState(0);
  } catch {
    const [x, setX] = useState(1);
  }
}
```

---

## Appeler seulement pendant le rendu

Donc on peut appeler un hook, pendant le rendu:

- Au top niveau d'un composant fonctionnel
- Au top niveau d'un Hook personnalisÃ©

On ne peut pas appeler un hook:

- Ã€ partir d'une fonction JavaScript quelconque

```js
function FriendList() {
  const [onlineStatus, setOnlineStatus] = useOnlineStatus(); // âœ…
}

// âŒ Pas un composant, ni un Hook personnalisÃ©
function setOnlineStatus() {
  const [onlineStatus, setOnlineStatus] = useOnlineStatus();
}
```

---

## Liste des Hooks

LÃ©gende:

ğŸ†• React 18 (2022)

ğŸ†•ğŸ†• React 19 (2024)

---

## Hooks de l'Ã©tat

useState: GÃ¨re la persistance de valeurs et provoque un re-rendu quand la valeur change

useReducer: GÃ¨re la persistance de valeurs pour des Ã©tats complexes, en utilisant des fonctions dispatch et reducer. Provoque un re-rendu quand la valeur change

useContext: AccÃ¨de aux donnÃ©es du contexte et provoque un re-rendu quand le contexte change

useRef: GÃ¨re la persistance d'une valeur mutative, ne provoque JAMAIS de re-rendu, permet d'Ãªtre liÃ© Ã  un Ã©lÃ©ment du DOM

useImperativeHandle: Personnalise l'instance d'une `ref` retournÃ©e au composant parent

---

## Hooks de perfomance

useCallback: MÃ©moÃ¯ser des callbacks pour prÃ©venir des re-rendus

useMemo: MÃ©moÃ¯ser des valeurs pour prÃ©venir des re-calculs non-nÃ©cessaires

---

## Hooks et les Effets

useEffect: Permet l'appel d'Effets impurs aprÃ¨s le rendu, tel que le chargement de donnÃ©es, les abonnements, les modifications du DOM

useLayoutEffect: Similaire Ã  useEffect, lancÃ© aprÃ¨s le rendu et les modifs du DOM, mais avant le 'paint' du navigateur. (Ã‰vite l'effet de clignotement)

ğŸ†• useInsertionEffect: (pour les bibliothÃ¨ques qui gÃ©nÃ¨rent du CSS-in-JS) Similaire Ã  useLayoutEffect, mais lancÃ© avant les autres layout effects. Ã‰vite des problÃ¨mes de positionnement dans les calculs de useLayoutEffect

ğŸ†• useSyncExternalStore: permet de gÃ©rer les abonnements extÃ©rieurs Ã  React. Retourne une rÃ©fÃ©rence aux donnÃ©es, et gÃ¨re la notification de modification, qui provoque un re-rendu

---

## Hooks et les autres scÃ©narios

useDebugValue: Affichage d'infos dans React DevTools par notre Hook personnalisÃ©

ğŸ†• useId: gÃ©nÃ¨re un nom unique mais persistant

---

## Hooks et le concurrent rendering

ğŸ†• useDeferredValue: GÃ©nÃ¨re un rendu avec le rÃ©sultat prÃ©cÃ©dent tant que le nouveau rÃ©sultat n'a pas fini de suspendre

ğŸ†•ğŸ†• useOptimistic: GÃ©nÃ¨re un rendu avec un rÃ©sultat fourni (optimiste) tant que le nouveau rÃ©sultat n'a pas fini de suspendre

ğŸ†• useTransition: Permet d'encapsuler des setState() (qui gÃ©nÃ¨rent un re-rendu synchrone) de faÃ§on asynchrone, dans une "transition". La transition fait un rendu avec le rÃ©sultat prÃ©cÃ©dent, tant que le nouveau rÃ©sultat n'a pas fini de suspendre

ğŸ†•ğŸ†• use: encapsule une `promise` pour obtenir des donnÃ©es. Si la `promise` est complÃ©tÃ©e, on poursuit le rendu. Sinon, on interrompt et suspend le rendu. On cÃ©dule un nouveau rendu quand la `promise` complÃ¨tÃ©e.

---

## Hooks pour formulaire

ğŸ†•ğŸ†• useActionState: gÃ©nÃ¨re une mÃ©thode d'action et un Ã©tat qui contient le rÃ©sultat retournÃ© par cette mÃ©thode. On lie par la suite la prop `action` du `<form>`, ou la prop formAction d'un `<button>`

ğŸ†•ğŸ†• useFormStatus: Permet au composant enfant d'obtenir les infos du formulaire parent (pending, data, method, action)
