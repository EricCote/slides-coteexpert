---
title: Données et Effets
description: other
---

# Données et Effets

import cssMcu from './10-data/cssMcu';

---

## Qu'est-ce que useEffect

<img
  src='https://m.media-amazon.com/images/I/61vQ5HnKLdL._AC_UF894,1000_QL80_.jpg'
  alt='old phone'
  width='50%'
/>

`useEffect()` Hook React qui permet de synchroniser un composant avec un système externe.

---

## Qu'est-ce qu'un système externe?

Quelque chose qui n'est pas géré par React. React gère les composants, le JSX, le rendu et le résultat du rendu (virtual DOM)

React ne peut rien utiliser d'autre

- On ne peut utiliser une bibliothèque js (jQuery, Angular, GraphJS, etc)
- On ne peut faire de `fetch` réseau pour obtenir données
- APIs du navigateur (History API, Navigation API, Location API, etc)

Pourquoi? Le rendu doit être pur, sans effet de bord.

---

## Un effect roule après le rendu

Utiliser useEffect permet de créer un "Effect"

Les Effects sont exécutées immédiatement après le rendu (et après les fonctions de cleanup, s'il y a lieu)

<Alert type='danger'>
  **Attention:** Si un effect modifie l'état, ceci pourrait générer un rerendu,
  qui déclenche un autre effect, qui modifie l'état à nouveau... ainsi de
  suite... boucle infinie!
</Alert>
>

---

## Utilisation:

```js
useEffect(fn_Setup, dependencyArray?)
```

Paramètre fn_Setup:

- La fonction setup interagit et se "connecte" avec le monde externe
- Peut retourner une fonction flèche (surnommée `cleanup`) pour se "déconnecter"

Le tableau de dépendances détermine quand il faut exécuter

- aucun changement dans les dépendances: pas d'exécution d'Effet
- un ou plusieurs changements: exécute l'Effet après le rendu
- Si le tableau est `null` ou `undefined`: l'Effet exécute après chaque rendu
- Si le tableau est un tableau vide: l'Effet n'exécute qu'après le premier rendu seulement

---

## useEffects n'est pas facile

- Rendu et useEffect exécutent deux fois en Dev (`<StrictMode/>`)
- Cela créé des rendus additionnels
  - C'est pour aider à trouver les effets de bord indésirables
- useEffect devrait n'affecter qu'un élément externe seulement
  - C'est plus complexe quand on affecte plusieurs choses.

<hr />

- Tableaux de dépendences sont complexes avec strings, nombres et booléens
  - Encore plus difficiles avec objets ou tableaux
  - La comapraison utilise l'égalité référentielle (`Object.is()`)
  - On ne peut détecter le contenu modifié d'une référence
  - Objets et tableaux doivent être considérés immuables

---

## The Goal

"With time, the React team’s goal is to reduce the number of the Effects in your app to the minimum by providing more specific solutions to more specific problems. "

[source](https://react.dev/learn/reusing-logic-with-custom-hooks#custom-hooks-help-you-migrate-to-better-patterns)

---

## Bientôt

- Le hook `use()` peut être utilisé avec n'importe quel `promise`, pour obtenir des données
- **Spécial:** n'a pas besoin d'être défini au top niveau
  - peut être utilisé dans des boucles, des conditions
- Disponible en React 19+

---

## Obtenir données via un événement

- Pour un chargement géré par un événement, c'est simple et direct.
- Pas besoin de `useEffect`, ou de `use`.
- La pureté n'est nécessaire que pour le rendu.

<Sandpack files={cssMcu} >

```jsx src/App.js active
import { useState } from 'react';
import DisplayMovies from './DisplayMovies';

export default function App() {
  const [movies, setMovies] = useState([]);

  async function getMovies() {
    //get the data
    const response = await fetch('https://mcuapi.herokuapp.com/api/v1/movies');
    const data = await response.json();

    //sort movies by release date
    const sortedMovies = data.data.toSorted(
      (a, b) =>
        new Date(a.release_date).valueOf() - //
        new Date(b.release_date).valueOf()
    );

    //update the state, (schedules a re-render)
    setMovies(sortedMovies);
  }

  return (
    <>
      <h1>MCU Movies</h1>
      <button onClick={getMovies}>Refresh Movies</button>
      <DisplayMovies movies={movies} />
    </>
  );
}
```

```jsx src/DisplayMovies.jsx
export default function DisplayMovies({ movies, loading }) {
  if (loading) return <div>Loading...</div>;
  return movies.length > 0 ? (
    <div className='movieCards'>
      {movies.map((movie) => (
        <div key={movie.id}>
          <h3>{movie.title}</h3>
          <img src={movie.cover_url} />
          <p>
            <b>Release date: </b>
            {new Date(movie.release_date).toLocaleDateString()}
          </p>
          <p>{movie.overview}</p>
        </div>
      ))}
    </div>
  ) : (
    <div>No movies yet</div>
  );
}
```

</Sandpack>

---

## Ajouter la gestion des erreurs à l'événement

On ajoute un "état" `error` pour gérer les erreur.

<Sandpack files={cssMcu} >

```jsx src/App.js active
import { useState } from 'react';
import DisplayMovies from './DisplayMovies';
import DisplayError from './DisplayError';

export default function App() {
  const [movies, setMovies] = useState([]);
  const [error, setError] = useState();

  async function getMovies() {
    try {
      //get the data
      const response = await fetch(
        'https://mcuapi.herokuapp.com/api/v1/movies'
      );
      const data = await response.json();

      //sort movies by release date
      const sortedMovies = data.data.toSorted(
        (a, b) =>
          new Date(a.release_date).valueOf() -
          new Date(b.release_date).valueOf()
      );

      setMovies(sortedMovies);
    } catch (err) {
      setError(err);
    }
  }

  if (error) {
    return <DisplayError error={error} />;
  }

  return (
    <>
      <h1>MCU Movies</h1>
      <button onClick={getMovies}>Refresh Movies</button>
      <DisplayMovies movies={movies} />
    </>
  );
}
```

```jsx src/DisplayMovies.jsx
export default function DisplayMovies({ movies, loading }) {
  if (loading) return <div>Loading...</div>;
  return movies.length > 0 ? (
    <div className='movieCards'>
      {movies.map((movie) => (
        <div key={movie.id}>
          <h3>{movie.title}</h3>
          <img src={movie.cover_url} />
          <p>
            <b>Release date: </b>
            {new Date(movie.release_date).toLocaleDateString()}
          </p>
          <p>{movie.overview}</p>
        </div>
      ))}
    </div>
  ) : (
    <div>No movies yet</div>
  );
}
```

```jsx src/DisplayError.jsx
export default function DisplayError({ error }) {
  return (
    <>
      <div>There is an error:</div>
      <div style={{ color: 'red', fontFamily: 'monospace' }}>
        {error.message}
      </div>
    </>
  );
}
```

</Sandpack>

---

## Ajouter un visuel de chargement à l'événement

- On ajoute un état `loading`

<Sandpack files={cssMcu} >

```jsx src/App.js active
import { useState } from 'react';
import DisplayMovies from './DisplayMovies';
import DisplayError from './DisplayError';

export default function App() {
  const [movies, setMovies] = useState([]);
  const [error, setError] = useState();
  const [loading, setLoading] = useState(false);

  async function getMovies() {
    setLoading(true);

    //Artificial delay of 1 second
    await new Promise((resolve) => {
      setTimeout(resolve, 1000);
    });

    try {
      //get the data
      const response = await fetch(
        'https://mcuapi.herokuapp.com/api/v1/movies'
      );
      const data = await response.json();

      //sort movies by release date
      const sortedMovies = data.data.toSorted(
        (a, b) =>
          new Date(a.release_date).valueOf() -
          new Date(b.release_date).valueOf()
      );

      setMovies(sortedMovies);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  }

  if (error) {
    return <DisplayError error={error} />;
  }

  return (
    <>
      <h1>MCU Movies</h1>
      <button onClick={getMovies}>Refresh Movies</button>
      <DisplayMovies movies={movies} loading={loading} />
    </>
  );
}
```

```jsx src/DisplayMovies.jsx
export default function DisplayMovies({ movies, loading }) {
  if (loading)
    return (
      <div>
        <span className='spinner' /> Loading...
      </div>
    );
  return movies.length > 0 ? (
    <div className='movieCards'>
      {movies.map((movie) => (
        <div key={movie.id}>
          <h3>{movie.title}</h3>
          <img src={movie.cover_url} />
          <p>
            <b>Release date: </b>
            {new Date(movie.release_date).toLocaleDateString()}
          </p>
          <p>{movie.overview}</p>
        </div>
      ))}
    </div>
  ) : (
    <div>No movies yet</div>
  );
}
```

```jsx src/DisplayError.jsx
export default function DisplayError({ error }) {
  return (
    <>
      <div>There is an error:</div>
      <div style={{ color: 'red', fontFamily: 'monospace' }}>
        {error.message}
      </div>
    </>
  );
}
```

</Sandpack>

---

## Fetch avec Effect

- On ne peut appeler `getData` pendant le rendu
- Sinon, notre fonction est impure. (C'est un effet de bord)
- On peut utiliser `useEffect` pour appeler `getData` après le rendu

<Sandpack files={cssMcu}  >

```jsx src/App.js active
import { useState, useEffect } from 'react';
import DisplayMovies from './DisplayMovies';
import DisplayError from './DisplayError';

export default function App() {
  const [movies, setMovies] = useState([]);
  const [error, setError] = useState();
  const [loading, setLoading] = useState(false);

  async function getMovies() {
    setLoading(true);

    //Artificial delay of 1 second
    await new Promise((resolve) => {
      setTimeout(resolve, 1000);
    });

    try {
      //get the data
      const response = await fetch(
        'https://mcuapi.herokuapp.com/api/v1/movies'
      );
      const data = await response.json();

      //sort movies by release date
      const sortedMovies = data.data.toSorted(
        (a, b) =>
          new Date(a.release_date).valueOf() -
          new Date(b.release_date).valueOf()
      );

      setMovies(sortedMovies);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    getMovies();
  }, []); //runs only after first render

  if (error) {
    return <DisplayError error={error} />;
  }

  return (
    <>
      <h1>MCU Movies</h1>
      <button onClick={getMovies}>Refresh Movies</button>
      <DisplayMovies movies={movies} loading={loading} />
    </>
  );
}
```

```jsx src/DisplayMovies.jsx
export default function DisplayMovies({ movies, loading }) {
  if (loading) {
    return (
      <div>
        <span className='spinner' /> Loading
      </div>
    );
  }
  return movies.length > 0 ? (
    <div className='movieCards'>
      {movies.map((movie) => (
        <div key={movie.id}>
          <h3>{movie.title}</h3>
          <img src={movie.cover_url} />
          <p>
            <b>Release date: </b>
            {new Date(movie.release_date).toLocaleDateString()}
          </p>
          <p>{movie.overview}</p>
        </div>
      ))}
    </div>
  ) : (
    <div>No movies yet</div>
  );
}
```

```jsx src/DisplayError.jsx
export default function DisplayError({ error }) {
  return (
    <>
      <div>There is an error:</div>
      <div style={{ color: 'red', fontFamily: 'monospace' }}>
        {error.message}
      </div>
    </>
  );
}
```

</Sandpack>

---

## Charger avec un hook personnalisé

- `useApi` isole le code qui charge
- En production, `useApi` utiliserait du caching pour réduire le nombre d'appels réseaux

<Sandpack files={cssMcu} >

```jsx src/App.js active
import useApi from './useApi';
import DisplayMovies from './DisplayMovies';
import DisplayError from './DisplayError';

export default function App() {
  const { data, error, loading, reload } = useApi(
    'https://mcuapi.herokuapp.com/api/v1/movies',
    { delay: 1000 }
  );

  if (error) return <DisplayError error={error} />;

  const unsortedMovies = data?.data ?? [];
  //sort movies by release date
  const sortedMovies = unsortedMovies.toSorted(
    (a, b) =>
      new Date(a.release_date).valueOf() - //
      new Date(b.release_date).valueOf()
  );

  return (
    <>
      <h1>MCU Movies</h1>
      <button onClick={reload}>Refresh Movies</button>
      <DisplayMovies movies={sortedMovies} loading={loading} />
    </>
  );
}
```

```js src/useApi.js
import { useState, useEffect } from 'react';
//This code is missing caching
//useQuery from "TanStack Query" has caching

export default function useApi(endpoint, options) {
  const [data, setData] = useState();
  const [error, setError] = useState();
  const [loading, setLoading] = useState(false);

  const { delay, ...rest } = options ?? {};

  async function loadData() {
    setLoading(true);

    //Artificial delay
    if (delay) {
      await new Promise((resolve) => {
        setTimeout(resolve, delay);
      });
    }

    try {
      const res = await fetch(endpoint);
      const data = await res.json();
      setData(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    loadData();
  }, [endpoint, delay]);

  return { data, error, loading, reload: loadData };
}
```

```jsx src/DisplayMovies.jsx
export default function DisplayMovies({ movies, loading }) {
  if (loading) {
    return (
      <div>
        <span className='spinner' /> Loading
      </div>
    );
  }
  return movies.length > 0 ? (
    <div className='movieCards'>
      {movies.map((movie) => (
        <div key={movie.id}>
          <h3>{movie.title}</h3>
          <img src={movie.cover_url} />
          <p>
            <b>Release date: </b>
            {new Date(movie.release_date).toLocaleDateString()}
          </p>
          <p>{movie.overview}</p>
        </div>
      ))}
    </div>
  ) : (
    <div>No movies yet</div>
  );
}
```

```jsx src/DisplayError.jsx
export default function DisplayError({ error }) {
  return (
    <>
      <div>There is an error:</div>
      <div style={{ color: 'red', fontFamily: 'monospace' }}>
        {error.message}
      </div>
    </>
  );
}
```

</Sandpack >

---

## Suspense et use dans la prochaine version de React

- `use` permet d'appeler une promesse pendant rendu
- `use` interrompt le rendu quand la promesse n'est pas encore complétée
- et cela interrompt le rendu du parent, grand-parent et ainsi de suite
- l'interruption remonte l'arboresence jusqu'au `<suspense>`, qui fait un rendu du `fallback`
- Quand la promesse complète, on fait un nouveau rendu du `<suspense>`

<Sandpack v19 files={cssMcu}>

```jsx src/App.js active
import { use, Suspense } from 'react';
import DisplayMovies from './DisplayMovies';
import DisplayError from './DisplayError';
import useRerender from './useRerender';
import { fetchData } from './fetchData';

const url = 'https://mcuapi.herokuapp.com/api/v1/movies';

export default function App() {
  //Because there is no caching in this version,
  //any rerender will trigger a new network call
  //This is bad, React will show warning
  const forceRerender = useRerender();

  return (
    <>
      <h1>MCU Movies</h1>
      <button onClick={forceRerender}>Force Rerender</button>

      <Suspense fallback={<div>Loading...</div>}>
        <Movies />
      </Suspense>
    </>
  );
}

function Movies() {
  const rawData = use(fetchData(url, 1000));
  if (rawData.error) return <DisplayError error={rawData.error} />;

  const movies = rawData.data.toSorted(
    (a, b) =>
      new Date(a.release_date).valueOf() - //
      new Date(b.release_date).valueOf()
  );

  return <DisplayMovies movies={movies} />;
}
```

```js src/fetchData.js
//this fetchData uses NO caching
export function fetchData(url, options) {
  return getData(url, options);
}

async function getData(url, options) {
  const { delay, ...rest } = options ?? {};

  //Artificial delay
  if (delay) {
    await new Promise((resolve) => {
      setTimeout(resolve, delay);
    });
  }

  try {
    const response = await fetch(url, rest);
    return await response.json();
  } catch (err) {
    return { error: err };
  }
}
```

```jsx src/useRerender.jsx
import { useState } from 'react';

export default function useRerender() {
  const [, setRerender] = useState();

  function forceRerender() {
    setRerender({});
  }

  return forceRerender;
}
```

```jsx src/DisplayMovies.jsx
export default function DisplayMovies({ movies }) {
  return movies.length > 0 ? (
    <div className='movieCards'>
      {movies.map((movie) => (
        <div key={movie.id}>
          <h3>{movie.title}</h3>
          <img src={movie.cover_url} />
          <p>
            <b>Release date: </b>
            {new Date(movie.release_date).toLocaleDateString()}
          </p>
          <p>{movie.overview}</p>
        </div>
      ))}
    </div>
  ) : (
    <div>No movies yet</div>
  );
}
```

```jsx src/DisplayError.jsx
export default function DisplayError({ error }) {
  return (
    <>
      <div>There is an error:</div>
      <div style={{ color: 'red', fontFamily: 'monospace' }}>
        {error.message}
      </div>
    </>
  );
}
```

</Sandpack>

---

## Chargement avec React 19 avec caching

<Sandpack v19 files={cssMcu} >

```jsx src/App.js active
import { use, Suspense } from 'react';
import DisplayMovies from './DisplayMovies';
import DisplayError from './DisplayError';
import useRerender from './useRerender';
import { fetchData } from './fetchData';

const url = 'https://mcuapi.herokuapp.com/api/v1/movies';

export default function App() {
  const forceRerender = useRerender();

  return (
    <>
      <h1>MCU Movies</h1>
      <button onClick={forceRerender}>Force Rerender</button>

      <Suspense fallback={<div className='spinner'></div>}>
        <Movies />
      </Suspense>
    </>
  );
}

function Movies() {
  const rawData = use(fetchData(url, { delay: 1000 }));
  if (rawData.error) return <DisplayError error={rawData.error} />;

  const movies = rawData.data.toSorted(
    (a, b) =>
      new Date(a.release_date).valueOf() - //
      new Date(b.release_date).valueOf()
  );

  return <DisplayMovies movies={movies} />;
}
```

```jsx src/fetchData.js
let cache = new Map();

//this fetchData uses simple caching
export function fetchData(url, options) {
  if (!cache.has(url)) {
    cache.set(url, getData(url, options));
  }
  return cache.get(url);
}

async function getData(url, options) {
  const { delay, ...rest } = options ?? {};

  //artificial delay
  if (delay) {
    await new Promise((resolve) => {
      setTimeout(resolve, delay);
    });
  }

  try {
    const response = await fetch(url, rest);
    return await response.json();
  } catch (err) {
    return { error: err };
  }
}

export function removeFromCache(url) {
  if (cache.has(url)) {
    cache.delete(url);
  }
}
```

```jsx src/useRerender.jsx
import { useState } from 'react';

export default function useRerender() {
  const [, setRerender] = useState();

  function forceRerender() {
    setRerender({});
  }

  return forceRerender;
}
```

```jsx src/DisplayMovies.jsx
export default function DisplayMovies({ movies }) {
  return movies.length > 0 ? (
    <div className='movieCards'>
      {movies.map((movie) => (
        <div key={movie.id}>
          <h3>{movie.title}</h3>
          <img src={movie.cover_url} />
          <p>
            <b>Release date: </b>
            {new Date(movie.release_date).toLocaleDateString()}
          </p>
          <p>{movie.overview}</p>
        </div>
      ))}
    </div>
  ) : (
    <div>No movies yet</div>
  );
}
```

```jsx src/DisplayError.jsx
export default function DisplayError({ error }) {
  return (
    <>
      <div>There is an error:</div>
      <div style={{ color: 'red', fontFamily: 'monospace' }}>
        {error.message}
      </div>
    </>
  );
}
```

</Sandpack>

---

## Vider la cache

On ajoute un bouton qui vide la cache

<Sandpack v19 files={cssMcu} >

```jsx src/App.js active
import { use, Suspense } from 'react';
import DisplayMovies from './DisplayMovies';
import DisplayError from './DisplayError';
import useRerender from './useRerender';
import { fetchData, removeFromCache } from './fetchData';

const url = 'https://mcuapi.herokuapp.com/api/v1/movies';

export default function App() {
  const forceRerender = useRerender();

  return (
    <>
      <h1>MCU Movies</h1>
      <button onClick={forceRerender}>Force Rerender</button>
      <button onClick={() => removeFromCache(url)}>
        Empty results from cache
      </button>

      <Suspense fallback={<div className='spinner'></div>}>
        <Movies />
      </Suspense>
    </>
  );
}

function Movies() {
  const rawData = use(fetchData(url, { delay: 1000 }));
  if (rawData.error) return <DisplayError error={rawData.error} />;
  const movies = rawData.data.toSorted(
    (a, b) =>
      new Date(a.release_date).valueOf() - //
      new Date(b.release_date).valueOf()
  );
  return <DisplayMovies movies={movies} />;
}
```

```jsx src/fetchData.js
let cache = new Map();

//this fetchData uses simple caching
export function fetchData(url, options) {
  if (!cache.has(url)) {
    cache.set(url, getData(url, options));
  }
  return cache.get(url);
}

async function getData(url, options) {
  const { delay, ...rest } = options ?? {};

  //artificial delay
  if (delay) {
    await new Promise((resolve) => {
      setTimeout(resolve, delay);
    });
  }

  try {
    const response = await fetch(url, rest);
    return await response.json();
  } catch (err) {
    return { error: err };
  }
}

export function removeFromCache(url) {
  if (cache.has(url)) {
    cache.delete(url);
  }
}
```

```jsx src/useRerender.jsx
import { useState } from 'react';

export default function useRerender() {
  const [, setRerender] = useState();

  function forceRerender() {
    setRerender({});
  }

  return forceRerender;
}
```

```jsx src/DisplayMovies.jsx
export default function DisplayMovies({ movies }) {
  return movies.length > 0 ? (
    <div className='movieCards'>
      {movies.map((movie) => (
        <div key={movie.id}>
          <h3>{movie.title}</h3>
          <img src={movie.cover_url} />
          <p>
            <b>Release date: </b>
            {new Date(movie.release_date).toLocaleDateString()}
          </p>
          <p>{movie.overview}</p>
        </div>
      ))}
    </div>
  ) : (
    <div>No movies yet</div>
  );
}
```

```jsx src/DisplayError.jsx
export default function DisplayError({ error }) {
  return (
    <>
      <div>There is an error:</div>
      <div style={{ color: 'red', fontFamily: 'monospace' }}>
        {error.message}
      </div>
    </>
  );
}
```

</Sandpack>

---

## Exemple d'un appel simple avec Suspense

<Sandpack v19>

```js src/App.js
import { useState } from 'react';
import ArtistPage from './ArtistPage.js';

export default function App() {
  const [show, setShow] = useState(false);
  if (show) {
    return (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  } else {
    return (
      <button onClick={() => setShow(true)}>
        Open The Beatles artist page
      </button>
    );
  }
}
```

```js src/ArtistPage.js active
import { Suspense } from 'react';
import Albums from './Albums.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<Loading />}>
        <Albums artistId={artist.id} />
      </Suspense>
    </>
  );
}

function Loading() {
  return (
    <h2>
      <span className='spinner'></span> Loading...
    </h2>
  );
}
```

```js src/Albums.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Albums({ artistId }) {
  const albums = use(fetchData(`/${artistId}/albums`));
  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>
          {album.title} ({album.year})
        </li>
      ))}
    </ul>
  );
}
```

```js src/data.js
// Note: the way you would do data fetching depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url === '/the-beatles/albums') {
    return await getAlbums();
  } else {
    throw Error('Not implemented');
  }
}

async function getAlbums() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 3000);
  });

  return [
    {
      id: 13,
      title: 'Let It Be',
      year: 1970,
    },
    {
      id: 12,
      title: 'Abbey Road',
      year: 1969,
    },
    {
      id: 11,
      title: 'Yellow Submarine',
      year: 1969,
    },
    {
      id: 10,
      title: 'The Beatles',
      year: 1968,
    },
    {
      id: 9,
      title: 'Magical Mystery Tour',
      year: 1967,
    },
    {
      id: 8,
      title: "Sgt. Pepper's Lonely Hearts Club Band",
      year: 1967,
    },
    {
      id: 7,
      title: 'Revolver',
      year: 1966,
    },
    {
      id: 6,
      title: 'Rubber Soul',
      year: 1965,
    },
    {
      id: 5,
      title: 'Help!',
      year: 1965,
    },
    {
      id: 4,
      title: 'Beatles For Sale',
      year: 1964,
    },
    {
      id: 3,
      title: "A Hard Day's Night",
      year: 1964,
    },
    {
      id: 2,
      title: 'With The Beatles',
      year: 1963,
    },
    {
      id: 1,
      title: 'Please Please Me',
      year: 1963,
    },
  ];
}
```

```css
.spinner {
  display: inline-block;
  width: 2em;
  height: 2em;
  vertical-align: -0.125em;
  border-radius: 50%;
  animation: 0.75s linear infinite spinner;
  border: 0.25em solid currentcolor;
  border-right-color: transparent;
}

@keyframes spinner {
  to {
    transform: rotate(360deg) /* rtl:ignore */;
  }
}
```

</Sandpack>

---

## Exemple d'un suspense pour deux appels en cascade

Les deux appels sont en cascades, mais le rendu apparait une fois les 2 complétés

<Sandpack v19>

```js src/App.js
import { useState } from 'react';
import ArtistPage from './ArtistPage.js';

export default function App() {
  const [show, setShow] = useState(false);
  if (show) {
    return (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  } else {
    return (
      <button onClick={() => setShow(true)}>
        Open The Beatles artist page
      </button>
    );
  }
}
```

```js src/ArtistPage.js active
import { Suspense } from 'react';
import Albums from './Albums.js';
import Biography from './Biography.js';
import Panel from './Panel.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<Loading />}>
        <Biography artistId={artist.id} />
        <Panel>
          <Albums artistId={artist.id} />
        </Panel>
      </Suspense>
    </>
  );
}

function Loading() {
  return (
    <h2>
      <span className='spinner' /> Loading...
    </h2>
  );
}
```

```js src/Panel.js
export default function Panel({ children }) {
  return <section className='panel'>{children}</section>;
}
```

```js src/Biography.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Biography({ artistId }) {
  const bio = use(fetchData(`/${artistId}/bio`));
  return (
    <section>
      <p className='bio'>{bio}</p>
    </section>
  );
}
```

```js src/Albums.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Albums({ artistId }) {
  const albums = use(fetchData(`/${artistId}/albums`));
  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>
          {album.title} ({album.year})
        </li>
      ))}
    </ul>
  );
}
```

```js src/data.js
// Note: the way you would do data fetching depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url === '/the-beatles/albums') {
    return await getAlbums();
  } else if (url === '/the-beatles/bio') {
    return await getBio();
  } else {
    throw Error('Not implemented');
  }
}

async function getBio() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 1500);
  });

  return `The Beatles were an English rock band, 
    formed in Liverpool in 1960, that comprised 
    John Lennon, Paul McCartney, George Harrison 
    and Ringo Starr.`;
}

async function getAlbums() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 3000);
  });

  return [
    {
      id: 13,
      title: 'Let It Be',
      year: 1970,
    },
    {
      id: 12,
      title: 'Abbey Road',
      year: 1969,
    },
    {
      id: 11,
      title: 'Yellow Submarine',
      year: 1969,
    },
    {
      id: 10,
      title: 'The Beatles',
      year: 1968,
    },
    {
      id: 9,
      title: 'Magical Mystery Tour',
      year: 1967,
    },
    {
      id: 8,
      title: "Sgt. Pepper's Lonely Hearts Club Band",
      year: 1967,
    },
    {
      id: 7,
      title: 'Revolver',
      year: 1966,
    },
    {
      id: 6,
      title: 'Rubber Soul',
      year: 1965,
    },
    {
      id: 5,
      title: 'Help!',
      year: 1965,
    },
    {
      id: 4,
      title: 'Beatles For Sale',
      year: 1964,
    },
    {
      id: 3,
      title: "A Hard Day's Night",
      year: 1964,
    },
    {
      id: 2,
      title: 'With The Beatles',
      year: 1963,
    },
    {
      id: 1,
      title: 'Please Please Me',
      year: 1963,
    },
  ];
}
```

```css
.bio {
  font-style: italic;
}

.panel {
  border: 1px solid #aaa;
  border-radius: 6px;
  margin-top: 20px;
  padding: 10px;
}

.spinner {
  display: inline-block;
  width: 2em;
  height: 2em;
  vertical-align: -0.125em;
  border-radius: 50%;
  animation: 0.75s linear infinite spinner;
  border: 0.25em solid currentcolor;
  border-right-color: transparent;
}

@keyframes spinner {
  to {
    transform: rotate(360deg) /* rtl:ignore */;
  }
}
```

</Sandpack>

---

## Exemple de suspenses imbriqués, pour deux appels en cascade

<Sandpack v19>

```js src/App.js
import { useState } from 'react';
import ArtistPage from './ArtistPage.js';

export default function App() {
  const [show, setShow] = useState(false);
  if (show) {
    return (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  } else {
    return (
      <button onClick={() => setShow(true)}>
        Open The Beatles artist page
      </button>
    );
  }
}
```

```js src/ArtistPage.js active
import { Suspense } from 'react';
import Albums from './Albums.js';
import Biography from './Biography.js';
import Panel from './Panel.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<BigSpinner />}>
        <Biography artistId={artist.id} />
        <Suspense fallback={<AlbumsGlimmer />}>
          <Panel>
            <Albums artistId={artist.id} />
          </Panel>
        </Suspense>
      </Suspense>
    </>
  );
}

function BigSpinner() {
  return (
    <h2>
      <span className='spinner'></span> Loading...
    </h2>
  );
}

function AlbumsGlimmer() {
  return (
    <div className='glimmer-panel'>
      <div className='glimmer-line' />
      <div className='glimmer-line' />
      <div className='glimmer-line' />
    </div>
  );
}
```

```js src/Panel.js
export default function Panel({ children }) {
  return <section className='panel'>{children}</section>;
}
```

```js src/Biography.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Biography({ artistId }) {
  const bio = use(fetchData(`/${artistId}/bio`));
  return (
    <section>
      <p className='bio'>{bio}</p>
    </section>
  );
}
```

```js src/Albums.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Albums({ artistId }) {
  const albums = use(fetchData(`/${artistId}/albums`));
  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>
          {album.title} ({album.year})
        </li>
      ))}
    </ul>
  );
}
```

```js src/data.js
// Note: the way you would do data fetching depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url === '/the-beatles/albums') {
    return await getAlbums();
  } else if (url === '/the-beatles/bio') {
    return await getBio();
  } else {
    throw Error('Not implemented');
  }
}

async function getBio() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 500);
  });

  return `The Beatles were an English rock band, 
    formed in Liverpool in 1960, that comprised 
    John Lennon, Paul McCartney, George Harrison 
    and Ringo Starr.`;
}

async function getAlbums() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 3000);
  });

  return [
    {
      id: 13,
      title: 'Let It Be',
      year: 1970,
    },
    {
      id: 12,
      title: 'Abbey Road',
      year: 1969,
    },
    {
      id: 11,
      title: 'Yellow Submarine',
      year: 1969,
    },
    {
      id: 10,
      title: 'The Beatles',
      year: 1968,
    },
    {
      id: 9,
      title: 'Magical Mystery Tour',
      year: 1967,
    },
    {
      id: 8,
      title: "Sgt. Pepper's Lonely Hearts Club Band",
      year: 1967,
    },
    {
      id: 7,
      title: 'Revolver',
      year: 1966,
    },
    {
      id: 6,
      title: 'Rubber Soul',
      year: 1965,
    },
    {
      id: 5,
      title: 'Help!',
      year: 1965,
    },
    {
      id: 4,
      title: 'Beatles For Sale',
      year: 1964,
    },
    {
      id: 3,
      title: "A Hard Day's Night",
      year: 1964,
    },
    {
      id: 2,
      title: 'With The Beatles',
      year: 1963,
    },
    {
      id: 1,
      title: 'Please Please Me',
      year: 1963,
    },
  ];
}
```

```css
.bio {
  font-style: italic;
}

.panel {
  border: 1px solid #aaa;
  border-radius: 6px;
  margin-top: 20px;
  padding: 10px;
}

.glimmer-panel {
  border: 1px dashed #aaa;
  background: linear-gradient(
    90deg,
    rgba(221, 221, 221, 1) 0%,
    rgba(255, 255, 255, 1) 100%
  );
  border-radius: 6px;
  margin-top: 20px;
  padding: 10px;
}

.glimmer-line {
  display: block;
  width: 60%;
  height: 20px;
  margin: 10px;
  border-radius: 4px;
  background: #f0f0f0;
}

.spinner {
  display: inline-block;
  width: 2em;
  height: 2em;
  vertical-align: -0.125em;
  border-radius: 50%;
  animation: 0.75s linear infinite spinner;
  border: 0.25em solid currentcolor;
  border-right-color: transparent;
}

@keyframes spinner {
  to {
    transform: rotate(360deg) /* rtl:ignore */;
  }
}
```

</Sandpack>

---

## On perd l'affichage pendant le chargement

<Sandpack v19>

```js src/App.js
import { Suspense, useState } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  return (
    <>
      <label>
        Search albums:
        <input value={query} onChange={(e) => setQuery(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <SearchResults query={query} />
      </Suspense>
    </>
  );
}
```

```js src/SearchResults.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function SearchResults({ query }) {
  if (query === '') {
    return null;
  }
  const albums = use(fetchData(`/search?q=${query}`));
  if (albums.length === 0) {
    return (
      <p>
        No matches for <i>"{query}"</i>
      </p>
    );
  }
  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>
          {album.title} ({album.year})
        </li>
      ))}
    </ul>
  );
}
```

```js src/data.js
// Note: the way you would do data fetching depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url.startsWith('/search?q=')) {
    return await getSearchResults(url.slice('/search?q='.length));
  } else {
    throw Error('Not implemented');
  }
}

async function getSearchResults(query) {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 500);
  });

  const allAlbums = [
    {
      id: 13,
      title: 'Let It Be',
      year: 1970,
    },
    {
      id: 12,
      title: 'Abbey Road',
      year: 1969,
    },
    {
      id: 11,
      title: 'Yellow Submarine',
      year: 1969,
    },
    {
      id: 10,
      title: 'The Beatles',
      year: 1968,
    },
    {
      id: 9,
      title: 'Magical Mystery Tour',
      year: 1967,
    },
    {
      id: 8,
      title: "Sgt. Pepper's Lonely Hearts Club Band",
      year: 1967,
    },
    {
      id: 7,
      title: 'Revolver',
      year: 1966,
    },
    {
      id: 6,
      title: 'Rubber Soul',
      year: 1965,
    },
    {
      id: 5,
      title: 'Help!',
      year: 1965,
    },
    {
      id: 4,
      title: 'Beatles For Sale',
      year: 1964,
    },
    {
      id: 3,
      title: "A Hard Day's Night",
      year: 1964,
    },
    {
      id: 2,
      title: 'With The Beatles',
      year: 1963,
    },
    {
      id: 1,
      title: 'Please Please Me',
      year: 1963,
    },
  ];

  const lowerQuery = query.trim().toLowerCase();
  return allAlbums.filter((album) => {
    const lowerTitle = album.title.toLowerCase();
    return (
      lowerTitle.startsWith(lowerQuery) ||
      lowerTitle.indexOf(' ' + lowerQuery) !== -1
    );
  });
}
```

```css
input {
  margin: 10px;
}
```

</Sandpack>

---

## Conserver l'affichage des données grâce à useDeferredValue

`useDeferred` est basé sur une autre valeur. On conserve une copie de la valeur précédente

- `useDeferred` fait deux rendus
- Un premier avec la valeur précédente (sans l'afficher, le "commit")
- Cédule le second avec la nouvelle valeur
  - Si ce second rendu est complété immédiatement, on l'affiche (commit).
  - Sinon (si on suspend), on affiche alors le premier rendu (avec la valeur précédente).
  - On peut utiliser la mémoisation pour éviter le premier rendu

<Sandpack v19>

```js src/App.js
import { Suspense, useState, useDeferredValue } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  const isStale = query !== deferredQuery;
  return (
    <>
      <label>
        Search albums:
        <input value={query} onChange={(e) => setQuery(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <div style={{ opacity: isStale ? 0.5 : 1 }}>
          <SearchResults query={deferredQuery} />
        </div>
      </Suspense>
    </>
  );
}
```

```js src/SearchResults.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function SearchResults({ query }) {
  if (query === '') {
    return null;
  }
  const albums = use(fetchData(`/search?q=${query}`));
  if (albums.length === 0) {
    return (
      <p>
        No matches for <i>"{query}"</i>
      </p>
    );
  }
  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>
          {album.title} ({album.year})
        </li>
      ))}
    </ul>
  );
}
```

```js src/data.js
// Note: the way you would do data fetching depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url.startsWith('/search?q=')) {
    return await getSearchResults(url.slice('/search?q='.length));
  } else {
    throw Error('Not implemented');
  }
}

async function getSearchResults(query) {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 500);
  });

  const allAlbums = [
    {
      id: 13,
      title: 'Let It Be',
      year: 1970,
    },
    {
      id: 12,
      title: 'Abbey Road',
      year: 1969,
    },
    {
      id: 11,
      title: 'Yellow Submarine',
      year: 1969,
    },
    {
      id: 10,
      title: 'The Beatles',
      year: 1968,
    },
    {
      id: 9,
      title: 'Magical Mystery Tour',
      year: 1967,
    },
    {
      id: 8,
      title: "Sgt. Pepper's Lonely Hearts Club Band",
      year: 1967,
    },
    {
      id: 7,
      title: 'Revolver',
      year: 1966,
    },
    {
      id: 6,
      title: 'Rubber Soul',
      year: 1965,
    },
    {
      id: 5,
      title: 'Help!',
      year: 1965,
    },
    {
      id: 4,
      title: 'Beatles For Sale',
      year: 1964,
    },
    {
      id: 3,
      title: "A Hard Day's Night",
      year: 1964,
    },
    {
      id: 2,
      title: 'With The Beatles',
      year: 1963,
    },
    {
      id: 1,
      title: 'Please Please Me',
      year: 1963,
    },
  ];

  const lowerQuery = query.trim().toLowerCase();
  return allAlbums.filter((album) => {
    const lowerTitle = album.title.toLowerCase();
    return (
      lowerTitle.startsWith(lowerQuery) ||
      lowerTitle.indexOf(' ' + lowerQuery) !== -1
    );
  });
}
```

```css
input {
  margin: 10px;
}
```

</Sandpack>

---

## Suspense à un niveau global

Ici, on fait un suspense au niveau du routage complet. Mais la transition n'est pas fluide.

<Sandpack v19>

```js src/App.js
import { Suspense, useState } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
  return (
    <Suspense fallback={<BigSpinner />}>
      <Router />
    </Suspense>
  );
}

function Router() {
  const [page, setPage] = useState('/');

  function navigate(url) {
    setPage(url);
  }

  let content;
  if (page === '/') {
    content = <IndexPage navigate={navigate} />;
  } else if (page === '/the-beatles') {
    content = (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  }
  return <Layout>{content}</Layout>;
}

function BigSpinner() {
  return <h2>🌀 Loading...</h2>;
}
```

```js src/Layout.js
export default function Layout({ children }) {
  return (
    <div className='layout'>
      <section className='header'>Music Browser</section>
      <main>{children}</main>
    </div>
  );
}
```

```js src/IndexPage.js
export default function IndexPage({ navigate }) {
  return (
    <button onClick={() => navigate('/the-beatles')}>
      Open The Beatles artist page
    </button>
  );
}
```

```js src/ArtistPage.js
import { Suspense } from 'react';
import Albums from './Albums.js';
import Biography from './Biography.js';
import Panel from './Panel.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Biography artistId={artist.id} />
      <Suspense fallback={<AlbumsGlimmer />}>
        <Panel>
          <Albums artistId={artist.id} />
        </Panel>
      </Suspense>
    </>
  );
}

function AlbumsGlimmer() {
  return (
    <div className='glimmer-panel'>
      <div className='glimmer-line' />
      <div className='glimmer-line' />
      <div className='glimmer-line' />
    </div>
  );
}
```

```js src/Albums.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Albums({ artistId }) {
  const albums = use(fetchData(`/${artistId}/albums`));
  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>
          {album.title} ({album.year})
        </li>
      ))}
    </ul>
  );
}
```

```js src/Biography.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Biography({ artistId }) {
  const bio = use(fetchData(`/${artistId}/bio`));
  return (
    <section>
      <p className='bio'>{bio}</p>
    </section>
  );
}
```

```js src/Panel.js
export default function Panel({ children }) {
  return <section className='panel'>{children}</section>;
}
```

```js src/data.js
// Note: the way you would do data fetching depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url === '/the-beatles/albums') {
    return await getAlbums();
  } else if (url === '/the-beatles/bio') {
    return await getBio();
  } else {
    throw Error('Not implemented');
  }
}

async function getBio() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 500);
  });

  return `The Beatles were an English rock band, 
    formed in Liverpool in 1960, that comprised 
    John Lennon, Paul McCartney, George Harrison 
    and Ringo Starr.`;
}

async function getAlbums() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 3000);
  });

  return [
    {
      id: 13,
      title: 'Let It Be',
      year: 1970,
    },
    {
      id: 12,
      title: 'Abbey Road',
      year: 1969,
    },
    {
      id: 11,
      title: 'Yellow Submarine',
      year: 1969,
    },
    {
      id: 10,
      title: 'The Beatles',
      year: 1968,
    },
    {
      id: 9,
      title: 'Magical Mystery Tour',
      year: 1967,
    },
    {
      id: 8,
      title: "Sgt. Pepper's Lonely Hearts Club Band",
      year: 1967,
    },
    {
      id: 7,
      title: 'Revolver',
      year: 1966,
    },
    {
      id: 6,
      title: 'Rubber Soul',
      year: 1965,
    },
    {
      id: 5,
      title: 'Help!',
      year: 1965,
    },
    {
      id: 4,
      title: 'Beatles For Sale',
      year: 1964,
    },
    {
      id: 3,
      title: "A Hard Day's Night",
      year: 1964,
    },
    {
      id: 2,
      title: 'With The Beatles',
      year: 1963,
    },
    {
      id: 1,
      title: 'Please Please Me',
      year: 1963,
    },
  ];
}
```

```css
main {
  min-height: 200px;
  padding: 10px;
}

.layout {
  border: 1px solid black;
}

.header {
  background: #222;
  padding: 10px;
  text-align: center;
  color: white;
}

.bio {
  font-style: italic;
}

.panel {
  border: 1px solid #aaa;
  border-radius: 6px;
  margin-top: 20px;
  padding: 10px;
}

.glimmer-panel {
  border: 1px dashed #aaa;
  background: linear-gradient(
    90deg,
    rgba(221, 221, 221, 1) 0%,
    rgba(255, 255, 255, 1) 100%
  );
  border-radius: 6px;
  margin-top: 20px;
  padding: 10px;
}

.glimmer-line {
  display: block;
  width: 60%;
  height: 20px;
  margin: 10px;
  border-radius: 4px;
  background: #f0f0f0;
}
```

</Sandpack>

---

## StartTransition à la rescousse

StartTransition indique un changement de State non-bloquant, qui n'est pas urgent. Si un autre événement lance un setState, le rendu de transition est interrompu (et redémarré plus tard, un fois le traitement de l'événement terminé).

<Sandpack v19>

```js src/App.js
import { Suspense, startTransition, useState } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
  return (
    <Suspense fallback={<BigSpinner />}>
      <Router />
    </Suspense>
  );
}

function Router() {
  const [page, setPage] = useState('/');

  function navigate(url) {
    startTransition(() => {
      setPage(url);
    });
  }

  let content;
  if (page === '/') {
    content = <IndexPage navigate={navigate} />;
  } else if (page === '/the-beatles') {
    content = (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  }
  return <Layout>{content}</Layout>;
}

function BigSpinner() {
  return <h2>🌀 Loading...</h2>;
}
```

```js src/Layout.js
export default function Layout({ children }) {
  return (
    <div className='layout'>
      <section className='header'>Music Browser</section>
      <main>{children}</main>
    </div>
  );
}
```

```js src/IndexPage.js
export default function IndexPage({ navigate }) {
  return (
    <button onClick={() => navigate('/the-beatles')}>
      Open The Beatles artist page
    </button>
  );
}
```

```js src/ArtistPage.js
import { Suspense } from 'react';
import Albums from './Albums.js';
import Biography from './Biography.js';
import Panel from './Panel.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Biography artistId={artist.id} />
      <Suspense fallback={<AlbumsGlimmer />}>
        <Panel>
          <Albums artistId={artist.id} />
        </Panel>
      </Suspense>
    </>
  );
}

function AlbumsGlimmer() {
  return (
    <div className='glimmer-panel'>
      <div className='glimmer-line' />
      <div className='glimmer-line' />
      <div className='glimmer-line' />
    </div>
  );
}
```

```js src/Albums.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Albums({ artistId }) {
  const albums = use(fetchData(`/${artistId}/albums`));
  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>
          {album.title} ({album.year})
        </li>
      ))}
    </ul>
  );
}
```

```js src/Biography.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Biography({ artistId }) {
  const bio = use(fetchData(`/${artistId}/bio`));
  return (
    <section>
      <p className='bio'>{bio}</p>
    </section>
  );
}
```

```js src/Panel.js
export default function Panel({ children }) {
  return <section className='panel'>{children}</section>;
}
```

```js src/data.js
// Note: the way you would do data fetching depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url === '/the-beatles/albums') {
    return await getAlbums();
  } else if (url === '/the-beatles/bio') {
    return await getBio();
  } else {
    throw Error('Not implemented');
  }
}

async function getBio() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 500);
  });

  return `The Beatles were an English rock band, 
    formed in Liverpool in 1960, that comprised 
    John Lennon, Paul McCartney, George Harrison 
    and Ringo Starr.`;
}

async function getAlbums() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 3000);
  });

  return [
    {
      id: 13,
      title: 'Let It Be',
      year: 1970,
    },
    {
      id: 12,
      title: 'Abbey Road',
      year: 1969,
    },
    {
      id: 11,
      title: 'Yellow Submarine',
      year: 1969,
    },
    {
      id: 10,
      title: 'The Beatles',
      year: 1968,
    },
    {
      id: 9,
      title: 'Magical Mystery Tour',
      year: 1967,
    },
    {
      id: 8,
      title: "Sgt. Pepper's Lonely Hearts Club Band",
      year: 1967,
    },
    {
      id: 7,
      title: 'Revolver',
      year: 1966,
    },
    {
      id: 6,
      title: 'Rubber Soul',
      year: 1965,
    },
    {
      id: 5,
      title: 'Help!',
      year: 1965,
    },
    {
      id: 4,
      title: 'Beatles For Sale',
      year: 1964,
    },
    {
      id: 3,
      title: "A Hard Day's Night",
      year: 1964,
    },
    {
      id: 2,
      title: 'With The Beatles',
      year: 1963,
    },
    {
      id: 1,
      title: 'Please Please Me',
      year: 1963,
    },
  ];
}
```

```css
main {
  min-height: 200px;
  padding: 10px;
}

.layout {
  border: 1px solid black;
}

.header {
  background: #222;
  padding: 10px;
  text-align: center;
  color: white;
}

.bio {
  font-style: italic;
}

.panel {
  border: 1px solid #aaa;
  border-radius: 6px;
  margin-top: 20px;
  padding: 10px;
}

.glimmer-panel {
  border: 1px dashed #aaa;
  background: linear-gradient(
    90deg,
    rgba(221, 221, 221, 1) 0%,
    rgba(255, 255, 255, 1) 100%
  );
  border-radius: 6px;
  margin-top: 20px;
  padding: 10px;
}

.glimmer-line {
  display: block;
  width: 60%;
  height: 20px;
  margin: 10px;
  border-radius: 4px;
  background: #f0f0f0;
}
```

</Sandpack>

---

## useTransition

Permet d'avoir accès à startTransition, ainsi que son état `isPending`.

<Sandpack v19>

```js src/App.js
import { Suspense, useState, useTransition } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
  return (
    <Suspense fallback={<BigSpinner />}>
      <Router />
    </Suspense>
  );
}

function Router() {
  const [page, setPage] = useState('/');
  const [isPending, startTransition] = useTransition();

  function navigate(url) {
    startTransition(() => {
      setPage(url);
    });
  }

  let content;
  if (page === '/') {
    content = <IndexPage navigate={navigate} />;
  } else if (page === '/the-beatles') {
    content = (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  }
  return <Layout isPending={isPending}>{content}</Layout>;
}

function BigSpinner() {
  return <h2>🌀 Loading...</h2>;
}
```

```js src/Layout.js
export default function Layout({ children, isPending }) {
  return (
    <div className='layout'>
      <section
        className='header'
        style={{
          opacity: isPending ? 0.7 : 1,
        }}
      >
        Music Browser
      </section>
      <main>{children}</main>
    </div>
  );
}
```

```js src/IndexPage.js
export default function IndexPage({ navigate }) {
  return (
    <button onClick={() => navigate('/the-beatles')}>
      Open The Beatles artist page
    </button>
  );
}
```

```js src/ArtistPage.js
import { Suspense } from 'react';
import Albums from './Albums.js';
import Biography from './Biography.js';
import Panel from './Panel.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Biography artistId={artist.id} />
      <Suspense fallback={<AlbumsGlimmer />}>
        <Panel>
          <Albums artistId={artist.id} />
        </Panel>
      </Suspense>
    </>
  );
}

function AlbumsGlimmer() {
  return (
    <div className='glimmer-panel'>
      <div className='glimmer-line' />
      <div className='glimmer-line' />
      <div className='glimmer-line' />
    </div>
  );
}
```

```js src/Albums.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Albums({ artistId }) {
  const albums = use(fetchData(`/${artistId}/albums`));
  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>
          {album.title} ({album.year})
        </li>
      ))}
    </ul>
  );
}
```

```js src/Biography.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Biography({ artistId }) {
  const bio = use(fetchData(`/${artistId}/bio`));
  return (
    <section>
      <p className='bio'>{bio}</p>
    </section>
  );
}
```

```js src/Panel.js
export default function Panel({ children }) {
  return <section className='panel'>{children}</section>;
}
```

```js src/data.js hidden
// Note: the way you would do data fetching depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url === '/the-beatles/albums') {
    return await getAlbums();
  } else if (url === '/the-beatles/bio') {
    return await getBio();
  } else {
    throw Error('Not implemented');
  }
}

async function getBio() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 500);
  });

  return `The Beatles were an English rock band, 
    formed in Liverpool in 1960, that comprised 
    John Lennon, Paul McCartney, George Harrison 
    and Ringo Starr.`;
}

async function getAlbums() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 3000);
  });

  return [
    {
      id: 13,
      title: 'Let It Be',
      year: 1970,
    },
    {
      id: 12,
      title: 'Abbey Road',
      year: 1969,
    },
    {
      id: 11,
      title: 'Yellow Submarine',
      year: 1969,
    },
    {
      id: 10,
      title: 'The Beatles',
      year: 1968,
    },
    {
      id: 9,
      title: 'Magical Mystery Tour',
      year: 1967,
    },
    {
      id: 8,
      title: "Sgt. Pepper's Lonely Hearts Club Band",
      year: 1967,
    },
    {
      id: 7,
      title: 'Revolver',
      year: 1966,
    },
    {
      id: 6,
      title: 'Rubber Soul',
      year: 1965,
    },
    {
      id: 5,
      title: 'Help!',
      year: 1965,
    },
    {
      id: 4,
      title: 'Beatles For Sale',
      year: 1964,
    },
    {
      id: 3,
      title: "A Hard Day's Night",
      year: 1964,
    },
    {
      id: 2,
      title: 'With The Beatles',
      year: 1963,
    },
    {
      id: 1,
      title: 'Please Please Me',
      year: 1963,
    },
  ];
}
```

```css
main {
  min-height: 200px;
  padding: 10px;
}

.layout {
  border: 1px solid black;
}

.header {
  background: #222;
  padding: 10px;
  text-align: center;
  color: white;
}

.bio {
  font-style: italic;
}

.panel {
  border: 1px solid #aaa;
  border-radius: 6px;
  margin-top: 20px;
  padding: 10px;
}

.glimmer-panel {
  border: 1px dashed #aaa;
  background: linear-gradient(
    90deg,
    rgba(221, 221, 221, 1) 0%,
    rgba(255, 255, 255, 1) 100%
  );
  border-radius: 6px;
  margin-top: 20px;
  padding: 10px;
}

.glimmer-line {
  display: block;
  width: 60%;
  height: 20px;
  margin: 10px;
  border-radius: 4px;
  background: #f0f0f0;
}
```

</Sandpack>

---

## Calling an API the classic way

<Sandpack>

```js src/ContactApi.js
// This encapsulates calls to the Rest API.
// GetAllContacts()
// getContact(id)
// saveContact(contact) //(create and update)
// deleteContact(id)
// registerNotification(fn)
// unregisterNotification(fn)
// resetContacts()

const base = 'https://contacts.reactacademy.live/api';

export default class ContactApi {
  static ws = null; //WebSocket for notifications

  static getAllContacts() {
    return fetch(`${base}/contacts`).then((resp) => resp.json());
  }

  static getContact(contactId) {
    return fetch(`${base}/contacts/${contactId}`).then((resp) => resp.json());
  }

  static saveContact(contact) {
    // Simulate server-side validation

    const minContactLength = 3;
    if (contact.firstName.length < minContactLength) {
      throw new Error(
        `First Name must be at least ${minContactLength} characters.`
      );
    }

    if (contact.lastName.length < minContactLength) {
      throw new Error(
        `Last Name must be at least ${minContactLength} characters.`
      );
    }

    if (contact.id) {
      //if id, update contact
      return fetch(`${base}/contacts/${contact.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(contact), // body data type must match "Content-Type" header
      });
    } else {
      //if no id, create contact
      return fetch(`${base}/contacts`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(contact), // body data type must match "Content-Type" header
      }).then((resp) => resp.json());
    }
  }

  static deleteContact(contactId) {
    return fetch(`${base}/contacts/${contactId}`, { method: 'DELETE' });
  }

  static async registerNotification(fn) {
    if (this.ws === null) {
      // this.ws = {};
      const res = await fetch(`${base}/negotiate`);
      const url = await res.json();
      this.ws = new WebSocket(url.url);

      this.ws.onopen = () => console.log('connected');

      this.ws.onmessage = () => {
        fn();
      };
    }
  }

  static async unregisterNotification() {
    if (this.ws !== null) {
      this.ws.close();
      this.ws = null;
    }
  }
  static resetContacts() {
    return fetch(`${base}/contacts/reset`);
  }
}
```

```jsx src/App.js
import { useEffect, useState } from 'react';
import ContactApi from './ContactApi';
import ContactTable from './ContactTable';

export default function App() {
  return <ContactContainer />;
}

function ContactContainer() {
  const [contacts, setContacts] = useState([]);
  const [loading, setLoading] = useState(false);

  // Effect to show data after first render
  useEffect(() => {
    refreshData();
  }, []);

  // Effect to register for change notification
  // useEffect(() => {
  //   ContactApi.registerNotification(refreshData);
  //   return () => {
  //     ContactApi.unregisterNotification();
  //   };
  // }, []);

  // This calls data (async)
  async function refreshData() {
    try {
      setLoading(true);
      await new Promise((resolve) => {
        setTimeout(resolve, 1500);
      });
      const data = await ContactApi.getAllContacts();
      setContacts(data);
    } catch (err) {
      console.log(err);
    } finally {
      setLoading(false);
    }
  }

  async function modifyContact(formData) {
    const contact = Object.fromEntries(formData);
    if (contact.id === '0') contact.id = 0;
    if (contact.id === null) return;
    await ContactApi.saveContact(contact);
    await refreshData();
  }

  async function deleteContact(id) {
    await ContactApi.deleteContact(id);
    refreshData();
  }

  return (
    <>
      <h1>Contacts (using Hooks)</h1>

      {loading ? (
        <div className='spinner' />
      ) : (
        <ContactTable
          contacts={contacts}
          modifyContact={modifyContact}
          deleteContact={deleteContact}
        />
      )}
    </>
  );
}
```

```jsx src/ContactTable.jsx
import { useState } from 'react';

export default function ContactTable({
  contacts,
  modifyContact,
  deleteContact,
}) {
  const [modificationRow, setModificationRow] = useState(null);

  function modifyRow(id) {
    setModificationRow(id);
  }

  return (
    <form
      onSubmit={async (evt) => {
        evt.preventDefault();
        setModificationRow(null);
        modifyContact(new FormData(evt.currentTarget));
      }}
    >
      <table>
        <thead>
          <tr>
            <th style={{ maxWidth: 70 }}>id</th>
            <th>First Name</th>
            <th>Last Name</th>
            <th>Email</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {contacts.map((contact) =>
            contact.id === modificationRow ? (
              <EditRow key={contact.id} contact={contact} setRow={modifyRow} />
            ) : (
              <Row
                key={contact.id}
                contact={contact}
                setRow={modifyRow}
                deleteContact={deleteContact}
              />
            )
          )}
        </tbody>
        <tfoot>
          {modificationRow === 0 ? (
            <EditRow
              contact={{ id: 0, firstName: '', lastName: '', email: '' }}
              setRow={modifyRow}
            />
          ) : (
            <tr>
              <td colSpan={5}>
                <button
                  title='Create Contact'
                  type='button'
                  onClick={() => {
                    setModificationRow(0);
                  }}
                >
                  ➕ Create Contact
                </button>
              </td>
            </tr>
          )}
        </tfoot>
      </table>
    </form>
  );
}

function Row({ contact, setRow, deleteContact }) {
  return (
    <tr key={contact.id}>
      <td
        style={{
          maxWidth: 70,
          whiteSpace: 'nowrap',
          overflow: 'hidden',
          textOverflow: 'ellipsis',
        }}
        title={contact.id.toString()}
      >
        {contact.id}
      </td>
      <td>{contact.firstName}</td>
      <td>{contact.lastName}</td>
      <td>
        <a href={`mailto:{contact.email}`}>{contact.email}</a>
      </td>
      <td style={{ display: 'flex' }}>
        <button
          title='Edit'
          type='button'
          onClick={() => {
            setRow(contact.id);
          }}
        >
          🖊️
        </button>
        <button
          title='Details'
          type='button'
          onClick={() => alert(`goto details for ${contact.firstName}`)}
        >
          🧾
        </button>
        <button
          title='Delete'
          type='button'
          onClick={() => deleteContact(contact.id)}
        >
          🗑️
        </button>
      </td>
    </tr>
  );
}

function EditRow({ contact, setRow }) {
  return (
    <tr key={contact.id} className='bg-warning'>
      <td style={{ maxWidth: 70 }} title={contact.id.toString()}>
        <input name='id' placeholder='ID' defaultValue={contact.id} readOnly />
      </td>
      <td>
        <input
          name='firstName'
          placeholder='First Name'
          defaultValue={contact.firstName}
        />
      </td>
      <td className='align-middle'>
        <input
          name='lastName'
          placeholder='Last Name'
          defaultValue={contact.lastName}
        />
      </td>
      <td className='align-middle'>
        <input
          name='email'
          placeholder='name@email.com'
          defaultValue={contact.email}
        />
      </td>
      <td>
        <button title='Save' type='submit'>
          ✔️
        </button>
        <button
          title='Cancel'
          type='button'
          onClick={() => {
            setRow(null);
          }}
        >
          ❌
        </button>
      </td>
    </tr>
  );
}
```

```css
table {
  border-collapse: collapse;
}

table > * > * > * {
  border-width: 0px;
  border-bottom-width: 1px;
  border-color: #dddddd;
  border-style: solid;
}

table > tbody > tr:nth-of-type(odd) > * {
  background-color: rgba(0, 0, 0, 0.05);
}

table th {
  text-align: left;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.4em 1em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #d9d9d9;
  cursor: pointer;
  transition: border-color 0.25s;
  margin: 0.1em;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

input {
  display: inline-block;
  width: 100%;
  padding: 0.2rem 0.4rem;
  margin: 0.1rem 0rem;
  font-size: 1rem;
  line-height: 1.5;
  color: #495057;
  background-color: #fff;
  background-clip: padding-box;
  border: 1px solid #ced4da;
  border-radius: 0.25rem;
  transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
}

input:focus {
  color: #495057;
  background-color: #fff;
  border-color: #80bdff;
  outline: 0;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.spinner {
  display: inline-block;
  width: 2em;
  height: 2em;
  vertical-align: -0.125em;
  border-radius: 50%;
  animation: 0.75s linear infinite spinner;
  border: 0.25em solid currentcolor;
  border-right-color: transparent;
}

@keyframes spinner {
  to {
    transform: rotate(360deg) /* rtl:ignore */;
  }
}
```

</Sandpack>

---

## Calling an API with React 19

- No useEffects needed

<Sandpack v19>

```js src/ContactApi.js
// This encapsulates calls to the Rest API.
// GetAllContacts()
// getContact(id)
// saveContact(contact) //(create and update)
// deleteContact(id)
// registerNotification(fn)
// unregisterNotification(fn)
// resetContacts()

import { use } from 'react';
import { fetchData, removeFromCache } from './fetchData';

const base = 'https://contacts.reactacademy.live/api';

export default class ContactApi {
  static ws = null; //WebSocket for notifications

  static getAllContacts() {
    return use(fetchData(`${base}/contacts`));
  }

  static async refreshContacts() {
    removeFromCache(`${base}/contacts`);
    await fetchData(`${base}/contacts`, {
      delay: 1500,
    });
  }

  static removeContacts() {
    removeFromCache(`${base}/contacts`);
  }

  static getContact(contactId) {
    return fetch(`${base}/contacts/${contactId}`).then((resp) => resp.json());
  }

  static saveContact(contact) {
    // Simulate server-side validation

    const minContactLength = 3;
    if (contact.firstName.length < minContactLength) {
      throw new Error(
        `First Name must be at least ${minContactLength} characters.`
      );
    }

    if (contact.lastName.length < minContactLength) {
      throw new Error(
        `Last Name must be at least ${minContactLength} characters.`
      );
    }

    if (contact.id) {
      //if id, update contact
      return fetch(`${base}/contacts/${contact.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(contact), // body data type must match "Content-Type" header
      });
    } else {
      //if no id, create contact
      return fetch(`${base}/contacts`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(contact), // body data type must match "Content-Type" header
      }).then((resp) => resp.json());
    }
  }

  static deleteContact(contactId) {
    return fetch(`${base}/contacts/${contactId}`, { method: 'DELETE' });
  }

  static async registerNotification(fn) {
    if (this.ws === null) {
      // this.ws = {};
      const res = await fetch(`${base}/negotiate`);
      const url = await res.json();
      this.ws = new WebSocket(url.url);

      this.ws.onopen = () => console.log('connected');

      this.ws.onmessage = () => {
        fn();
      };
    }
  }

  static async unregisterNotification() {
    if (this.ws !== null) {
      this.ws.close();
      this.ws = null;
    }
  }
  static resetContacts() {
    return fetch(`${base}/contacts/reset`);
  }
}
```

```jsx src/App.js
import { useEffect, useState, Suspense, use } from 'react';
import { removeFromCache, fetchData } from './fetchData';
import useRerender from './useRerender';
import ContactApi from './ContactApi';
import ContactTable from './ContactTable';

export default function App() {
  return (
    <Suspense fallback={<div className='spinner' />}>
      <ContactContainer />
    </Suspense>
  );
}

function ContactContainer() {
  const contacts = ContactApi.getAllContacts();
  const forceRerender = useRerender();

  // Effect to register for change notification
  // useEffect(() => {
  //   ContactApi.registerNotification(refreshData);
  //   return () => {
  //     ContactApi.unregisterNotification();
  //   };
  // }, []);

  async function modifyContact(formData) {
    const contact = Object.fromEntries(formData);
    if (contact.id === '0') contact.id = 0;
    if (contact.id === null) return;
    await ContactApi.saveContact(contact);
    await ContactApi.refreshContacts();
    forceRefresh();
  }

  async function deleteContact(id) {
    await ContactApi.deleteContact(id);
  }

  return (
    <>
      <h1>Contacts (using Hooks)</h1>
      <ContactTable
        contacts={contacts}
        modifyContact={modifyContact}
        deleteContact={deleteContact}
      />
    </>
  );
}
```

```jsx src/ContactTable.jsx
import { useState, useActionState, useOptimistic } from 'react';
import { removeFromCache, fetchData } from './fetchData';

export default function ContactTable({
  contacts,
  modifyContact,
  deleteContact,
}) {
  const [modificationRow, setModificationRow] = useState(null);
  const [optimisticContacts, setOptimisticContacts] = useOptimistic(
    contacts,
    (contacts, newContact) =>
      newContact.id === 0
        ? [...contacts, newContact]
        : contacts.map((c) => (c.id === newContact.id ? newContact : c))
  );
  const [ctx, submitAction, isPending] = useActionState(
    async (previousState, formData) => {
      setOptimisticContacts(Object.fromEntries(formData));
      setModificationRow(null);

      await modifyContact(formData);
      return null;
    },
    null
  );

  function modifyRow(id) {
    setModificationRow(id);
  }

  return (
    <form action={submitAction}>
      <table>
        <thead>
          <tr>
            <th style={{ maxWidth: 70 }}>id</th>
            <th>First Name</th>
            <th>Last Name</th>
            <th>Email</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {optimisticContacts.map((contact) =>
            contact.id === modificationRow && !isPending ? (
              <EditRow key={contact.id} contact={contact} setRow={modifyRow} />
            ) : (
              <Row
                key={contact.id}
                contact={contact}
                setRow={modifyRow}
                deleteContact={deleteContact}
              />
            )
          )}
        </tbody>
        <tfoot>
          {modificationRow === 0 ? (
            <EditRow
              contact={{ id: 0, firstName: '', lastName: '', email: '' }}
              setRow={modifyRow}
            />
          ) : (
            <tr>
              <td colSpan={5}>
                <button
                  title='Create Contact'
                  type='button'
                  onClick={() => {
                    setModificationRow(0);
                  }}
                >
                  ➕ Create Contact
                </button>
              </td>
            </tr>
          )}
        </tfoot>
      </table>
    </form>
  );
}

function Row({ contact, setRow, deleteContact }) {
  return (
    <tr key={contact.id}>
      <td
        style={{
          maxWidth: 70,
          whiteSpace: 'nowrap',
          overflow: 'hidden',
          textOverflow: 'ellipsis',
        }}
        title={contact.id.toString()}
      >
        {contact.id}
      </td>
      <td>{contact.firstName}</td>
      <td>{contact.lastName}</td>
      <td>
        <a href={`mailto:{contact.email}`}>{contact.email}</a>
      </td>
      <td style={{ display: 'flex' }}>
        <button
          title='Edit'
          type='button'
          onClick={() => {
            setRow(contact.id);
          }}
        >
          🖊️
        </button>
        <button
          title='Details'
          type='button'
          onClick={() => alert(`goto details for ${contact.firstName}`)}
        >
          🧾
        </button>
        <button
          title='Delete'
          type='button'
          onClick={() => deleteContact(contact.id)}
        >
          🗑️
        </button>
      </td>
    </tr>
  );
}

function EditRow({ contact, setRow }) {
  return (
    <tr key={contact.id} className='bg-warning'>
      <td style={{ maxWidth: 70 }} title={contact.id.toString()}>
        <input name='id' placeholder='ID' defaultValue={contact.id} readOnly />
      </td>
      <td>
        <input
          name='firstName'
          placeholder='First Name'
          defaultValue={contact.firstName}
        />
      </td>
      <td className='align-middle'>
        <input
          name='lastName'
          placeholder='Last Name'
          defaultValue={contact.lastName}
        />
      </td>
      <td className='align-middle'>
        <input
          name='email'
          placeholder='name@email.com'
          defaultValue={contact.email}
        />
      </td>
      <td>
        <button title='Save' type='submit'>
          ✔️
        </button>
        <button
          title='Cancel'
          type='button'
          onClick={() => {
            setRow(null);
          }}
        >
          ❌
        </button>
      </td>
    </tr>
  );
}
```

```jsx src/fetchData.js
let cache = new Map();

//this fetchData uses simple caching
export function fetchData(url, options) {
  if (!cache.has(url)) {
    cache.set(url, getData(url, options));
  }
  return cache.get(url);
}

async function getData(url, options) {
  const { delay, ...rest } = options ?? {};

  //artificial delay
  if (delay) {
    await new Promise((resolve) => {
      setTimeout(resolve, delay);
    });
  }

  const response = await fetch(url, rest);
  return await response.json();
}

export function removeFromCache(url) {
  if (cache.has(url)) {
    cache.delete(url);
  }
}
```

```jsx src/useRerender.jsx
import { useState } from 'react';

export default function useRerender() {
  const [, setRerender] = useState();

  function forceRerender() {
    setRerender({});
  }

  return forceRerender;
}
```

```css
table {
  border-collapse: collapse;
}

table > * > * > * {
  border-width: 0px;
  border-bottom-width: 1px;
  border-color: #dddddd;
  border-style: solid;
}

table > tbody > tr:nth-of-type(odd) > * {
  background-color: rgba(0, 0, 0, 0.05);
}

table th {
  text-align: left;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.4em 1em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #d9d9d9;
  cursor: pointer;
  transition: border-color 0.25s;
  margin: 0.1em;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

input {
  display: inline-block;
  width: 100%;
  padding: 0.2rem 0.4rem;
  margin: 0.1rem 0rem;
  font-size: 1rem;
  line-height: 1.5;
  color: #495057;
  background-color: #fff;
  background-clip: padding-box;
  border: 1px solid #ced4da;
  border-radius: 0.25rem;
  transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
}

input:focus {
  color: #495057;
  background-color: #fff;
  border-color: #80bdff;
  outline: 0;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.spinner {
  display: inline-block;
  width: 2em;
  height: 2em;
  vertical-align: -0.125em;
  border-radius: 50%;
  animation: 0.75s linear infinite spinner;
  border: 0.25em solid currentcolor;
  border-right-color: transparent;
}

@keyframes spinner {
  to {
    transform: rotate(360deg) /* rtl:ignore */;
  }
}
```

</Sandpack>

---

## Questions?

<img
  src='/img/job.jpeg'
  style={{ marginLeft: 'auto', marginRight: 'auto', width: '50%' }}
/>
