---
title: Donn√©es et Effets
description: other
---

# Donn√©es et Effets

import cssMcu from './10-data/cssMcu';

---

## Qu'est-ce que useEffect

<img
  src='https://m.media-amazon.com/images/I/61vQ5HnKLdL._AC_UF894,1000_QL80_.jpg'
  alt='old phone'
  width='50%'
/>

`useEffect()` Hook React qui permet de synchroniser un composant avec un syst√®me externe.

---

## Qu'est-ce qu'un syst√®me externe?

Quelque chose qui n'est pas g√©r√© par React. React g√®re les composants, le JSX, le rendu et le r√©sultat du rendu (virtual DOM)

React ne peut rien utiliser d'autre

- On ne peut utiliser une biblioth√®que js (jQuery, Angular, GraphJS, etc)
- On ne peut faire de `fetch` r√©seau pour obtenir donn√©es
- APIs du navigateur (History API, Navigation API, Location API, etc)

Pourquoi? Le rendu doit √™tre pur, sans effet de bord.

---

## Un effect roule apr√®s le rendu

Utiliser useEffect permet de cr√©er un "Effect"

Les Effects sont ex√©cut√©es imm√©diatement apr√®s le rendu (et apr√®s les fonctions de cleanup, s'il y a lieu)

<Alert type='danger'>
  **Attention:** Si un effect modifie l'√©tat, ceci pourrait g√©n√©rer un rerendu,
  qui d√©clenche un autre effect, qui modifie l'√©tat √† nouveau... ainsi de
  suite... boucle infinie!
</Alert>
>

---

## Utilisation:

```js
useEffect(fn_Setup, dependencyArray?)
```

Param√®tre fn_Setup:

- La fonction setup interagit et se "connecte" avec le monde externe
- Peut retourner une fonction fl√®che (surnomm√©e `cleanup`) pour se "d√©connecter"

Le tableau de d√©pendances d√©termine quand il faut ex√©cuter

- aucun changement dans les d√©pendances: pas d'ex√©cution d'Effet
- un ou plusieurs changements: ex√©cute l'Effet apr√®s le rendu
- Si le tableau est `null` ou `undefined`: l'Effet ex√©cute apr√®s chaque rendu
- Si le tableau est un tableau vide: l'Effet n'ex√©cute qu'apr√®s le premier rendu seulement

---

## useEffects n'est pas facile

- Rendu et useEffect ex√©cutent deux fois en Dev (`<StrictMode/>`)
- Cela cr√©√© des rendus additionnels
  - C'est pour aider √† trouver les effets de bord ind√©sirables
- useEffect devrait n'affecter qu'un √©l√©ment externe seulement
  - C'est plus complexe quand on affecte plusieurs choses.

<hr />

- Tableaux de d√©pendences sont complexes avec strings, nombres et bool√©ens
  - Encore plus difficiles avec objets ou tableaux
  - La comapraison utilise l'√©galit√© r√©f√©rentielle (`Object.is()`)
  - On ne peut d√©tecter le contenu modifi√© d'une r√©f√©rence
  - Objets et tableaux doivent √™tre consid√©r√©s immuables

---

## The Goal

"With time, the React team‚Äôs goal is to reduce the number of the Effects in your app to the minimum by providing more specific solutions to more specific problems. "

[source](https://react.dev/learn/reusing-logic-with-custom-hooks#custom-hooks-help-you-migrate-to-better-patterns)

---

## Bient√¥t

- Le hook `use()` peut √™tre utilis√© avec n'importe quel `promise`, pour obtenir des donn√©es
- **Sp√©cial:** n'a pas besoin d'√™tre d√©fini au top niveau
  - peut √™tre utilis√© dans des boucles, des conditions
- Disponible en React 19+

---

## Obtenir donn√©es via un √©v√©nement

- Pour un chargement g√©r√© par un √©v√©nement, c'est simple et direct.
- Pas besoin de `useEffect`, ou de `use`.
- La puret√© n'est n√©cessaire que pour le rendu.

<Sandpack files={cssMcu} >

```jsx src/App.js active
import { useState } from 'react';
import DisplayMovies from './DisplayMovies';

export default function App() {
  const [movies, setMovies] = useState([]);

  async function getMovies() {
    //get the data
    const response = await fetch('https://mcuapi.herokuapp.com/api/v1/movies');
    const data = await response.json();

    //sort movies by release date
    const sortedMovies = data.data.toSorted(
      (a, b) =>
        new Date(a.release_date).valueOf() - //
        new Date(b.release_date).valueOf()
    );

    //update the state, (schedules a re-render)
    setMovies(sortedMovies);
  }

  return (
    <>
      <h1>MCU Movies</h1>
      <button onClick={getMovies}>Refresh Movies</button>
      <DisplayMovies movies={movies} />
    </>
  );
}
```

```jsx src/DisplayMovies.jsx
export default function DisplayMovies({ movies, loading }) {
  if (loading) return <div>Loading...</div>;
  return movies.length > 0 ? (
    <div className='movieCards'>
      {movies.map((movie) => (
        <div key={movie.id}>
          <h3>{movie.title}</h3>
          <img src={movie.cover_url} />
          <p>
            <b>Release date: </b>
            {new Date(movie.release_date).toLocaleDateString()}
          </p>
          <p>{movie.overview}</p>
        </div>
      ))}
    </div>
  ) : (
    <div>No movies yet</div>
  );
}
```

</Sandpack>

---

## Ajouter la gestion des erreurs √† l'√©v√©nement

On ajoute un "√©tat" `error` pour g√©rer les erreur.

<Sandpack files={cssMcu} >

```jsx src/App.js active
import { useState } from 'react';
import DisplayMovies from './DisplayMovies';
import DisplayError from './DisplayError';

export default function App() {
  const [movies, setMovies] = useState([]);
  const [error, setError] = useState();

  async function getMovies() {
    try {
      //get the data
      const response = await fetch(
        'https://mcuapi.herokuapp.com/api/v1/movies'
      );
      const data = await response.json();

      //sort movies by release date
      const sortedMovies = data.data.toSorted(
        (a, b) =>
          new Date(a.release_date).valueOf() -
          new Date(b.release_date).valueOf()
      );

      setMovies(sortedMovies);
    } catch (err) {
      setError(err);
    }
  }

  if (error) {
    return <DisplayError error={error} />;
  }

  return (
    <>
      <h1>MCU Movies</h1>
      <button onClick={getMovies}>Refresh Movies</button>
      <DisplayMovies movies={movies} />
    </>
  );
}
```

```jsx src/DisplayMovies.jsx
export default function DisplayMovies({ movies, loading }) {
  if (loading) return <div>Loading...</div>;
  return movies.length > 0 ? (
    <div className='movieCards'>
      {movies.map((movie) => (
        <div key={movie.id}>
          <h3>{movie.title}</h3>
          <img src={movie.cover_url} />
          <p>
            <b>Release date: </b>
            {new Date(movie.release_date).toLocaleDateString()}
          </p>
          <p>{movie.overview}</p>
        </div>
      ))}
    </div>
  ) : (
    <div>No movies yet</div>
  );
}
```

```jsx src/DisplayError.jsx
export default function DisplayError({ error }) {
  return (
    <>
      <div>There is an error:</div>
      <div style={{ color: 'red', fontFamily: 'monospace' }}>
        {error.message}
      </div>
    </>
  );
}
```

</Sandpack>

---

## Ajouter un visuel de chargement √† l'√©v√©nement

- On ajoute un √©tat `loading`

<Sandpack files={cssMcu} >

```jsx src/App.js active
import { useState } from 'react';
import DisplayMovies from './DisplayMovies';
import DisplayError from './DisplayError';

export default function App() {
  const [movies, setMovies] = useState([]);
  const [error, setError] = useState();
  const [loading, setLoading] = useState(false);

  async function getMovies() {
    setLoading(true);

    //Artificial delay of 1 second
    await new Promise((resolve) => {
      setTimeout(resolve, 1000);
    });

    try {
      //get the data
      const response = await fetch(
        'https://mcuapi.herokuapp.com/api/v1/movies'
      );
      const data = await response.json();

      //sort movies by release date
      const sortedMovies = data.data.toSorted(
        (a, b) =>
          new Date(a.release_date).valueOf() -
          new Date(b.release_date).valueOf()
      );

      setMovies(sortedMovies);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  }

  if (error) {
    return <DisplayError error={error} />;
  }

  return (
    <>
      <h1>MCU Movies</h1>
      <button onClick={getMovies}>Refresh Movies</button>
      <DisplayMovies movies={movies} loading={loading} />
    </>
  );
}
```

```jsx src/DisplayMovies.jsx
export default function DisplayMovies({ movies, loading }) {
  if (loading)
    return (
      <div>
        <span className='spinner' /> Loading...
      </div>
    );
  return movies.length > 0 ? (
    <div className='movieCards'>
      {movies.map((movie) => (
        <div key={movie.id}>
          <h3>{movie.title}</h3>
          <img src={movie.cover_url} />
          <p>
            <b>Release date: </b>
            {new Date(movie.release_date).toLocaleDateString()}
          </p>
          <p>{movie.overview}</p>
        </div>
      ))}
    </div>
  ) : (
    <div>No movies yet</div>
  );
}
```

```jsx src/DisplayError.jsx
export default function DisplayError({ error }) {
  return (
    <>
      <div>There is an error:</div>
      <div style={{ color: 'red', fontFamily: 'monospace' }}>
        {error.message}
      </div>
    </>
  );
}
```

</Sandpack>

---

## Fetch avec Effect

- On ne peut appeler `getData` pendant le rendu
- Sinon, notre fonction est impure. (C'est un effet de bord)
- On peut utiliser `useEffect` pour appeler `getData` apr√®s le rendu

<Sandpack files={cssMcu}  >

```jsx src/App.js active
import { useState, useEffect } from 'react';
import DisplayMovies from './DisplayMovies';
import DisplayError from './DisplayError';

export default function App() {
  const [movies, setMovies] = useState([]);
  const [error, setError] = useState();
  const [loading, setLoading] = useState(false);

  async function getMovies() {
    setLoading(true);

    //Artificial delay of 1 second
    await new Promise((resolve) => {
      setTimeout(resolve, 1000);
    });

    try {
      //get the data
      const response = await fetch(
        'https://mcuapi.herokuapp.com/api/v1/movies'
      );
      const data = await response.json();

      //sort movies by release date
      const sortedMovies = data.data.toSorted(
        (a, b) =>
          new Date(a.release_date).valueOf() -
          new Date(b.release_date).valueOf()
      );

      setMovies(sortedMovies);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    getMovies();
  }, []); //runs only after first render

  if (error) {
    return <DisplayError error={error} />;
  }

  return (
    <>
      <h1>MCU Movies</h1>
      <button onClick={getMovies}>Refresh Movies</button>
      <DisplayMovies movies={movies} loading={loading} />
    </>
  );
}
```

```jsx src/DisplayMovies.jsx
export default function DisplayMovies({ movies, loading }) {
  if (loading) {
    return (
      <div>
        <span className='spinner' /> Loading
      </div>
    );
  }
  return movies.length > 0 ? (
    <div className='movieCards'>
      {movies.map((movie) => (
        <div key={movie.id}>
          <h3>{movie.title}</h3>
          <img src={movie.cover_url} />
          <p>
            <b>Release date: </b>
            {new Date(movie.release_date).toLocaleDateString()}
          </p>
          <p>{movie.overview}</p>
        </div>
      ))}
    </div>
  ) : (
    <div>No movies yet</div>
  );
}
```

```jsx src/DisplayError.jsx
export default function DisplayError({ error }) {
  return (
    <>
      <div>There is an error:</div>
      <div style={{ color: 'red', fontFamily: 'monospace' }}>
        {error.message}
      </div>
    </>
  );
}
```

</Sandpack>

---

## Charger avec un hook personnalis√©

- `useApi` isole le code qui charge
- En production, `useApi` utiliserait du caching pour r√©duire le nombre d'appels r√©seaux

<Sandpack files={cssMcu} >

```jsx src/App.js active
import useApi from './useApi';
import DisplayMovies from './DisplayMovies';
import DisplayError from './DisplayError';

export default function App() {
  const { data, error, loading, reload } = useApi(
    'https://mcuapi.herokuapp.com/api/v1/movies',
    { delay: 1000 }
  );

  if (error) return <DisplayError error={error} />;

  const unsortedMovies = data?.data ?? [];
  //sort movies by release date
  const sortedMovies = unsortedMovies.toSorted(
    (a, b) =>
      new Date(a.release_date).valueOf() - //
      new Date(b.release_date).valueOf()
  );

  return (
    <>
      <h1>MCU Movies</h1>
      <button onClick={reload}>Refresh Movies</button>
      <DisplayMovies movies={sortedMovies} loading={loading} />
    </>
  );
}
```

```js src/useApi.js
import { useState, useEffect } from 'react';
//This code is missing caching
//useQuery from "TanStack Query" has caching

export default function useApi(endpoint, options) {
  const [data, setData] = useState();
  const [error, setError] = useState();
  const [loading, setLoading] = useState(false);

  const { delay, ...rest } = options ?? {};

  async function loadData() {
    setLoading(true);

    //Artificial delay
    if (delay) {
      await new Promise((resolve) => {
        setTimeout(resolve, delay);
      });
    }

    try {
      const res = await fetch(endpoint);
      const data = await res.json();
      setData(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    loadData();
  }, [endpoint, delay]);

  return { data, error, loading, reload: loadData };
}
```

```jsx src/DisplayMovies.jsx
export default function DisplayMovies({ movies, loading }) {
  if (loading) {
    return (
      <div>
        <span className='spinner' /> Loading
      </div>
    );
  }
  return movies.length > 0 ? (
    <div className='movieCards'>
      {movies.map((movie) => (
        <div key={movie.id}>
          <h3>{movie.title}</h3>
          <img src={movie.cover_url} />
          <p>
            <b>Release date: </b>
            {new Date(movie.release_date).toLocaleDateString()}
          </p>
          <p>{movie.overview}</p>
        </div>
      ))}
    </div>
  ) : (
    <div>No movies yet</div>
  );
}
```

```jsx src/DisplayError.jsx
export default function DisplayError({ error }) {
  return (
    <>
      <div>There is an error:</div>
      <div style={{ color: 'red', fontFamily: 'monospace' }}>
        {error.message}
      </div>
    </>
  );
}
```

</Sandpack >

---

## Suspense et use dans la prochaine version de React

- `use` permet d'appeler une promesse pendant rendu
- `use` interrompt le rendu quand la promesse n'est pas encore compl√©t√©e
- et cela interrompt le rendu du parent, grand-parent et ainsi de suite
- l'interruption remonte l'arboresence jusqu'au `<suspense>`, qui fait un rendu du `fallback`
- Quand la promesse compl√®te, on fait un nouveau rendu du `<suspense>`

<Sandpack v19 files={cssMcu}>

```jsx src/App.js active
import { use, Suspense } from 'react';
import DisplayMovies from './DisplayMovies';
import DisplayError from './DisplayError';
import useRerender from './useRerender';
import { fetchData } from './fetchData';

const url = 'https://mcuapi.herokuapp.com/api/v1/movies';

export default function App() {
  //Because there is no caching in this version,
  //any rerender will trigger a new network call
  //This is bad, React will show warning
  const forceRerender = useRerender();

  return (
    <>
      <h1>MCU Movies</h1>
      <button onClick={forceRerender}>Force Rerender</button>

      <Suspense fallback={<div>Loading...</div>}>
        <Movies />
      </Suspense>
    </>
  );
}

function Movies() {
  const rawData = use(fetchData(url, 1000));
  if (rawData.error) return <DisplayError error={rawData.error} />;

  const movies = rawData.data.toSorted(
    (a, b) =>
      new Date(a.release_date).valueOf() - //
      new Date(b.release_date).valueOf()
  );

  return <DisplayMovies movies={movies} />;
}
```

```js src/fetchData.js
//this fetchData uses NO caching
export function fetchData(url, options) {
  return getData(url, options);
}

async function getData(url, options) {
  const { delay, ...rest } = options ?? {};

  //Artificial delay
  if (delay) {
    await new Promise((resolve) => {
      setTimeout(resolve, delay);
    });
  }

  try {
    const response = await fetch(url, rest);
    return await response.json();
  } catch (err) {
    return { error: err };
  }
}
```

```jsx src/useRerender.jsx
import { useState } from 'react';

export default function useRerender() {
  const [, setRerender] = useState();

  function forceRerender() {
    setRerender({});
  }

  return forceRerender;
}
```

```jsx src/DisplayMovies.jsx
export default function DisplayMovies({ movies }) {
  return movies.length > 0 ? (
    <div className='movieCards'>
      {movies.map((movie) => (
        <div key={movie.id}>
          <h3>{movie.title}</h3>
          <img src={movie.cover_url} />
          <p>
            <b>Release date: </b>
            {new Date(movie.release_date).toLocaleDateString()}
          </p>
          <p>{movie.overview}</p>
        </div>
      ))}
    </div>
  ) : (
    <div>No movies yet</div>
  );
}
```

```jsx src/DisplayError.jsx
export default function DisplayError({ error }) {
  return (
    <>
      <div>There is an error:</div>
      <div style={{ color: 'red', fontFamily: 'monospace' }}>
        {error.message}
      </div>
    </>
  );
}
```

</Sandpack>

---

## Chargement avec React 19 avec caching

<Sandpack v19 files={cssMcu} >

```jsx src/App.js active
import { use, Suspense } from 'react';
import DisplayMovies from './DisplayMovies';
import DisplayError from './DisplayError';
import useRerender from './useRerender';
import { fetchData } from './fetchData';

const url = 'https://mcuapi.herokuapp.com/api/v1/movies';

export default function App() {
  const forceRerender = useRerender();

  return (
    <>
      <h1>MCU Movies</h1>
      <button onClick={forceRerender}>Force Rerender</button>

      <Suspense fallback={<div className='spinner'></div>}>
        <Movies />
      </Suspense>
    </>
  );
}

function Movies() {
  const rawData = use(fetchData(url, { delay: 1000 }));
  if (rawData.error) return <DisplayError error={rawData.error} />;

  const movies = rawData.data.toSorted(
    (a, b) =>
      new Date(a.release_date).valueOf() - //
      new Date(b.release_date).valueOf()
  );

  return <DisplayMovies movies={movies} />;
}
```

```jsx src/fetchData.js
let cache = new Map();

//this fetchData uses simple caching
export function fetchData(url, options) {
  if (!cache.has(url)) {
    cache.set(url, getData(url, options));
  }
  return cache.get(url);
}

async function getData(url, options) {
  const { delay, ...rest } = options ?? {};

  //artificial delay
  if (delay) {
    await new Promise((resolve) => {
      setTimeout(resolve, delay);
    });
  }

  try {
    const response = await fetch(url, rest);
    return await response.json();
  } catch (err) {
    return { error: err };
  }
}

export function removeFromCache(url) {
  if (cache.has(url)) {
    cache.delete(url);
  }
}
```

```jsx src/useRerender.jsx
import { useState } from 'react';

export default function useRerender() {
  const [, setRerender] = useState();

  function forceRerender() {
    setRerender({});
  }

  return forceRerender;
}
```

```jsx src/DisplayMovies.jsx
export default function DisplayMovies({ movies }) {
  return movies.length > 0 ? (
    <div className='movieCards'>
      {movies.map((movie) => (
        <div key={movie.id}>
          <h3>{movie.title}</h3>
          <img src={movie.cover_url} />
          <p>
            <b>Release date: </b>
            {new Date(movie.release_date).toLocaleDateString()}
          </p>
          <p>{movie.overview}</p>
        </div>
      ))}
    </div>
  ) : (
    <div>No movies yet</div>
  );
}
```

```jsx src/DisplayError.jsx
export default function DisplayError({ error }) {
  return (
    <>
      <div>There is an error:</div>
      <div style={{ color: 'red', fontFamily: 'monospace' }}>
        {error.message}
      </div>
    </>
  );
}
```

</Sandpack>

---

## Vider la cache

On ajoute un bouton qui vide la cache

<Sandpack v19 files={cssMcu} >

```jsx src/App.js active
import { use, Suspense } from 'react';
import DisplayMovies from './DisplayMovies';
import DisplayError from './DisplayError';
import useRerender from './useRerender';
import { fetchData, removeFromCache } from './fetchData';

const url = 'https://mcuapi.herokuapp.com/api/v1/movies';

export default function App() {
  const forceRerender = useRerender();

  return (
    <>
      <h1>MCU Movies</h1>
      <button onClick={forceRerender}>Force Rerender</button>
      <button onClick={() => removeFromCache(url)}>
        Empty results from cache
      </button>

      <Suspense fallback={<div className='spinner'></div>}>
        <Movies />
      </Suspense>
    </>
  );
}

function Movies() {
  const rawData = use(fetchData(url, { delay: 1000 }));
  if (rawData.error) return <DisplayError error={rawData.error} />;
  const movies = rawData.data.toSorted(
    (a, b) =>
      new Date(a.release_date).valueOf() - //
      new Date(b.release_date).valueOf()
  );
  return <DisplayMovies movies={movies} />;
}
```

```jsx src/fetchData.js
let cache = new Map();

//this fetchData uses simple caching
export function fetchData(url, options) {
  if (!cache.has(url)) {
    cache.set(url, getData(url, options));
  }
  return cache.get(url);
}

async function getData(url, options) {
  const { delay, ...rest } = options ?? {};

  //artificial delay
  if (delay) {
    await new Promise((resolve) => {
      setTimeout(resolve, delay);
    });
  }

  try {
    const response = await fetch(url, rest);
    return await response.json();
  } catch (err) {
    return { error: err };
  }
}

export function removeFromCache(url) {
  if (cache.has(url)) {
    cache.delete(url);
  }
}
```

```jsx src/useRerender.jsx
import { useState } from 'react';

export default function useRerender() {
  const [, setRerender] = useState();

  function forceRerender() {
    setRerender({});
  }

  return forceRerender;
}
```

```jsx src/DisplayMovies.jsx
export default function DisplayMovies({ movies }) {
  return movies.length > 0 ? (
    <div className='movieCards'>
      {movies.map((movie) => (
        <div key={movie.id}>
          <h3>{movie.title}</h3>
          <img src={movie.cover_url} />
          <p>
            <b>Release date: </b>
            {new Date(movie.release_date).toLocaleDateString()}
          </p>
          <p>{movie.overview}</p>
        </div>
      ))}
    </div>
  ) : (
    <div>No movies yet</div>
  );
}
```

```jsx src/DisplayError.jsx
export default function DisplayError({ error }) {
  return (
    <>
      <div>There is an error:</div>
      <div style={{ color: 'red', fontFamily: 'monospace' }}>
        {error.message}
      </div>
    </>
  );
}
```

</Sandpack>

---

## Exemple d'un appel simple avec Suspense

<Sandpack v19>

```js src/App.js
import { useState } from 'react';
import ArtistPage from './ArtistPage.js';

export default function App() {
  const [show, setShow] = useState(false);
  if (show) {
    return (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  } else {
    return (
      <button onClick={() => setShow(true)}>
        Open The Beatles artist page
      </button>
    );
  }
}
```

```js src/ArtistPage.js active
import { Suspense } from 'react';
import Albums from './Albums.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<Loading />}>
        <Albums artistId={artist.id} />
      </Suspense>
    </>
  );
}

function Loading() {
  return (
    <h2>
      <span className='spinner'></span> Loading...
    </h2>
  );
}
```

```js src/Albums.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Albums({ artistId }) {
  const albums = use(fetchData(`/${artistId}/albums`));
  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>
          {album.title} ({album.year})
        </li>
      ))}
    </ul>
  );
}
```

```js src/data.js
// Note: the way you would do data fetching depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url === '/the-beatles/albums') {
    return await getAlbums();
  } else {
    throw Error('Not implemented');
  }
}

async function getAlbums() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 3000);
  });

  return [
    {
      id: 13,
      title: 'Let It Be',
      year: 1970,
    },
    {
      id: 12,
      title: 'Abbey Road',
      year: 1969,
    },
    {
      id: 11,
      title: 'Yellow Submarine',
      year: 1969,
    },
    {
      id: 10,
      title: 'The Beatles',
      year: 1968,
    },
    {
      id: 9,
      title: 'Magical Mystery Tour',
      year: 1967,
    },
    {
      id: 8,
      title: "Sgt. Pepper's Lonely Hearts Club Band",
      year: 1967,
    },
    {
      id: 7,
      title: 'Revolver',
      year: 1966,
    },
    {
      id: 6,
      title: 'Rubber Soul',
      year: 1965,
    },
    {
      id: 5,
      title: 'Help!',
      year: 1965,
    },
    {
      id: 4,
      title: 'Beatles For Sale',
      year: 1964,
    },
    {
      id: 3,
      title: "A Hard Day's Night",
      year: 1964,
    },
    {
      id: 2,
      title: 'With The Beatles',
      year: 1963,
    },
    {
      id: 1,
      title: 'Please Please Me',
      year: 1963,
    },
  ];
}
```

```css
.spinner {
  display: inline-block;
  width: 2em;
  height: 2em;
  vertical-align: -0.125em;
  border-radius: 50%;
  animation: 0.75s linear infinite spinner;
  border: 0.25em solid currentcolor;
  border-right-color: transparent;
}

@keyframes spinner {
  to {
    transform: rotate(360deg) /* rtl:ignore */;
  }
}
```

</Sandpack>

---

## Exemple d'un suspense pour deux appels en cascade

Les deux appels sont en cascades, mais le rendu apparait une fois les 2 compl√©t√©s

<Sandpack v19>

```js src/App.js
import { useState } from 'react';
import ArtistPage from './ArtistPage.js';

export default function App() {
  const [show, setShow] = useState(false);
  if (show) {
    return (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  } else {
    return (
      <button onClick={() => setShow(true)}>
        Open The Beatles artist page
      </button>
    );
  }
}
```

```js src/ArtistPage.js active
import { Suspense } from 'react';
import Albums from './Albums.js';
import Biography from './Biography.js';
import Panel from './Panel.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<Loading />}>
        <Biography artistId={artist.id} />
        <Panel>
          <Albums artistId={artist.id} />
        </Panel>
      </Suspense>
    </>
  );
}

function Loading() {
  return (
    <h2>
      <span className='spinner' /> Loading...
    </h2>
  );
}
```

```js src/Panel.js
export default function Panel({ children }) {
  return <section className='panel'>{children}</section>;
}
```

```js src/Biography.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Biography({ artistId }) {
  const bio = use(fetchData(`/${artistId}/bio`));
  return (
    <section>
      <p className='bio'>{bio}</p>
    </section>
  );
}
```

```js src/Albums.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Albums({ artistId }) {
  const albums = use(fetchData(`/${artistId}/albums`));
  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>
          {album.title} ({album.year})
        </li>
      ))}
    </ul>
  );
}
```

```js src/data.js
// Note: the way you would do data fetching depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url === '/the-beatles/albums') {
    return await getAlbums();
  } else if (url === '/the-beatles/bio') {
    return await getBio();
  } else {
    throw Error('Not implemented');
  }
}

async function getBio() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 1500);
  });

  return `The Beatles were an English rock band, 
    formed in Liverpool in 1960, that comprised 
    John Lennon, Paul McCartney, George Harrison 
    and Ringo Starr.`;
}

async function getAlbums() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 3000);
  });

  return [
    {
      id: 13,
      title: 'Let It Be',
      year: 1970,
    },
    {
      id: 12,
      title: 'Abbey Road',
      year: 1969,
    },
    {
      id: 11,
      title: 'Yellow Submarine',
      year: 1969,
    },
    {
      id: 10,
      title: 'The Beatles',
      year: 1968,
    },
    {
      id: 9,
      title: 'Magical Mystery Tour',
      year: 1967,
    },
    {
      id: 8,
      title: "Sgt. Pepper's Lonely Hearts Club Band",
      year: 1967,
    },
    {
      id: 7,
      title: 'Revolver',
      year: 1966,
    },
    {
      id: 6,
      title: 'Rubber Soul',
      year: 1965,
    },
    {
      id: 5,
      title: 'Help!',
      year: 1965,
    },
    {
      id: 4,
      title: 'Beatles For Sale',
      year: 1964,
    },
    {
      id: 3,
      title: "A Hard Day's Night",
      year: 1964,
    },
    {
      id: 2,
      title: 'With The Beatles',
      year: 1963,
    },
    {
      id: 1,
      title: 'Please Please Me',
      year: 1963,
    },
  ];
}
```

```css
.bio {
  font-style: italic;
}

.panel {
  border: 1px solid #aaa;
  border-radius: 6px;
  margin-top: 20px;
  padding: 10px;
}

.spinner {
  display: inline-block;
  width: 2em;
  height: 2em;
  vertical-align: -0.125em;
  border-radius: 50%;
  animation: 0.75s linear infinite spinner;
  border: 0.25em solid currentcolor;
  border-right-color: transparent;
}

@keyframes spinner {
  to {
    transform: rotate(360deg) /* rtl:ignore */;
  }
}
```

</Sandpack>

---

## Exemple de suspenses imbriqu√©s, pour deux appels en cascade

<Sandpack v19>

```js src/App.js
import { useState } from 'react';
import ArtistPage from './ArtistPage.js';

export default function App() {
  const [show, setShow] = useState(false);
  if (show) {
    return (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  } else {
    return (
      <button onClick={() => setShow(true)}>
        Open The Beatles artist page
      </button>
    );
  }
}
```

```js src/ArtistPage.js active
import { Suspense } from 'react';
import Albums from './Albums.js';
import Biography from './Biography.js';
import Panel from './Panel.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<BigSpinner />}>
        <Biography artistId={artist.id} />
        <Suspense fallback={<AlbumsGlimmer />}>
          <Panel>
            <Albums artistId={artist.id} />
          </Panel>
        </Suspense>
      </Suspense>
    </>
  );
}

function BigSpinner() {
  return (
    <h2>
      <span className='spinner'></span> Loading...
    </h2>
  );
}

function AlbumsGlimmer() {
  return (
    <div className='glimmer-panel'>
      <div className='glimmer-line' />
      <div className='glimmer-line' />
      <div className='glimmer-line' />
    </div>
  );
}
```

```js src/Panel.js
export default function Panel({ children }) {
  return <section className='panel'>{children}</section>;
}
```

```js src/Biography.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Biography({ artistId }) {
  const bio = use(fetchData(`/${artistId}/bio`));
  return (
    <section>
      <p className='bio'>{bio}</p>
    </section>
  );
}
```

```js src/Albums.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Albums({ artistId }) {
  const albums = use(fetchData(`/${artistId}/albums`));
  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>
          {album.title} ({album.year})
        </li>
      ))}
    </ul>
  );
}
```

```js src/data.js
// Note: the way you would do data fetching depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url === '/the-beatles/albums') {
    return await getAlbums();
  } else if (url === '/the-beatles/bio') {
    return await getBio();
  } else {
    throw Error('Not implemented');
  }
}

async function getBio() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 500);
  });

  return `The Beatles were an English rock band, 
    formed in Liverpool in 1960, that comprised 
    John Lennon, Paul McCartney, George Harrison 
    and Ringo Starr.`;
}

async function getAlbums() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 3000);
  });

  return [
    {
      id: 13,
      title: 'Let It Be',
      year: 1970,
    },
    {
      id: 12,
      title: 'Abbey Road',
      year: 1969,
    },
    {
      id: 11,
      title: 'Yellow Submarine',
      year: 1969,
    },
    {
      id: 10,
      title: 'The Beatles',
      year: 1968,
    },
    {
      id: 9,
      title: 'Magical Mystery Tour',
      year: 1967,
    },
    {
      id: 8,
      title: "Sgt. Pepper's Lonely Hearts Club Band",
      year: 1967,
    },
    {
      id: 7,
      title: 'Revolver',
      year: 1966,
    },
    {
      id: 6,
      title: 'Rubber Soul',
      year: 1965,
    },
    {
      id: 5,
      title: 'Help!',
      year: 1965,
    },
    {
      id: 4,
      title: 'Beatles For Sale',
      year: 1964,
    },
    {
      id: 3,
      title: "A Hard Day's Night",
      year: 1964,
    },
    {
      id: 2,
      title: 'With The Beatles',
      year: 1963,
    },
    {
      id: 1,
      title: 'Please Please Me',
      year: 1963,
    },
  ];
}
```

```css
.bio {
  font-style: italic;
}

.panel {
  border: 1px solid #aaa;
  border-radius: 6px;
  margin-top: 20px;
  padding: 10px;
}

.glimmer-panel {
  border: 1px dashed #aaa;
  background: linear-gradient(
    90deg,
    rgba(221, 221, 221, 1) 0%,
    rgba(255, 255, 255, 1) 100%
  );
  border-radius: 6px;
  margin-top: 20px;
  padding: 10px;
}

.glimmer-line {
  display: block;
  width: 60%;
  height: 20px;
  margin: 10px;
  border-radius: 4px;
  background: #f0f0f0;
}

.spinner {
  display: inline-block;
  width: 2em;
  height: 2em;
  vertical-align: -0.125em;
  border-radius: 50%;
  animation: 0.75s linear infinite spinner;
  border: 0.25em solid currentcolor;
  border-right-color: transparent;
}

@keyframes spinner {
  to {
    transform: rotate(360deg) /* rtl:ignore */;
  }
}
```

</Sandpack>

---

## On perd l'affichage pendant le chargement

<Sandpack v19>

```js src/App.js
import { Suspense, useState } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  return (
    <>
      <label>
        Search albums:
        <input value={query} onChange={(e) => setQuery(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <SearchResults query={query} />
      </Suspense>
    </>
  );
}
```

```js src/SearchResults.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function SearchResults({ query }) {
  if (query === '') {
    return null;
  }
  const albums = use(fetchData(`/search?q=${query}`));
  if (albums.length === 0) {
    return (
      <p>
        No matches for <i>"{query}"</i>
      </p>
    );
  }
  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>
          {album.title} ({album.year})
        </li>
      ))}
    </ul>
  );
}
```

```js src/data.js
// Note: the way you would do data fetching depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url.startsWith('/search?q=')) {
    return await getSearchResults(url.slice('/search?q='.length));
  } else {
    throw Error('Not implemented');
  }
}

async function getSearchResults(query) {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 500);
  });

  const allAlbums = [
    {
      id: 13,
      title: 'Let It Be',
      year: 1970,
    },
    {
      id: 12,
      title: 'Abbey Road',
      year: 1969,
    },
    {
      id: 11,
      title: 'Yellow Submarine',
      year: 1969,
    },
    {
      id: 10,
      title: 'The Beatles',
      year: 1968,
    },
    {
      id: 9,
      title: 'Magical Mystery Tour',
      year: 1967,
    },
    {
      id: 8,
      title: "Sgt. Pepper's Lonely Hearts Club Band",
      year: 1967,
    },
    {
      id: 7,
      title: 'Revolver',
      year: 1966,
    },
    {
      id: 6,
      title: 'Rubber Soul',
      year: 1965,
    },
    {
      id: 5,
      title: 'Help!',
      year: 1965,
    },
    {
      id: 4,
      title: 'Beatles For Sale',
      year: 1964,
    },
    {
      id: 3,
      title: "A Hard Day's Night",
      year: 1964,
    },
    {
      id: 2,
      title: 'With The Beatles',
      year: 1963,
    },
    {
      id: 1,
      title: 'Please Please Me',
      year: 1963,
    },
  ];

  const lowerQuery = query.trim().toLowerCase();
  return allAlbums.filter((album) => {
    const lowerTitle = album.title.toLowerCase();
    return (
      lowerTitle.startsWith(lowerQuery) ||
      lowerTitle.indexOf(' ' + lowerQuery) !== -1
    );
  });
}
```

```css
input {
  margin: 10px;
}
```

</Sandpack>

---

## Conserver l'affichage des donn√©es gr√¢ce √† useDeferredValue

`useDeferred` est bas√© sur une autre valeur. On conserve une copie de la valeur pr√©c√©dente

- `useDeferred` fait deux rendus
- Un premier avec la valeur pr√©c√©dente (sans l'afficher, le "commit")
- C√©dule le second avec la nouvelle valeur
  - Si ce second rendu est compl√©t√© imm√©diatement, on l'affiche (commit).
  - Sinon (si on suspend), on affiche alors le premier rendu (avec la valeur pr√©c√©dente).
  - On peut utiliser la m√©moisation pour √©viter le premier rendu

<Sandpack v19>

```js src/App.js
import { Suspense, useState, useDeferredValue } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  const isStale = query !== deferredQuery;
  return (
    <>
      <label>
        Search albums:
        <input value={query} onChange={(e) => setQuery(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <div style={{ opacity: isStale ? 0.5 : 1 }}>
          <SearchResults query={deferredQuery} />
        </div>
      </Suspense>
    </>
  );
}
```

```js src/SearchResults.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function SearchResults({ query }) {
  if (query === '') {
    return null;
  }
  const albums = use(fetchData(`/search?q=${query}`));
  if (albums.length === 0) {
    return (
      <p>
        No matches for <i>"{query}"</i>
      </p>
    );
  }
  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>
          {album.title} ({album.year})
        </li>
      ))}
    </ul>
  );
}
```

```js src/data.js
// Note: the way you would do data fetching depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url.startsWith('/search?q=')) {
    return await getSearchResults(url.slice('/search?q='.length));
  } else {
    throw Error('Not implemented');
  }
}

async function getSearchResults(query) {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 500);
  });

  const allAlbums = [
    {
      id: 13,
      title: 'Let It Be',
      year: 1970,
    },
    {
      id: 12,
      title: 'Abbey Road',
      year: 1969,
    },
    {
      id: 11,
      title: 'Yellow Submarine',
      year: 1969,
    },
    {
      id: 10,
      title: 'The Beatles',
      year: 1968,
    },
    {
      id: 9,
      title: 'Magical Mystery Tour',
      year: 1967,
    },
    {
      id: 8,
      title: "Sgt. Pepper's Lonely Hearts Club Band",
      year: 1967,
    },
    {
      id: 7,
      title: 'Revolver',
      year: 1966,
    },
    {
      id: 6,
      title: 'Rubber Soul',
      year: 1965,
    },
    {
      id: 5,
      title: 'Help!',
      year: 1965,
    },
    {
      id: 4,
      title: 'Beatles For Sale',
      year: 1964,
    },
    {
      id: 3,
      title: "A Hard Day's Night",
      year: 1964,
    },
    {
      id: 2,
      title: 'With The Beatles',
      year: 1963,
    },
    {
      id: 1,
      title: 'Please Please Me',
      year: 1963,
    },
  ];

  const lowerQuery = query.trim().toLowerCase();
  return allAlbums.filter((album) => {
    const lowerTitle = album.title.toLowerCase();
    return (
      lowerTitle.startsWith(lowerQuery) ||
      lowerTitle.indexOf(' ' + lowerQuery) !== -1
    );
  });
}
```

```css
input {
  margin: 10px;
}
```

</Sandpack>

---

## Suspense √† un niveau global

Ici, on fait un suspense au niveau du routage complet. Mais la transition n'est pas fluide.

<Sandpack v19>

```js src/App.js
import { Suspense, useState } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
  return (
    <Suspense fallback={<BigSpinner />}>
      <Router />
    </Suspense>
  );
}

function Router() {
  const [page, setPage] = useState('/');

  function navigate(url) {
    setPage(url);
  }

  let content;
  if (page === '/') {
    content = <IndexPage navigate={navigate} />;
  } else if (page === '/the-beatles') {
    content = (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  }
  return <Layout>{content}</Layout>;
}

function BigSpinner() {
  return <h2>üåÄ Loading...</h2>;
}
```

```js src/Layout.js
export default function Layout({ children }) {
  return (
    <div className='layout'>
      <section className='header'>Music Browser</section>
      <main>{children}</main>
    </div>
  );
}
```

```js src/IndexPage.js
export default function IndexPage({ navigate }) {
  return (
    <button onClick={() => navigate('/the-beatles')}>
      Open The Beatles artist page
    </button>
  );
}
```

```js src/ArtistPage.js
import { Suspense } from 'react';
import Albums from './Albums.js';
import Biography from './Biography.js';
import Panel from './Panel.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Biography artistId={artist.id} />
      <Suspense fallback={<AlbumsGlimmer />}>
        <Panel>
          <Albums artistId={artist.id} />
        </Panel>
      </Suspense>
    </>
  );
}

function AlbumsGlimmer() {
  return (
    <div className='glimmer-panel'>
      <div className='glimmer-line' />
      <div className='glimmer-line' />
      <div className='glimmer-line' />
    </div>
  );
}
```

```js src/Albums.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Albums({ artistId }) {
  const albums = use(fetchData(`/${artistId}/albums`));
  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>
          {album.title} ({album.year})
        </li>
      ))}
    </ul>
  );
}
```

```js src/Biography.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Biography({ artistId }) {
  const bio = use(fetchData(`/${artistId}/bio`));
  return (
    <section>
      <p className='bio'>{bio}</p>
    </section>
  );
}
```

```js src/Panel.js
export default function Panel({ children }) {
  return <section className='panel'>{children}</section>;
}
```

```js src/data.js
// Note: the way you would do data fetching depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url === '/the-beatles/albums') {
    return await getAlbums();
  } else if (url === '/the-beatles/bio') {
    return await getBio();
  } else {
    throw Error('Not implemented');
  }
}

async function getBio() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 500);
  });

  return `The Beatles were an English rock band, 
    formed in Liverpool in 1960, that comprised 
    John Lennon, Paul McCartney, George Harrison 
    and Ringo Starr.`;
}

async function getAlbums() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 3000);
  });

  return [
    {
      id: 13,
      title: 'Let It Be',
      year: 1970,
    },
    {
      id: 12,
      title: 'Abbey Road',
      year: 1969,
    },
    {
      id: 11,
      title: 'Yellow Submarine',
      year: 1969,
    },
    {
      id: 10,
      title: 'The Beatles',
      year: 1968,
    },
    {
      id: 9,
      title: 'Magical Mystery Tour',
      year: 1967,
    },
    {
      id: 8,
      title: "Sgt. Pepper's Lonely Hearts Club Band",
      year: 1967,
    },
    {
      id: 7,
      title: 'Revolver',
      year: 1966,
    },
    {
      id: 6,
      title: 'Rubber Soul',
      year: 1965,
    },
    {
      id: 5,
      title: 'Help!',
      year: 1965,
    },
    {
      id: 4,
      title: 'Beatles For Sale',
      year: 1964,
    },
    {
      id: 3,
      title: "A Hard Day's Night",
      year: 1964,
    },
    {
      id: 2,
      title: 'With The Beatles',
      year: 1963,
    },
    {
      id: 1,
      title: 'Please Please Me',
      year: 1963,
    },
  ];
}
```

```css
main {
  min-height: 200px;
  padding: 10px;
}

.layout {
  border: 1px solid black;
}

.header {
  background: #222;
  padding: 10px;
  text-align: center;
  color: white;
}

.bio {
  font-style: italic;
}

.panel {
  border: 1px solid #aaa;
  border-radius: 6px;
  margin-top: 20px;
  padding: 10px;
}

.glimmer-panel {
  border: 1px dashed #aaa;
  background: linear-gradient(
    90deg,
    rgba(221, 221, 221, 1) 0%,
    rgba(255, 255, 255, 1) 100%
  );
  border-radius: 6px;
  margin-top: 20px;
  padding: 10px;
}

.glimmer-line {
  display: block;
  width: 60%;
  height: 20px;
  margin: 10px;
  border-radius: 4px;
  background: #f0f0f0;
}
```

</Sandpack>

---

## StartTransition √† la rescousse

StartTransition indique un changement de State non-bloquant, qui n'est pas urgent. Si un autre √©v√©nement lance un setState, le rendu de transition est interrompu (et red√©marr√© plus tard, un fois le traitement de l'√©v√©nement termin√©).

<Sandpack v19>

```js src/App.js
import { Suspense, startTransition, useState } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
  return (
    <Suspense fallback={<BigSpinner />}>
      <Router />
    </Suspense>
  );
}

function Router() {
  const [page, setPage] = useState('/');

  function navigate(url) {
    startTransition(() => {
      setPage(url);
    });
  }

  let content;
  if (page === '/') {
    content = <IndexPage navigate={navigate} />;
  } else if (page === '/the-beatles') {
    content = (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  }
  return <Layout>{content}</Layout>;
}

function BigSpinner() {
  return <h2>üåÄ Loading...</h2>;
}
```

```js src/Layout.js
export default function Layout({ children }) {
  return (
    <div className='layout'>
      <section className='header'>Music Browser</section>
      <main>{children}</main>
    </div>
  );
}
```

```js src/IndexPage.js
export default function IndexPage({ navigate }) {
  return (
    <button onClick={() => navigate('/the-beatles')}>
      Open The Beatles artist page
    </button>
  );
}
```

```js src/ArtistPage.js
import { Suspense } from 'react';
import Albums from './Albums.js';
import Biography from './Biography.js';
import Panel from './Panel.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Biography artistId={artist.id} />
      <Suspense fallback={<AlbumsGlimmer />}>
        <Panel>
          <Albums artistId={artist.id} />
        </Panel>
      </Suspense>
    </>
  );
}

function AlbumsGlimmer() {
  return (
    <div className='glimmer-panel'>
      <div className='glimmer-line' />
      <div className='glimmer-line' />
      <div className='glimmer-line' />
    </div>
  );
}
```

```js src/Albums.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Albums({ artistId }) {
  const albums = use(fetchData(`/${artistId}/albums`));
  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>
          {album.title} ({album.year})
        </li>
      ))}
    </ul>
  );
}
```

```js src/Biography.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Biography({ artistId }) {
  const bio = use(fetchData(`/${artistId}/bio`));
  return (
    <section>
      <p className='bio'>{bio}</p>
    </section>
  );
}
```

```js src/Panel.js
export default function Panel({ children }) {
  return <section className='panel'>{children}</section>;
}
```

```js src/data.js
// Note: the way you would do data fetching depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url === '/the-beatles/albums') {
    return await getAlbums();
  } else if (url === '/the-beatles/bio') {
    return await getBio();
  } else {
    throw Error('Not implemented');
  }
}

async function getBio() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 500);
  });

  return `The Beatles were an English rock band, 
    formed in Liverpool in 1960, that comprised 
    John Lennon, Paul McCartney, George Harrison 
    and Ringo Starr.`;
}

async function getAlbums() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 3000);
  });

  return [
    {
      id: 13,
      title: 'Let It Be',
      year: 1970,
    },
    {
      id: 12,
      title: 'Abbey Road',
      year: 1969,
    },
    {
      id: 11,
      title: 'Yellow Submarine',
      year: 1969,
    },
    {
      id: 10,
      title: 'The Beatles',
      year: 1968,
    },
    {
      id: 9,
      title: 'Magical Mystery Tour',
      year: 1967,
    },
    {
      id: 8,
      title: "Sgt. Pepper's Lonely Hearts Club Band",
      year: 1967,
    },
    {
      id: 7,
      title: 'Revolver',
      year: 1966,
    },
    {
      id: 6,
      title: 'Rubber Soul',
      year: 1965,
    },
    {
      id: 5,
      title: 'Help!',
      year: 1965,
    },
    {
      id: 4,
      title: 'Beatles For Sale',
      year: 1964,
    },
    {
      id: 3,
      title: "A Hard Day's Night",
      year: 1964,
    },
    {
      id: 2,
      title: 'With The Beatles',
      year: 1963,
    },
    {
      id: 1,
      title: 'Please Please Me',
      year: 1963,
    },
  ];
}
```

```css
main {
  min-height: 200px;
  padding: 10px;
}

.layout {
  border: 1px solid black;
}

.header {
  background: #222;
  padding: 10px;
  text-align: center;
  color: white;
}

.bio {
  font-style: italic;
}

.panel {
  border: 1px solid #aaa;
  border-radius: 6px;
  margin-top: 20px;
  padding: 10px;
}

.glimmer-panel {
  border: 1px dashed #aaa;
  background: linear-gradient(
    90deg,
    rgba(221, 221, 221, 1) 0%,
    rgba(255, 255, 255, 1) 100%
  );
  border-radius: 6px;
  margin-top: 20px;
  padding: 10px;
}

.glimmer-line {
  display: block;
  width: 60%;
  height: 20px;
  margin: 10px;
  border-radius: 4px;
  background: #f0f0f0;
}
```

</Sandpack>

---

## useTransition

Permet d'avoir acc√®s √† startTransition, ainsi que son √©tat `isPending`.

<Sandpack v19>

```js src/App.js
import { Suspense, useState, useTransition } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
  return (
    <Suspense fallback={<BigSpinner />}>
      <Router />
    </Suspense>
  );
}

function Router() {
  const [page, setPage] = useState('/');
  const [isPending, startTransition] = useTransition();

  function navigate(url) {
    startTransition(() => {
      setPage(url);
    });
  }

  let content;
  if (page === '/') {
    content = <IndexPage navigate={navigate} />;
  } else if (page === '/the-beatles') {
    content = (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  }
  return <Layout isPending={isPending}>{content}</Layout>;
}

function BigSpinner() {
  return <h2>üåÄ Loading...</h2>;
}
```

```js src/Layout.js
export default function Layout({ children, isPending }) {
  return (
    <div className='layout'>
      <section
        className='header'
        style={{
          opacity: isPending ? 0.7 : 1,
        }}
      >
        Music Browser
      </section>
      <main>{children}</main>
    </div>
  );
}
```

```js src/IndexPage.js
export default function IndexPage({ navigate }) {
  return (
    <button onClick={() => navigate('/the-beatles')}>
      Open The Beatles artist page
    </button>
  );
}
```

```js src/ArtistPage.js
import { Suspense } from 'react';
import Albums from './Albums.js';
import Biography from './Biography.js';
import Panel from './Panel.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Biography artistId={artist.id} />
      <Suspense fallback={<AlbumsGlimmer />}>
        <Panel>
          <Albums artistId={artist.id} />
        </Panel>
      </Suspense>
    </>
  );
}

function AlbumsGlimmer() {
  return (
    <div className='glimmer-panel'>
      <div className='glimmer-line' />
      <div className='glimmer-line' />
      <div className='glimmer-line' />
    </div>
  );
}
```

```js src/Albums.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Albums({ artistId }) {
  const albums = use(fetchData(`/${artistId}/albums`));
  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>
          {album.title} ({album.year})
        </li>
      ))}
    </ul>
  );
}
```

```js src/Biography.js
import { use } from 'react';
import { fetchData } from './data.js';

export default function Biography({ artistId }) {
  const bio = use(fetchData(`/${artistId}/bio`));
  return (
    <section>
      <p className='bio'>{bio}</p>
    </section>
  );
}
```

```js src/Panel.js
export default function Panel({ children }) {
  return <section className='panel'>{children}</section>;
}
```

```js src/data.js hidden
// Note: the way you would do data fetching depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url === '/the-beatles/albums') {
    return await getAlbums();
  } else if (url === '/the-beatles/bio') {
    return await getBio();
  } else {
    throw Error('Not implemented');
  }
}

async function getBio() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 500);
  });

  return `The Beatles were an English rock band, 
    formed in Liverpool in 1960, that comprised 
    John Lennon, Paul McCartney, George Harrison 
    and Ringo Starr.`;
}

async function getAlbums() {
  // Add a fake delay to make waiting noticeable.
  await new Promise((resolve) => {
    setTimeout(resolve, 3000);
  });

  return [
    {
      id: 13,
      title: 'Let It Be',
      year: 1970,
    },
    {
      id: 12,
      title: 'Abbey Road',
      year: 1969,
    },
    {
      id: 11,
      title: 'Yellow Submarine',
      year: 1969,
    },
    {
      id: 10,
      title: 'The Beatles',
      year: 1968,
    },
    {
      id: 9,
      title: 'Magical Mystery Tour',
      year: 1967,
    },
    {
      id: 8,
      title: "Sgt. Pepper's Lonely Hearts Club Band",
      year: 1967,
    },
    {
      id: 7,
      title: 'Revolver',
      year: 1966,
    },
    {
      id: 6,
      title: 'Rubber Soul',
      year: 1965,
    },
    {
      id: 5,
      title: 'Help!',
      year: 1965,
    },
    {
      id: 4,
      title: 'Beatles For Sale',
      year: 1964,
    },
    {
      id: 3,
      title: "A Hard Day's Night",
      year: 1964,
    },
    {
      id: 2,
      title: 'With The Beatles',
      year: 1963,
    },
    {
      id: 1,
      title: 'Please Please Me',
      year: 1963,
    },
  ];
}
```

```css
main {
  min-height: 200px;
  padding: 10px;
}

.layout {
  border: 1px solid black;
}

.header {
  background: #222;
  padding: 10px;
  text-align: center;
  color: white;
}

.bio {
  font-style: italic;
}

.panel {
  border: 1px solid #aaa;
  border-radius: 6px;
  margin-top: 20px;
  padding: 10px;
}

.glimmer-panel {
  border: 1px dashed #aaa;
  background: linear-gradient(
    90deg,
    rgba(221, 221, 221, 1) 0%,
    rgba(255, 255, 255, 1) 100%
  );
  border-radius: 6px;
  margin-top: 20px;
  padding: 10px;
}

.glimmer-line {
  display: block;
  width: 60%;
  height: 20px;
  margin: 10px;
  border-radius: 4px;
  background: #f0f0f0;
}
```

</Sandpack>

---

## Calling an API the classic way

<Sandpack>

```js src/ContactApi.js
// This encapsulates calls to the Rest API.
// GetAllContacts()
// getContact(id)
// saveContact(contact) //(create and update)
// deleteContact(id)
// registerNotification(fn)
// unregisterNotification(fn)
// resetContacts()

const base = 'https://contacts.reactacademy.live/api';

export default class ContactApi {
  static ws = null; //WebSocket for notifications

  static getAllContacts() {
    return fetch(`${base}/contacts`).then((resp) => resp.json());
  }

  static getContact(contactId) {
    return fetch(`${base}/contacts/${contactId}`).then((resp) => resp.json());
  }

  static saveContact(contact) {
    // Simulate server-side validation

    const minContactLength = 3;
    if (contact.firstName.length < minContactLength) {
      throw new Error(
        `First Name must be at least ${minContactLength} characters.`
      );
    }

    if (contact.lastName.length < minContactLength) {
      throw new Error(
        `Last Name must be at least ${minContactLength} characters.`
      );
    }

    if (contact.id) {
      //if id, update contact
      return fetch(`${base}/contacts/${contact.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(contact), // body data type must match "Content-Type" header
      });
    } else {
      //if no id, create contact
      return fetch(`${base}/contacts`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(contact), // body data type must match "Content-Type" header
      }).then((resp) => resp.json());
    }
  }

  static deleteContact(contactId) {
    return fetch(`${base}/contacts/${contactId}`, { method: 'DELETE' });
  }

  static async registerNotification(fn) {
    if (this.ws === null) {
      // this.ws = {};
      const res = await fetch(`${base}/negotiate`);
      const url = await res.json();
      this.ws = new WebSocket(url.url);

      this.ws.onopen = () => console.log('connected');

      this.ws.onmessage = () => {
        fn();
      };
    }
  }

  static async unregisterNotification() {
    if (this.ws !== null) {
      this.ws.close();
      this.ws = null;
    }
  }
  static resetContacts() {
    return fetch(`${base}/contacts/reset`);
  }
}
```

```jsx src/App.js
import { useEffect, useState } from 'react';
import ContactApi from './ContactApi';
import ContactTable from './ContactTable';

export default function App() {
  return <ContactContainer />;
}

function ContactContainer() {
  const [contacts, setContacts] = useState([]);
  const [loading, setLoading] = useState(false);

  // Effect to show data after first render
  useEffect(() => {
    refreshData();
  }, []);

  // Effect to register for change notification
  // useEffect(() => {
  //   ContactApi.registerNotification(refreshData);
  //   return () => {
  //     ContactApi.unregisterNotification();
  //   };
  // }, []);

  // This calls data (async)
  async function refreshData() {
    try {
      setLoading(true);
      await new Promise((resolve) => {
        setTimeout(resolve, 1500);
      });
      const data = await ContactApi.getAllContacts();
      setContacts(data);
    } catch (err) {
      console.log(err);
    } finally {
      setLoading(false);
    }
  }

  async function modifyContact(formData) {
    const contact = Object.fromEntries(formData);
    if (contact.id === '0') contact.id = 0;
    if (contact.id === null) return;
    await ContactApi.saveContact(contact);
    await refreshData();
  }

  async function deleteContact(id) {
    await ContactApi.deleteContact(id);
    refreshData();
  }

  return (
    <>
      <h1>Contacts (using Hooks)</h1>

      {loading ? (
        <div className='spinner' />
      ) : (
        <ContactTable
          contacts={contacts}
          modifyContact={modifyContact}
          deleteContact={deleteContact}
        />
      )}
    </>
  );
}
```

```jsx src/ContactTable.jsx
import { useState } from 'react';

export default function ContactTable({
  contacts,
  modifyContact,
  deleteContact,
}) {
  const [modificationRow, setModificationRow] = useState(null);

  function modifyRow(id) {
    setModificationRow(id);
  }

  return (
    <form
      onSubmit={async (evt) => {
        evt.preventDefault();
        setModificationRow(null);
        modifyContact(new FormData(evt.currentTarget));
      }}
    >
      <table>
        <thead>
          <tr>
            <th style={{ maxWidth: 70 }}>id</th>
            <th>First Name</th>
            <th>Last Name</th>
            <th>Email</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {contacts.map((contact) =>
            contact.id === modificationRow ? (
              <EditRow key={contact.id} contact={contact} setRow={modifyRow} />
            ) : (
              <Row
                key={contact.id}
                contact={contact}
                setRow={modifyRow}
                deleteContact={deleteContact}
              />
            )
          )}
        </tbody>
        <tfoot>
          {modificationRow === 0 ? (
            <EditRow
              contact={{ id: 0, firstName: '', lastName: '', email: '' }}
              setRow={modifyRow}
            />
          ) : (
            <tr>
              <td colSpan={5}>
                <button
                  title='Create Contact'
                  type='button'
                  onClick={() => {
                    setModificationRow(0);
                  }}
                >
                  ‚ûï Create Contact
                </button>
              </td>
            </tr>
          )}
        </tfoot>
      </table>
    </form>
  );
}

function Row({ contact, setRow, deleteContact }) {
  return (
    <tr key={contact.id}>
      <td
        style={{
          maxWidth: 70,
          whiteSpace: 'nowrap',
          overflow: 'hidden',
          textOverflow: 'ellipsis',
        }}
        title={contact.id.toString()}
      >
        {contact.id}
      </td>
      <td>{contact.firstName}</td>
      <td>{contact.lastName}</td>
      <td>
        <a href={`mailto:{contact.email}`}>{contact.email}</a>
      </td>
      <td style={{ display: 'flex' }}>
        <button
          title='Edit'
          type='button'
          onClick={() => {
            setRow(contact.id);
          }}
        >
          üñäÔ∏è
        </button>
        <button
          title='Details'
          type='button'
          onClick={() => alert(`goto details for ${contact.firstName}`)}
        >
          üßæ
        </button>
        <button
          title='Delete'
          type='button'
          onClick={() => deleteContact(contact.id)}
        >
          üóëÔ∏è
        </button>
      </td>
    </tr>
  );
}

function EditRow({ contact, setRow }) {
  return (
    <tr key={contact.id} className='bg-warning'>
      <td style={{ maxWidth: 70 }} title={contact.id.toString()}>
        <input name='id' placeholder='ID' defaultValue={contact.id} readOnly />
      </td>
      <td>
        <input
          name='firstName'
          placeholder='First Name'
          defaultValue={contact.firstName}
        />
      </td>
      <td className='align-middle'>
        <input
          name='lastName'
          placeholder='Last Name'
          defaultValue={contact.lastName}
        />
      </td>
      <td className='align-middle'>
        <input
          name='email'
          placeholder='name@email.com'
          defaultValue={contact.email}
        />
      </td>
      <td>
        <button title='Save' type='submit'>
          ‚úîÔ∏è
        </button>
        <button
          title='Cancel'
          type='button'
          onClick={() => {
            setRow(null);
          }}
        >
          ‚ùå
        </button>
      </td>
    </tr>
  );
}
```

```css
table {
  border-collapse: collapse;
}

table > * > * > * {
  border-width: 0px;
  border-bottom-width: 1px;
  border-color: #dddddd;
  border-style: solid;
}

table > tbody > tr:nth-of-type(odd) > * {
  background-color: rgba(0, 0, 0, 0.05);
}

table th {
  text-align: left;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.4em 1em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #d9d9d9;
  cursor: pointer;
  transition: border-color 0.25s;
  margin: 0.1em;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

input {
  display: inline-block;
  width: 100%;
  padding: 0.2rem 0.4rem;
  margin: 0.1rem 0rem;
  font-size: 1rem;
  line-height: 1.5;
  color: #495057;
  background-color: #fff;
  background-clip: padding-box;
  border: 1px solid #ced4da;
  border-radius: 0.25rem;
  transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
}

input:focus {
  color: #495057;
  background-color: #fff;
  border-color: #80bdff;
  outline: 0;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.spinner {
  display: inline-block;
  width: 2em;
  height: 2em;
  vertical-align: -0.125em;
  border-radius: 50%;
  animation: 0.75s linear infinite spinner;
  border: 0.25em solid currentcolor;
  border-right-color: transparent;
}

@keyframes spinner {
  to {
    transform: rotate(360deg) /* rtl:ignore */;
  }
}
```

</Sandpack>

---

## Calling an API with React 19

- No useEffects needed

<Sandpack v19>

```js src/ContactApi.js
// This encapsulates calls to the Rest API.
// GetAllContacts()
// getContact(id)
// saveContact(contact) //(create and update)
// deleteContact(id)
// registerNotification(fn)
// unregisterNotification(fn)
// resetContacts()

import { use } from 'react';
import { fetchData, removeFromCache } from './fetchData';

const base = 'https://contacts.reactacademy.live/api';

export default class ContactApi {
  static ws = null; //WebSocket for notifications

  static getAllContacts() {
    return use(fetchData(`${base}/contacts`));
  }

  static async refreshContacts() {
    removeFromCache(`${base}/contacts`);
    await fetchData(`${base}/contacts`, {
      delay: 1500,
    });
  }

  static removeContacts() {
    removeFromCache(`${base}/contacts`);
  }

  static getContact(contactId) {
    return fetch(`${base}/contacts/${contactId}`).then((resp) => resp.json());
  }

  static saveContact(contact) {
    // Simulate server-side validation

    const minContactLength = 3;
    if (contact.firstName.length < minContactLength) {
      throw new Error(
        `First Name must be at least ${minContactLength} characters.`
      );
    }

    if (contact.lastName.length < minContactLength) {
      throw new Error(
        `Last Name must be at least ${minContactLength} characters.`
      );
    }

    if (contact.id) {
      //if id, update contact
      return fetch(`${base}/contacts/${contact.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(contact), // body data type must match "Content-Type" header
      });
    } else {
      //if no id, create contact
      return fetch(`${base}/contacts`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(contact), // body data type must match "Content-Type" header
      }).then((resp) => resp.json());
    }
  }

  static deleteContact(contactId) {
    return fetch(`${base}/contacts/${contactId}`, { method: 'DELETE' });
  }

  static async registerNotification(fn) {
    if (this.ws === null) {
      // this.ws = {};
      const res = await fetch(`${base}/negotiate`);
      const url = await res.json();
      this.ws = new WebSocket(url.url);

      this.ws.onopen = () => console.log('connected');

      this.ws.onmessage = () => {
        fn();
      };
    }
  }

  static async unregisterNotification() {
    if (this.ws !== null) {
      this.ws.close();
      this.ws = null;
    }
  }
  static resetContacts() {
    return fetch(`${base}/contacts/reset`);
  }
}
```

```jsx src/App.js
import { useEffect, useState, Suspense, use } from 'react';
import { removeFromCache, fetchData } from './fetchData';
import useRerender from './useRerender';
import ContactApi from './ContactApi';
import ContactTable from './ContactTable';

export default function App() {
  return (
    <Suspense fallback={<div className='spinner' />}>
      <ContactContainer />
    </Suspense>
  );
}

function ContactContainer() {
  const contacts = ContactApi.getAllContacts();
  const forceRerender = useRerender();

  // Effect to register for change notification
  // useEffect(() => {
  //   ContactApi.registerNotification(refreshData);
  //   return () => {
  //     ContactApi.unregisterNotification();
  //   };
  // }, []);

  async function modifyContact(formData) {
    const contact = Object.fromEntries(formData);
    if (contact.id === '0') contact.id = 0;
    if (contact.id === null) return;
    await ContactApi.saveContact(contact);
    await ContactApi.refreshContacts();
    forceRefresh();
  }

  async function deleteContact(id) {
    await ContactApi.deleteContact(id);
  }

  return (
    <>
      <h1>Contacts (using Hooks)</h1>
      <ContactTable
        contacts={contacts}
        modifyContact={modifyContact}
        deleteContact={deleteContact}
      />
    </>
  );
}
```

```jsx src/ContactTable.jsx
import { useState, useActionState, useOptimistic } from 'react';
import { removeFromCache, fetchData } from './fetchData';

export default function ContactTable({
  contacts,
  modifyContact,
  deleteContact,
}) {
  const [modificationRow, setModificationRow] = useState(null);
  const [optimisticContacts, setOptimisticContacts] = useOptimistic(
    contacts,
    (contacts, newContact) =>
      newContact.id === 0
        ? [...contacts, newContact]
        : contacts.map((c) => (c.id === newContact.id ? newContact : c))
  );
  const [ctx, submitAction, isPending] = useActionState(
    async (previousState, formData) => {
      setOptimisticContacts(Object.fromEntries(formData));
      setModificationRow(null);

      await modifyContact(formData);
      return null;
    },
    null
  );

  function modifyRow(id) {
    setModificationRow(id);
  }

  return (
    <form action={submitAction}>
      <table>
        <thead>
          <tr>
            <th style={{ maxWidth: 70 }}>id</th>
            <th>First Name</th>
            <th>Last Name</th>
            <th>Email</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {optimisticContacts.map((contact) =>
            contact.id === modificationRow && !isPending ? (
              <EditRow key={contact.id} contact={contact} setRow={modifyRow} />
            ) : (
              <Row
                key={contact.id}
                contact={contact}
                setRow={modifyRow}
                deleteContact={deleteContact}
              />
            )
          )}
        </tbody>
        <tfoot>
          {modificationRow === 0 ? (
            <EditRow
              contact={{ id: 0, firstName: '', lastName: '', email: '' }}
              setRow={modifyRow}
            />
          ) : (
            <tr>
              <td colSpan={5}>
                <button
                  title='Create Contact'
                  type='button'
                  onClick={() => {
                    setModificationRow(0);
                  }}
                >
                  ‚ûï Create Contact
                </button>
              </td>
            </tr>
          )}
        </tfoot>
      </table>
    </form>
  );
}

function Row({ contact, setRow, deleteContact }) {
  return (
    <tr key={contact.id}>
      <td
        style={{
          maxWidth: 70,
          whiteSpace: 'nowrap',
          overflow: 'hidden',
          textOverflow: 'ellipsis',
        }}
        title={contact.id.toString()}
      >
        {contact.id}
      </td>
      <td>{contact.firstName}</td>
      <td>{contact.lastName}</td>
      <td>
        <a href={`mailto:{contact.email}`}>{contact.email}</a>
      </td>
      <td style={{ display: 'flex' }}>
        <button
          title='Edit'
          type='button'
          onClick={() => {
            setRow(contact.id);
          }}
        >
          üñäÔ∏è
        </button>
        <button
          title='Details'
          type='button'
          onClick={() => alert(`goto details for ${contact.firstName}`)}
        >
          üßæ
        </button>
        <button
          title='Delete'
          type='button'
          onClick={() => deleteContact(contact.id)}
        >
          üóëÔ∏è
        </button>
      </td>
    </tr>
  );
}

function EditRow({ contact, setRow }) {
  return (
    <tr key={contact.id} className='bg-warning'>
      <td style={{ maxWidth: 70 }} title={contact.id.toString()}>
        <input name='id' placeholder='ID' defaultValue={contact.id} readOnly />
      </td>
      <td>
        <input
          name='firstName'
          placeholder='First Name'
          defaultValue={contact.firstName}
        />
      </td>
      <td className='align-middle'>
        <input
          name='lastName'
          placeholder='Last Name'
          defaultValue={contact.lastName}
        />
      </td>
      <td className='align-middle'>
        <input
          name='email'
          placeholder='name@email.com'
          defaultValue={contact.email}
        />
      </td>
      <td>
        <button title='Save' type='submit'>
          ‚úîÔ∏è
        </button>
        <button
          title='Cancel'
          type='button'
          onClick={() => {
            setRow(null);
          }}
        >
          ‚ùå
        </button>
      </td>
    </tr>
  );
}
```

```jsx src/fetchData.js
let cache = new Map();

//this fetchData uses simple caching
export function fetchData(url, options) {
  if (!cache.has(url)) {
    cache.set(url, getData(url, options));
  }
  return cache.get(url);
}

async function getData(url, options) {
  const { delay, ...rest } = options ?? {};

  //artificial delay
  if (delay) {
    await new Promise((resolve) => {
      setTimeout(resolve, delay);
    });
  }

  const response = await fetch(url, rest);
  return await response.json();
}

export function removeFromCache(url) {
  if (cache.has(url)) {
    cache.delete(url);
  }
}
```

```jsx src/useRerender.jsx
import { useState } from 'react';

export default function useRerender() {
  const [, setRerender] = useState();

  function forceRerender() {
    setRerender({});
  }

  return forceRerender;
}
```

```css
table {
  border-collapse: collapse;
}

table > * > * > * {
  border-width: 0px;
  border-bottom-width: 1px;
  border-color: #dddddd;
  border-style: solid;
}

table > tbody > tr:nth-of-type(odd) > * {
  background-color: rgba(0, 0, 0, 0.05);
}

table th {
  text-align: left;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.4em 1em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #d9d9d9;
  cursor: pointer;
  transition: border-color 0.25s;
  margin: 0.1em;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

input {
  display: inline-block;
  width: 100%;
  padding: 0.2rem 0.4rem;
  margin: 0.1rem 0rem;
  font-size: 1rem;
  line-height: 1.5;
  color: #495057;
  background-color: #fff;
  background-clip: padding-box;
  border: 1px solid #ced4da;
  border-radius: 0.25rem;
  transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
}

input:focus {
  color: #495057;
  background-color: #fff;
  border-color: #80bdff;
  outline: 0;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.spinner {
  display: inline-block;
  width: 2em;
  height: 2em;
  vertical-align: -0.125em;
  border-radius: 50%;
  animation: 0.75s linear infinite spinner;
  border: 0.25em solid currentcolor;
  border-right-color: transparent;
}

@keyframes spinner {
  to {
    transform: rotate(360deg) /* rtl:ignore */;
  }
}
```

</Sandpack>

---

## Questions?

<img
  src='/img/job.jpeg'
  style={{ marginLeft: 'auto', marginRight: 'auto', width: '50%' }}
/>
