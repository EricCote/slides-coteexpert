---
title: React 19
---

# Les nouveautés de React 19

---

## Grandes lignes

- Actions
- Server Components
- Chargement de Asset
- Gestion des Métadonnées
- Composants Web
- Nouveaux Hooks
- React Compiler

---

## Actions

Toute fonction utilisant une transition Asynchrone est une Action.

Les Actions gèrent l'envoi de données:

**Pending state** (État en attente): Permet d'avoir un état d'attente qui démarre au début de la requête et termine quand l'update final est complété

**Optimistic updates** (Mises-à-jour optimistes): Les Actions supportent le nouveau hook `useOptimistic`. Nous avons un feedback immédiat pendant que les données sont envoyées.

**Error Handling** (Gestion d'erreur): Permet d'afficher des "Error Boundaries" si une requête échoue, et reset aux valeurs originales.

**Formulaires** les éléments `<form>` permettent de passer des fonctions à `action` et `formAction`. Cela utilise une action et réinitialise après l'envoi.

---

## Ancienne façon de gérer les actions

Approche classique de React 16-17

<Sandpack  >

```jsx src/App.js active
import { useState } from 'react';
import { redirect, updateName } from './util.js';

export default function UpdateName({}) {
  const [name, setName] = useState('');
  const [error, setError] = useState(null);
  const [isPending, setIsPending] = useState(false);

  const handleSubmit = async () => {
    setIsPending(true);
    const error = await updateName(name);
    setIsPending(false);
    if (error) {
      setError(error);
      return;
    }
    redirect('/path');
  };

  return (
    <div>
      <input value={name} onChange={(event) => setName(event.target.value)} />
      <button onClick={handleSubmit} disabled={isPending}>
        {isPending ? 'Updating...' : 'Update'}
      </button>
      {error && <p>{error}</p>}
    </div>
  );
}
```

```jsx src/util.js
function wait(milliseconds) {
  return new Promise((resolve) => setTimeout(resolve, milliseconds));
}

export function redirect(page) {
  alert(`Should redirect to '${page}'`);
}

export async function updateName(name) {
  await wait(1000);
  if (name.length < 2) {
    return 'Name too short';
  }
  alert(`Success updating name to '${name}'`);
}
```

</Sandpack>

---

## Gérer l'état d'attente avec useTransition

Fonctionne avec React 18

<Sandpack  >

```jsx src/App.js active
import { useState, useTransition } from 'react';
import { redirect, updateName } from './util.js';

export default function UpdateName({}) {
  const [name, setName] = useState('');
  const [error, setError] = useState(null);
  const [isPending, startTransition] = useTransition();

  function handleSubmit() {
    startTransition(async () => {
      const error = await updateName(name);
      if (error) {
        setError(error);
        return;
      }
      redirect('/path');
    });
  }

  return (
    <div>
      <input value={name} onChange={(event) => setName(event.target.value)} />
      <button onClick={handleSubmit} disabled={isPending}>
        {isPending ? 'Updating...' : 'Update'}
      </button>
      {error && <p>{error}</p>}
    </div>
  );
}
```

```jsx src/util.js
function wait(milliseconds) {
  return new Promise((resolve) => setTimeout(resolve, milliseconds));
}

export function redirect(page) {
  alert(`Should redirect to '${page}'`);
}

export async function updateName(name) {
  await wait(1000);
  if (name.length < 2) {
    return 'Name too short';
  }
  alert(`Success updating name to '${name}'`);
}
```

</Sandpack>

---

## Form Actions et useActionState

<Sandpack v19  >

```jsx src/App.js active
import { useState, useTransition, useActionState } from 'react';
import { redirect, updateName } from './util.js';

// Using <form> Actions and useActionState
export default function ChangeName({ name, setName }) {
  const [error, submitAction, isPending] = useActionState(
    async (previousState, formData) => {
      const error = await updateName(formData.get('name'));
      if (error) {
        return error;
      }
      redirect('/path');
      return null;
    },
    null
  );

  return (
    <form action={submitAction}>
      <input type='text' name='name' />
      <button type='submit' disabled={isPending}>
        Update
      </button>
      {error && <p>{error}</p>}
    </form>
  );
}
```

```jsx src/util.js
function wait(milliseconds) {
  return new Promise((resolve) => setTimeout(resolve, milliseconds));
}

export function redirect(page) {
  alert(`Should redirect to '${page}'`);
}

export async function updateName(name) {
  await wait(1000);
  if (name.length < 2) {
    return 'Name too short';
  }
  alert(`Success updating name to '${name}'`);
}
```

</Sandpack>

---

## useActionState en détail

```jsx
const [state, submitAction, isPending] = useActionState(
  async (previousState, newName) => {
    const data = await updateName(newName);
    if (data.error) {
      // You can return any result of the action.
      // Here, we return the state.
      return data;
    }

    // handle success
    return data;
  },
  null
);
```

---

## Actions avec `<form>`

On peut passer **action** à `<form>`.

```jsx
<form action={actionFunction}>
```

On peut passer **formAction** à `<input>` et `<button>` ce qui modifie le **action** du `<form>` parent.

```jsx
<input type='submit' formAction={actionFunction} />
```

Quand l'action réussit, React fait un reset des composants non-controllés.

On peut appeler `requestFormReset()` pour forcer un reset.

---

## useFormStatus

`useFormStatus` retourne l'état du `<form>` parent le plus proche (similaire au Context Provider)

```jsx
import { useFormStatus } from 'react-dom';

function DesignButton() {
  const { pending } = useFormStatus();
  return <button type='submit' disabled={pending} />;
}
```

```jsx
const { pending, data, method, action } = useFormStatus();
```

---

## useFormStatus

<Sandpack  v19 >

```jsx src/App.js active
import { useState, useTransition, useActionState, useOptimistic } from 'react';
import { useFormStatus } from 'react-dom';
import { redirect, updateName } from './util.js';

export default function ChangeName() {
  async function submitAction(formData) {
    const data = await updateName(formData.get('name'));
  }

  return (
    <form action={submitAction}>
      <Status />
      <p>
        <label>Change Name: </label>
        <input type='text' name='name' />
        <button>Submit</button>
      </p>
    </form>
  );
}

function Status() {
  const { pending } = useFormStatus();
  return pending ? <p>Pending...</p> : <p>Done!</p>;
}
```

```jsx src/util.js
function wait(milliseconds) {
  return new Promise((resolve) => setTimeout(resolve, milliseconds));
}

export function redirect(page) {
  alert(`Should redirect to '${page}'`);
}

export async function updateName(name) {
  await wait(1000);
  alert(`Success updating name to '${name.toUpperCase()}'`);
  return name.toUpperCase();
}
```

</Sandpack>

---

### UseOptimistic

<Sandpack  v19>

```jsx src/App.js active
import { useState, useTransition, useActionState, useOptimistic } from 'react';
import { redirect, updateName } from './util.js';

export default function App() {
  const [name, setName] = useState('');
  return <ChangeName currentName={name} onUpdateName={setName} />;
}

// Using useOptimistic
function ChangeName({ currentName, onUpdateName }) {
  const [optimisticName, setOptimisticName] = useOptimistic(currentName);

  const submitAction = async (formData) => {
    const newName = formData.get('name');
    setOptimisticName(newName);
    const updatedName = await updateName(newName);
    onUpdateName(updatedName);
  };

  return (
    <form action={submitAction}>
      <p>Your name is: {optimisticName}</p>
      <p>
        <label>Change Name: </label>
        <input
          type='text'
          name='name'
          disabled={currentName !== optimisticName}
        />
        <button>Submit</button>
      </p>
    </form>
  );
}
```

```jsx src/util.js
function wait(milliseconds) {
  return new Promise((resolve) => setTimeout(resolve, milliseconds));
}

export function redirect(page) {
  alert(`Should redirect to '${page}'`);
}

export async function updateName(name) {
  await wait(1000);
  alert(`Success updating name to '${name}'`);
  return name;
}
```

</Sandpack>

---

### Utilisation de use Optimistic

Pendant le `action` du `<form>`, le `setState` est cédulé pour la toute fin du action

Pour permettre de céduler des render **avant** la fin du action, on utilise `useOptimistic`

La portée de `useOptimistic` est le temps d'appeler `action`. Après que `action` complète, cela reset.

---

## Combiner les technologies

<Sandpack  v19>

```jsx src/App.js active
import { useState, useTransition, useActionState, useOptimistic } from 'react';
import { useFormStatus } from 'react-dom';
import { redirect, updateName } from './util.js';

export default function App() {
  const [name, setName] = useState('');
  return <ChangeName currentName={name} onUpdateName={setName} />;
}

// Using useOptimistic
function ChangeName({ currentName, onUpdateName }) {
  const [optimisticName, setOptimisticName] = useOptimistic(currentName);

  const [data, submitAction, isPending] = useActionState(
    async (previousState, formData) => {
      const newName = formData.get('name');
      setOptimisticName(newName);
      const data = await updateName(newName);
      if (data.error) {
        return data.error;
      }
      onUpdateName(data);
      return data;
    },
    null
  );

  return (
    <form action={submitAction}>
      <Status />
      <p>Your name is: {optimisticName}</p>
      <p>
        <label>Change Name: </label>
        <input
          type='text'
          name='name'
          disabled={currentName !== optimisticName}
        />
        <button>Submit</button>
      </p>
    </form>
  );
}

function Status() {
  const { pending } = useFormStatus();
  return pending ? <p>Pending...</p> : <p>Done!</p>;
}
```

```jsx src/util.js
function wait(milliseconds) {
  return new Promise((resolve) => setTimeout(resolve, milliseconds));
}

export function redirect(page) {
  alert(`Should redirect to '${page}'`);
}

export async function updateName(name) {
  await wait(1000);
  alert(`Success updating name to '${name.toUpperCase()}'`);
  return name.toUpperCase();
}
```

</Sandpack>
