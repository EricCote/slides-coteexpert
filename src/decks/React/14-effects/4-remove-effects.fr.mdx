---
title: '√âliminer les Effects inutiles'
---

# √âliminer les Effects inutiles

---

## Les Effects ne sont pas tous utiles

- Un Effect est une fa√ßon d'ex√©cuter du code hors du paradigme de React
- √áa permet de synchroniser nos composants avec un syst√®me externe
  - Un widget non-React, un appel r√©seau, un apel au DOM
- Si on ne collabore pas avec un syst√®me externe, alors Effect est inutile
- √âliminer un effect inutile est une excellente id√©e
  - Plus simple √† lire le code
  - Plus rapide
  - Moins de risque d'erreur

---

## Points importants

- Pourquoi enlever les Effects inutiles
- Comment cacher des calculs co√ªteux sans Effects
- Comment r√©initialiser l'√©tat sans Effects
- Comment partager la logique entre gestionnaires d'√©v√©nements
- D√©placer un Effect vers un gestionnaire d'√©v√©nement
- Notifier un parent des changements

---

## √âliminer les Effects inutiles

- Deux cas communs o√π le Effect n'est pas utile:
- **Transformer les donn√©es du rendu**
  - Pour filtrer une liste, on pourrait appeler setState dans un Effect
  - Mais ce n'est pas tr√®s efficace
    - React fait un premier rendu
    - React appelle l'Effect
    - React c√©dule le changement de state et un nouveau rendu
    - React fait un second rendu avec les donn√©es filtr√©es
  - Ces transformations devraient √™tre appel√©es directement du rendu, sans Effect
- **G√©rer un √©v√©nement utilisateur**
  - On pourrait g√©rer le POST vers '/api/buy' avec un Effect.
  - Mais au moment de l'ex√©cution de l'effect, il n'est plus possible de d√©terminer l'action exacte de l'utilisateur (ex: le bouton cliqu√©)

---

## Effect est parfois utile

- Il faut des Effects, pour synchronisaer avec des librairies externes
  - Synchroniser un widget jQuery avec un √©tat React
  - Otenir des donn√©es via fetch pour synchoniser une liste de r√©sultats avec le champ de recherche.

---

## Probl√®me: Utiliser un Effect pour modifier un prop ou un √©tat

- Imaginons un `fullName` d√©rivant de `firstName` et `lastName`
- On pourrait imaginer g√©rer `fullName` dans un √©tat, synchronis√© via un Effect: (Mauvais)

```js {5-9}
function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');

  // üî¥ Avoid: redundant state and unnecessary Effect
  const [fullName, setFullName] = useState('');
  useEffect(() => {
    setFullName(firstName + ' ' + lastName);
  }, [firstName, lastName]);
  // ...
}
```

- Mauvais: ceci g√©n√®re des rendus additionnels
- un premier rendu avec le `fullName` moisi, et un second avec le `fullName` mis √† jour

---

## Solution: Calculer la valeur durant le rendu

```js {4-5}
function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');
  // ‚úÖ Good: calculated during rendering
  const fullName = firstName + ' ' + lastName;
  // ...
}
```

- Ce que l'on peut calculer (√† partir de props ou d'√©tat) ne devrait pas √™tre stock√© dans un √©tat, mais plut√¥t calcul√© au rendu.
  - Plus rapide (on √©vite des rendus additionnels)
  - Plus simple
  - Moins de bogues

---

## Probl√®me: Utiliser Effect pour faire du travail ou des calculs

- Voici un autre mauvais exemple, pour fitrer le visuel d'une liste.

```js {4-8}
function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');

  // üî¥ Avoid: redundant state and unnecessary Effect
  const [visibleTodos, setVisibleTodos] = useState([]);
  useEffect(() => {
    setVisibleTodos(getFilteredTodos(todos, filter));
  }, [todos, filter]);

  // ...
}
```

---

## Solution 1: Faire le travail ou le calcul dans le rendu

On peut √©liminer l'√âtat et l'Effect

```js {3-4}
function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  // ‚úÖ This is fine if getFilteredTodos() is not slow.
  const visibleTodos = getFilteredTodos(todos, filter);
  // ...
}
```

---

## Solution 2: Cacher le r√©sultat quand le travail est long

Si `getFilteredTodos()` est lent ou qu'il y a beaucoup de `todos`, il faut limiter le nombre d'appels √† la fonction

Il faut cacher le r√©sultat dans une m√©mo√Øsation avec `useMemo`

```js {5-6}
import { useMemo, useState } from 'react';

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  // ‚úÖ Does not re-run getFilteredTodos() unless todos or filter change
  const visibleTodos = useMemo(
    () => getFilteredTodos(todos, filter),
    [todos, filter]
  );
  // ...
}
```

On n'ex√©cute pas la fonction tant que `todos` or `filter` conservent leurs valeurs. On retourne plut√¥t le dernier r√©sultat cach√©.

La fonction pass√©e √† `useMemo` doit √™tre pure, car elle roule pendant un rendu.

---

## D√©terminer si un calcul est long

- Si l'on cr√©√© ou l'on boucle sur des milliers d'objets, l'ex√©cution peut √™tre lente.
- On peut utiliser la console pour mesurer la dur√©e d'une fonction

```js {1,3}
console.time('filter array');
const visibleTodos = getFilteredTodos(todos, filter);
console.timeEnd('filter array');
```

- Le r√©sulat sera: `filter array: 0.15ms{:txt}`
- Si la dur√©e est significative (plus de `1ms{:txt}`), on pourrait m√©mo√Øser avec `useMemo`

```js
console.time('filter array');
const visibleTodos = useMemo(() => {
  return getFilteredTodos(todos, filter); // Skipped if todos and filter haven't changed
}, [todos, filter]);
console.timeEnd('filter array');
```

---

## D√©tails sur la performance

- `useMemo` n'aide pas la performance du premier rendu.
  - Cela peut aider les rendus suivants (si le r√©sultat est dans la cache).
- On peut aussi tester avec un ralentissement artificiel
  - ex: le [CPU Throttling](https://developer.chrome.com/blog/new-in-devtools-61/#throttling) de Chrome
- En `StrictMode`, l'application ex√©cute les rendus deux fois.
  - Le mode production (build) permet de mesurer la performance dans le monde r√©el

---

## Probl√®me: Effect pour r√©initialiser l'√©tat quand prop change

**Probl√®me**: Dans le `ProfilePage`, le champ `comment` ne r√©initialise pas quand on navigue d'un profil √† l'autre.

On pourrait r√©parer le code de cette fa√ßon (mauvaise approche):

```js {4-7}
export default function ProfilePage({ userId }) {
  const [comment, setComment] = useState('');

  // üî¥ Avoid: Resetting state on prop change in an Effect
  useEffect(() => {
    setComment('');
  }, [userId]);
  // ...
}
```

**Inefficace**: `ProfilePage` (et tous ses enfants) feront deux rendus: un premier avec le "vieux" `comment`, et un second avec le `comment` initialis√©.

---

## Solution: Passer une key diff√©rente cr√©√© un nouveau composant

On pourrait sp√©cifier que chaque profil est un composant diff√©rent en sp√©cifiant une cl√© explicite. Si on s√©pare le composant en deux, c'est facile de passer l'attribut `key`.

```js {5,11-12}
export default function ProfilePage({ userId }) {
  return <Profile userId={userId} key={userId} />;
}

function Profile({ userId }) {
  // ‚úÖ This and any other state below will reset on key change automatically
  const [comment, setComment] = useState('');
  // ...
}
```

React conserve l'√©tat des composants qui sont rendus √† la m√™me position. En utilisant un `key` diff√©rent, on indique que c'est un composant diff√©rent, avec de nouveaux enfants et un nouvel √©tat.

`ProfilePage` serait le composant export√© et visible. `Profile` serait un d√©tail d'implantation priv√©.

---

## Probl√®me: Effect pour r√©initialiser un √©tat quand prop change

Si on ne veut r√©initialiser qu'une partie de l'√©tat?

Quand la liste d'`items` change, on veut r√©initiliser la `selection`, mais pas `isReverse`.

```js {5-8}
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selection, setSelection] = useState(null);

  // üî¥ Avoid: Adjusting state on prop change in an Effect
  useEffect(() => {
    setSelection(null);
  }, [items]);
  // ...
}
```

**Inefficace**, car on fait deux rendus.

---

## Solution 1: Modifier l'√©tat dans le rendu

On ajuste l'√©tat pendant le rendu pour √©liminer l'Effect.

```js {5-11}
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selection, setSelection] = useState(null);

  // Better: Adjust the state while rendering
  const [prevItems, setPrevItems] = useState(items);
  if (items !== prevItems) {
    setPrevItems(items);
    setSelection(null);
  }
  // ...
}
```

- On stocke les items du rendu pr√©c√©dent, dans `prevItems`
- `setPrevItems` c√©dule un changement d'√©tat (quand les `items` changent)
- Quand le composant termine le rendu (apr√®s `return <jsx />` ):
  - React interrompt le rendu courant, se d√©barasse du JSX
  - Pas de rendu des enfants, pas de commit, pas de modification du DOM
  - Le changement d'√©tat compl√®te ensuite, et lance un rendu

---

## D√©tails d'optimisation

- Pendant le rendu, React ne permet de modifier que l'√©tat local
- Erreur retourn√©e, si on modifie l'√©tat d'un autre composant
- Il faut √©viter une boucle infinie de rendus
  - En ajoutant une condition (ex: `items !== prevItems`)
- Cette solution n'est pas id√©ale
  - On pourait √©liminer l'√©tat

---

## Solution 2: √âliminer l'√©tat redondant

- On peut r√©duire l'√©tat, en ne stockant que l'`item.id`, plut√¥t que l'`item`

```js {3-5}
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selectedId, setSelectedId] = useState(null);
  // ‚úÖ Best: Calculate everything during rendering
  const selection = items.find((item) => item.id === selectedId) ?? null;
  // ...
}
```

- Plus besoin d'ajuster l'√©tat:
  - Si le ID s√©lectionn√© est dans la liste, il demeure s√©lectionn√©
  - Sinon, la `selection` sera `null`

---

## Probl√®me: Effect ex√©cute du code suite √† un √©v√©nement

Imaginons une page produits avec deux boutons (_Buy_ et _Checkout_). Ces deux boutons affichent une notification quand on ajoute un produit dans le panier. Appeler `showNotification()` dans les gestionnaires de clic est r√©p√©titif. On serait tent√© de placer cela dans un effet.

```js {2-7}
function ProductPage({ product, addToCart }) {
  // üî¥ Avoid: Event-specific logic inside an Effect
  useEffect(() => {
    if (product.isInCart) {
      showNotification(`Added ${product.name} to the shopping cart!`);
    }
  }, [product]);

  function handleBuyClick() {
    addToCart(product);
  }

  function handleCheckoutClick() {
    addToCart(product);
    navigateTo('/checkout');
  }
  // ...
}
```

---

## Probl√®mes

- L'approche pr√©c√©dente pourrait causer des bogues.
- Imaginons que l'app conserve le panier entre les "chargements"
  - Un "refresh" reprovoque la notification
  - `product.isInCart` est d√©j√† √† vrai, et `showNotification` est appel√© √† nouveau
- Les effets sont utiles quand on veut rouler du code **suite** √† l'affichage du composant
  - Mais ici, on veut rouler le code **suite** au clic du bouton

---

## Solution: Appeler ce code dans le gestionnaire d'√©v√©nements

```js {2-6,9,13}
function ProductPage({ product, addToCart }) {
  // ‚úÖ Good: Event-specific logic is called from event handlers
  function buyProduct() {
    addToCart(product);
    showNotification(`Added ${product.name} to the shopping cart!`);
  }

  function handleBuyClick() {
    buyProduct();
  }

  function handleCheckoutClick() {
    buyProduct();
    navigateTo('/checkout');
  }
  // ...
}
```

le code ci-haut √©limine l'Effet et le bogue

---

### Probl√®me: Utiliser Effet pour envoyer POST

Ce formulaire envoie deux requ√™tes POST: un √©v√©nement analytique au montage, et un post √† `/api/register` quand on clique _Submit_

```js {5-8,10-16}
function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  // ‚úÖ Good: This logic should run because the component was displayed
  useEffect(() => {
    post('/analytics/event', { eventName: 'visit_form' });
  }, []);

  // üî¥ Avoid: Event-specific logic inside an Effect
  const [jsonToSubmit, setJsonToSubmit] = useState(null);
  useEffect(() => {
    if (jsonToSubmit !== null) {
      post('/api/register', jsonToSubmit);
    }
  }, [jsonToSubmit]);

  function handleSubmit(e) {
    e.preventDefault();
    setJsonToSubmit({ firstName, lastName });
  }
  // ...
}
```

---

## Solution: d√©placer ce code vers un gestionnaire d'√©v√©nements

- L'effect est correct pour les donn√©es analytiques, car on veut notifier **suite** √† l'affichage du fomulaire.
- Mais l'appel POST de `/api/register` devrait √™tre associ√© au "submit" du formulaire, plut√¥t qu'√† l'affichage.
- √âliminons le second Effect:

```js {12-13}
function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  // ‚úÖ Good: This logic runs because the component was displayed
  useEffect(() => {
    post('/analytics/event', { eventName: 'visit_form' });
  }, []);

  function handleSubmit(e) {
    e.preventDefault();
    // ‚úÖ Good: Event-specific logic is in the event handler
    post('/api/register', { firstName, lastName });
  }
  // ...
}
```

---

### Probl√®me: Effect ex√©cute une cha√Æne de calculs

On pourrait √™tre tent√© de cha√Æner les effets, modifier un √©tat bas√© sur un autre √©tat.

```js {7-29}
function Game() {
  const [card, setCard] = useState(null);
  const [goldCardCount, setGoldCardCount] = useState(0);
  const [round, setRound] = useState(1);
  const [isGameOver, setIsGameOver] = useState(false);

  // üî¥ Avoid: Chains of Effects that adjust the state solely to trigger each other
  useEffect(() => {
    if (card !== null && card.gold) {
      setGoldCardCount(c => c + 1);
    }
  }, [card]);

  useEffect(() => {
    if (goldCardCount > 3) {
      setRound(r => r + 1)
      setGoldCardCount(0);
    }
  }, [goldCardCount]);

  useEffect(() => {
    if (round > 5) {
      setIsGameOver(true);
    }
  }, [round]);

  useEffect(() => {
    alert('Good game!');
  }, [isGameOver]);

  function handlePlaceCard(nextCard) {
    if (isGameOver) {
      throw Error('Game already ended.');
    } else {
      setCard(nextCard);
    }
  }

  // ...
```

---

## Probl√®mes

C'est **inefficace**: le composant (et ses enfants) sont re-rendus entre chaque appel `set` dans la cha√Æne.

Par exemple: `setCard` ‚Üí render ‚Üí `setGoldCardCount` ‚Üí render ‚Üí `setRound` ‚Üí render ‚Üí `setIsGameOver` ‚Üí render

C'est beaucoup de rendus inutiles.

Autre probl√®me: si un jour, le jeu a besoin de naviguer dans l'historique des tours pr√©c√©dents, il faut ramener les variables d'√©tats. Ceci entrainerait une cascade de `setState`.

C'est donc du code rigide et fragile

---

## Solution: D√©placer ce code dans le rendu et les √©v√©nements

Dans ce cas, vaut mieux utiliser des calculs pendant le rendu, et garder la modification des √©tats dans les √©v√©nements:

```js {6-7,14-26}
function Game() {
  const [card, setCard] = useState(null);
  const [goldCardCount, setGoldCardCount] = useState(0);
  const [round, setRound] = useState(1);

  // ‚úÖ Calculate what you can during rendering
  const isGameOver = round > 5;

  function handlePlaceCard(nextCard) {
    if (isGameOver) {
      throw Error('Game already ended.');
    }

    // ‚úÖ Calculate all the next state in the event handler
    setCard(nextCard);
    if (nextCard.gold) {
      if (goldCardCount <= 3) {
        setGoldCardCount(goldCardCount + 1);
      } else {
        setGoldCardCount(0);
        setRound(round + 1);
        if (round === 5) {
          alert('Good game!');
        }
      }
    }
  }

  // ...
```

This is a lot more efficient. Also, if you implement a way to view game history, now you will be able to set each state variable to a move from the past without triggering the Effect chain that adjusts every other value. If you need to reuse logic between several event handlers, you can [extract a function](#sharing-logic-between-event-handlers) and call it from those handlers.

Remember that inside event handlers, [state behaves like a snapshot.](/learn/state-as-a-snapshot) For example, even after you call `setRound(round + 1)`, the `round` variable will reflect the value at the time the user clicked the button. If you need to use the next value for calculations, define it manually like `const nextRound = round + 1`.

In some cases, you _can't_ calculate the next state directly in the event handler. For example, imagine a form with multiple dropdowns where the options of the next dropdown depend on the selected value of the previous dropdown. Then, a chain of Effects is appropriate because you are synchronizing with network.

---

## Probl√®me: Effect initialise l'application

Some logic should only run once when the app loads.

You might be tempted to place it in an Effect in the top-level component:

```js {2-6}
function App() {
  // üî¥ Avoid: Effects with logic that should only ever run once
  useEffect(() => {
    loadDataFromLocalStorage();
    checkAuthToken();
  }, []);
  // ...
}
```

However, you'll quickly discover that it [runs twice in development.](/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development) This can cause issues--for example, maybe it invalidates the authentication token because the function wasn't designed to be called twice. In general, your components should be resilient to being remounted. This includes your top-level `App` component.

---

## Solution 1: utiliser drapeau pour n'ex√©cuter qu'une fois

Although it may not ever get remounted in practice in production, following the same constraints in all components makes it easier to move and reuse code. If some logic must run _once per app load_ rather than _once per component mount_, add a top-level variable to track whether it has already executed:

```js {1,5-6,10}
let didInit = false;

function App() {
  useEffect(() => {
    if (!didInit) {
      didInit = true;
      // ‚úÖ Only runs once per app load
      loadDataFromLocalStorage();
      checkAuthToken();
    }
  }, []);
  // ...
}
```

---

## Solution 2: ex√©cuter le code √† l'initialisation du module

You can also run it during module initialization and before the app renders:

```js {1,5}
if (typeof window !== 'undefined') {
  // Check if we're running in the browser.
  // ‚úÖ Only runs once per app load
  checkAuthToken();
  loadDataFromLocalStorage();
}

function App() {
  // ...
}
```

Code at the top level runs once when your component is imported--even if it doesn't end up being rendered. To avoid slowdown or surprising behavior when importing arbitrary components, don't overuse this pattern. Keep app-wide initialization logic to root component modules like `App.js` or in your application's entry point.

---

## Probl√®me: Efect notifie le parent d'un changement d'√©tat

Let's say you're writing a `Toggle` component with an internal `isOn` state which can be either `true` or `false`. There are a few different ways to toggle it (by clicking or dragging). You want to notify the parent component whenever the `Toggle` internal state changes, so you expose an `onChange` event and call it from an Effect:

```js {4-7}
function Toggle({ onChange }) {
  const [isOn, setIsOn] = useState(false);

  // üî¥ Avoid: The onChange handler runs too late
  useEffect(() => {
    onChange(isOn);
  }, [isOn, onChange]);

  function handleClick() {
    setIsOn(!isOn);
  }

  function handleDragEnd(e) {
    if (isCloserToRightEdge(e)) {
      setIsOn(true);
    } else {
      setIsOn(false);
    }
  }

  // ...
}
```

Like earlier, this is not ideal. The `Toggle` updates its state first, and React updates the screen. Then React runs the Effect, which calls the `onChange` function passed from a parent component. Now the parent component will update its own state, starting another render pass. It would be better to do everything in a single pass.

---

## Solution 1: D√©placer la notification dans l'√©v√©nement

Delete the Effect and instead update the state of _both_ components within the same event handler:

```js {5-7,11,16,18}
function Toggle({ onChange }) {
  const [isOn, setIsOn] = useState(false);

  function updateToggle(nextIsOn) {
    // ‚úÖ Good: Perform all updates during the event that caused them
    setIsOn(nextIsOn);
    onChange(nextIsOn);
  }

  function handleClick() {
    updateToggle(!isOn);
  }

  function handleDragEnd(e) {
    if (isCloserToRightEdge(e)) {
      updateToggle(true);
    } else {
      updateToggle(false);
    }
  }

  // ...
}
```

With this approach, both the `Toggle` component and its parent component update their state during the event. React [batches updates](/learn/queueing-a-series-of-state-updates) from different components together, so there will only be one render pass.

## Solution 2: Remonter l'√©tat local au composant parent

You might also be able to remove the state altogether, and instead receive `isOn` from the parent component:

```js {1,2}
// ‚úÖ Also good: the component is fully controlled by its parent
function Toggle({ isOn, onChange }) {
  function handleClick() {
    onChange(!isOn);
  }

  function handleDragEnd(e) {
    if (isCloserToRightEdge(e)) {
      onChange(true);
    } else {
      onChange(false);
    }
  }

  // ...
}
```

["Lifting state up"](/learn/sharing-state-between-components) lets the parent component fully control the `Toggle` by toggling the parent's own state. This means the parent component will have to contain more logic, but there will be less state overall to worry about. Whenever you try to keep two different state variables synchronized, try lifting state up instead!

---

## Probl√®me: Effect obtient des donn√©es qui sont pass√©es au parent

This `Child` component fetches some data and then passes it to the `Parent` component in an Effect:

```js {9-14}
function Parent() {
  const [data, setData] = useState(null);
  // ...
  return <Child onFetched={setData} />;
}

function Child({ onFetched }) {
  const data = useSomeAPI();
  // üî¥ Avoid: Passing data to the parent in an Effect
  useEffect(() => {
    if (data) {
      onFetched(data);
    }
  }, [onFetched, data]);
  // ...
}
```

---

## Solution: Remonter le fetch au parent

In React, data flows from the parent components to their children. When you see something wrong on the screen, you can trace where the information comes from by going up the component chain until you find which component passes the wrong prop or has the wrong state. When child components update the state of their parent components in Effects, the data flow becomes very difficult to trace. Since both the child and the parent need the same data, let the parent component fetch that data, and _pass it down_ to the child instead:

```js {4-5}
function Parent() {
  const data = useSomeAPI();
  // ...
  // ‚úÖ Good: Passing data down to the child
  return <Child data={data} />;
}

function Child({ data }) {
  // ...
}
```

This is simpler and keeps the data flow predictable: the data flows down from the parent to the child.

---

## Probl√®me: Effect s'abonne √† un service externe c√¥t√© client

Sometimes, your components may need to subscribe to some data outside of the React state. This data could be from a third-party library or a built-in browser API. Since this data can change without React's knowledge, you need to manually subscribe your components to it. This is often done with an Effect, for example:

```js {2-17}
function useOnlineStatus() {
  // Not ideal: Manual store subscription in an Effect
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function updateState() {
      setIsOnline(navigator.onLine);
    }

    updateState();

    window.addEventListener('online', updateState);
    window.addEventListener('offline', updateState);
    return () => {
      window.removeEventListener('online', updateState);
      window.removeEventListener('offline', updateState);
    };
  }, []);
  return isOnline;
}

function ChatIndicator() {
  const isOnline = useOnlineStatus();
  // ...
}
```

Here, the component subscribes to an external data store (in this case, the browser `navigator.onLine` API). Since this API does not exist on the server (so it can't be used for the initial HTML), initially the state is set to `true`. Whenever the value of that data store changes in the browser, the component updates its state.

## Solution: utiliser useSyncExternalStore

Although it's common to use Effects for this, React has a purpose-built Hook for subscribing to an external store that is preferred instead. Delete the Effect and replace it with a call to [`useSyncExternalStore`](/reference/react/useSyncExternalStore):

```js {11-16}
function subscribe(callback) {
  window.addEventListener('online', callback);
  window.addEventListener('offline', callback);
  return () => {
    window.removeEventListener('online', callback);
    window.removeEventListener('offline', callback);
  };
}

function useOnlineStatus() {
  // ‚úÖ Good: Subscribing to an external store with a built-in Hook
  return useSyncExternalStore(
    subscribe, // React won't resubscribe for as long as you pass the same function
    () => navigator.onLine, // How to get the value on the client
    () => true // How to get the value on the server
  );
}

function ChatIndicator() {
  const isOnline = useOnlineStatus();
  // ...
}
```

This approach is less error-prone than manually syncing mutable data to React state with an Effect. Typically, you'll write a custom Hook like `useOnlineStatus()` above so that you don't need to repeat this code in the individual components. [Read more about subscribing to external stores from React components.](/reference/react/useSyncExternalStore)

---

## Probl√®me: Effect fait un fectch sans logique de Cleanup

Many apps use Effects to kick off data fetching. It is quite common to write a data fetching Effect like this:

```js {5-10}
function SearchResults({ query }) {
  const [results, setResults] = useState([]);
  const [page, setPage] = useState(1);

  useEffect(() => {
    // üî¥ Avoid: Fetching without cleanup logic
    fetchResults(query, page).then((json) => {
      setResults(json);
    });
  }, [query, page]);

  function handleNextPageClick() {
    setPage(page + 1);
  }
  // ...
}
```

You _don't_ need to move this fetch to an event handler.

This might seem like a contradiction with the earlier examples where you needed to put the logic into the event handlers! However, consider that it's not _the typing event_ that's the main reason to fetch. Search inputs are often prepopulated from the URL, and the user might navigate Back and Forward without touching the input.

It doesn't matter where `page` and `query` come from. While this component is visible, you want to keep `results` [synchronized](/learn/synchronizing-with-effects) with data from the network for the current `page` and `query`. This is why it's an Effect.

However, the code above has a bug. Imagine you type `"hello"` fast. Then the `query` will change from `"h"`, to `"he"`, `"hel"`, `"hell"`, and `"hello"`. This will kick off separate fetches, but there is no guarantee about which order the responses will arrive in. For example, the `"hell"` response may arrive _after_ the `"hello"` response. Since it will call `setResults()` last, you will be displaying the wrong search results. This is called a ["race condition"](https://en.wikipedia.org/wiki/Race_condition): two different requests "raced" against each other and came in a different order than you expected.

---

## Solution 1: ne pas oublier le cleanup avec Fectch

**To fix the race condition, you need to [add a cleanup function](/learn/synchronizing-with-effects#fetching-data) to ignore stale responses:**

```js {5,7,9,11-13}
function SearchResults({ query }) {
  const [results, setResults] = useState([]);
  const [page, setPage] = useState(1);
  useEffect(() => {
    let ignore = false;
    fetchResults(query, page).then((json) => {
      if (!ignore) {
        setResults(json);
      }
    });
    return () => {
      ignore = true;
    };
  }, [query, page]);

  function handleNextPageClick() {
    setPage(page + 1);
  }
  // ...
}
```

This ensures that when your Effect fetches data, all responses except the last requested one will be ignored.

Handling race conditions is not the only difficulty with implementing data fetching. You might also want to think about caching responses (so that the user can click Back and see the previous screen instantly), how to fetch data on the server (so that the initial server-rendered HTML contains the fetched content instead of a spinner), and how to avoid network waterfalls (so that a child can fetch data without waiting for every parent).

---

## Solution 2: Utiliser un Framework pour obtenir donn√©es

**These issues apply to any UI library, not just React. Solving them is not trivial, which is why modern [frameworks](/learn/start-a-new-react-project#production-grade-react-frameworks) provide more efficient built-in data fetching mechanisms than fetching data in Effects.**

---

## Solution 3: Utiliser un Hook personnalis√©

If you don't use a framework (and don't want to build your own) but would like to make data fetching from Effects more ergonomic, consider extracting your fetching logic into a custom Hook like in this example:

```js {4}
function SearchResults({ query }) {
  const [page, setPage] = useState(1);
  const params = new URLSearchParams({ query, page });
  const results = useData(`/api/search?${params}`);

  function handleNextPageClick() {
    setPage(page + 1);
  }
  // ...
}

function useData(url) {
  const [data, setData] = useState(null);
  useEffect(() => {
    let ignore = false;
    fetch(url)
      .then((response) => response.json())
      .then((json) => {
        if (!ignore) {
          setData(json);
        }
      });
    return () => {
      ignore = true;
    };
  }, [url]);
  return data;
}
```

You'll likely also want to add some logic for error handling and to track whether the content is loading. You can build a Hook like this yourself or use one of the many solutions already available in the React ecosystem. **Although this alone won't be as efficient as using a framework's built-in data fetching mechanism, moving the data fetching logic into a custom Hook will make it easier to adopt an efficient data fetching strategy later.**

In general, whenever you have to resort to writing Effects, keep an eye out for when you can extract a piece of functionality into a custom Hook with a more declarative and purpose-built API like `useData` above. The fewer raw `useEffect` calls you have in your components, the easier you will find to maintain your application.

---

## R√©sum√©

- If you can calculate something during render, you don't need an Effect.
- To cache expensive calculations, add `useMemo` instead of `useEffect`.
- To reset the state of an entire component tree, pass a different `key` to it.
- To reset a particular bit of state in response to a prop change, set it during rendering.
- Code that runs because a component was _displayed_ should be in Effects, the rest should be in events.
- If you need to update the state of several components, it's better to do it during a single event.
- Whenever you try to synchronize state variables in different components, consider lifting state up.
- You can fetch data with Effects, but you need to implement cleanup to avoid race conditions.

---

## D√©fi 4.1

#### Transformer donn√©es sans Effect

Peut-on √©liminer l'Effect ici?

<Sandpack>

```js
import { useState, useEffect } from 'react';
import { initialTodos, createTodo } from './todos.js';

export default function TodoList() {
  const [todos, setTodos] = useState(initialTodos);
  const [showActive, setShowActive] = useState(false);
  const [activeTodos, setActiveTodos] = useState([]);
  const [visibleTodos, setVisibleTodos] = useState([]);
  const [footer, setFooter] = useState(null);

  useEffect(() => {
    setActiveTodos(todos.filter((todo) => !todo.completed));
  }, [todos]);

  useEffect(() => {
    setVisibleTodos(showActive ? activeTodos : todos);
  }, [showActive, todos, activeTodos]);

  useEffect(() => {
    setFooter(<footer>{activeTodos.length} todos left</footer>);
  }, [activeTodos]);

  return (
    <>
      <label>
        <input
          type='checkbox'
          checked={showActive}
          onChange={(e) => setShowActive(e.target.checked)}
        />
        Show only active todos
      </label>
      <NewTodo onAdd={(newTodo) => setTodos([...todos, newTodo])} />
      <ul>
        {visibleTodos.map((todo) => (
          <li key={todo.id}>
            {todo.completed ? <s>{todo.text}</s> : todo.text}
          </li>
        ))}
      </ul>
      {footer}
    </>
  );
}

function NewTodo({ onAdd }) {
  const [text, setText] = useState('');

  function handleAddClick() {
    setText('');
    onAdd(createTodo(text));
  }

  return (
    <>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={handleAddClick}>Add</button>
    </>
  );
}
```

```js src/todos.js
let nextId = 0;

export function createTodo(text, completed = false) {
  return {
    id: nextId++,
    text,
    completed,
  };
}

export const initialTodos = [
  createTodo('Get apples', true),
  createTodo('Get oranges', true),
  createTodo('Get carrots'),
];
```

```css
label {
  display: block;
}
input {
  margin-top: 10px;
}
```

</Sandpack>

<Hint>

On peut utiliser un calcul pour √©liminer de l'√âtat et des Effects

</Hint>

---

## D√©fi 4.2

#### Cacher un calcul sans Effect

Filtrer appelle `getVisibleTodos()`.

Il faut √©liminer l'Effect. Assurez-vous que `getVisibleTodos()` ne roule pas inutilement quand on tape dans la saisie.

<Hint>

Une solution serait d'utiliser `useMemo()`. Une autre solution serait d'isoler la saisie (et son √©tat) dans un composant `NewTodo`

</Hint>

<Sandpack>

```js
import { useState, useEffect } from 'react';
import { initialTodos, createTodo, getVisibleTodos } from './todos.js';

export default function TodoList() {
  const [todos, setTodos] = useState(initialTodos);
  const [showActive, setShowActive] = useState(false);
  const [text, setText] = useState('');
  const [visibleTodos, setVisibleTodos] = useState([]);

  useEffect(() => {
    setVisibleTodos(getVisibleTodos(todos, showActive));
  }, [todos, showActive]);

  function handleAddClick() {
    setText('');
    setTodos([...todos, createTodo(text)]);
  }

  return (
    <>
      <label>
        <input
          type='checkbox'
          checked={showActive}
          onChange={(e) => setShowActive(e.target.checked)}
        />
        Show only active todos
      </label>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={handleAddClick}>Add</button>
      <ul>
        {visibleTodos.map((todo) => (
          <li key={todo.id}>
            {todo.completed ? <s>{todo.text}</s> : todo.text}
          </li>
        ))}
      </ul>
    </>
  );
}
```

```js src/todos.js
let nextId = 0;
let calls = 0;

export function getVisibleTodos(todos, showActive) {
  console.log(`getVisibleTodos() was called ${++calls} times`);
  const activeTodos = todos.filter((todo) => !todo.completed);
  const visibleTodos = showActive ? activeTodos : todos;
  return visibleTodos;
}

export function createTodo(text, completed = false) {
  return {
    id: nextId++,
    text,
    completed,
  };
}

export const initialTodos = [
  createTodo('Get apples', true),
  createTodo('Get oranges', true),
  createTodo('Get carrots'),
];
```

```css
label {
  display: block;
}
input {
  margin-top: 10px;
}
```

</Sandpack>

---

## D√©fi 4.3

#### R√©initialiser √† z√©ro sans Effect

Le composant `EditContact` re√ßoit un objet `{ id, name, email }` par la prop `savedContact`.

Pourrait-on enlever l'Effect?

<Sandpack>

```js src/App.js hidden
import { useState } from 'react';
import ContactList from './ContactList.js';
import EditContact from './EditContact.js';

export default function ContactManager() {
  const [contacts, setContacts] = useState(initialContacts);
  const [selectedId, setSelectedId] = useState(0);
  const selectedContact = contacts.find((c) => c.id === selectedId);

  function handleSave(updatedData) {
    const nextContacts = contacts.map((c) => {
      if (c.id === updatedData.id) {
        return updatedData;
      } else {
        return c;
      }
    });
    setContacts(nextContacts);
  }

  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedId={selectedId}
        onSelect={(id) => setSelectedId(id)}
      />
      <hr />
      <EditContact savedContact={selectedContact} onSave={handleSave} />
    </div>
  );
}

const initialContacts = [
  { id: 0, name: 'Taylor', email: 'taylor@mail.com' },
  { id: 1, name: 'Alice', email: 'alice@mail.com' },
  { id: 2, name: 'Bob', email: 'bob@mail.com' },
];
```

```js src/ContactList.js hidden
export default function ContactList({ contacts, selectedId, onSelect }) {
  return (
    <section>
      <ul>
        {contacts.map((contact) => (
          <li key={contact.id}>
            <button
              onClick={() => {
                onSelect(contact.id);
              }}
            >
              {contact.id === selectedId ? <b>{contact.name}</b> : contact.name}
            </button>
          </li>
        ))}
      </ul>
    </section>
  );
}
```

```js src/EditContact.js active
import { useState, useEffect } from 'react';

export default function EditContact({ savedContact, onSave }) {
  const [name, setName] = useState(savedContact.name);
  const [email, setEmail] = useState(savedContact.email);

  useEffect(() => {
    setName(savedContact.name);
    setEmail(savedContact.email);
  }, [savedContact]);

  return (
    <section>
      <label>
        Name:{' '}
        <input
          type='text'
          value={name}
          onChange={(e) => setName(e.target.value)}
        />
      </label>
      <label>
        Email:{' '}
        <input
          type='email'
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
      </label>
      <button
        onClick={() => {
          const updatedData = {
            id: savedContact.id,
            name: name,
            email: email,
          };
          onSave(updatedData);
        }}
      >
        Save
      </button>
      <button
        onClick={() => {
          setName(savedContact.name);
          setEmail(savedContact.email);
        }}
      >
        Reset
      </button>
    </section>
  );
}
```

```css
ul,
li {
  list-style: none;
  margin: 0;
  padding: 0;
}
li {
  display: inline-block;
}
li button {
  padding: 10px;
}
label {
  display: block;
  margin: 10px 0;
}
button {
  margin-right: 10px;
  margin-bottom: 10px;
}
```

</Sandpack>

<Hint>

Utiliser un attribut `key`

</Hint>

---

## D√©fi 4.4

#### Envoyer un fomulaire sans Effect

Voici un formulaire de clavardage. L'affichage bascule entre un formulaire, et un bouton "open chat".
On demande que le formulaire soit cach√© au d√©part. Mais si on initialise `showForm` √† false plut√¥t que true, le message "thank you" apparait par d√©faut. Ce n'est pas d√©sirable.

Initialisez `showForm` √† false, r√©parez le code et √©liminez l'Effect

<Hint>

Le message est envoy√© parce que "thank you" est affich√©? Ou c'est l'inverse?

</Hint>

<Sandpack>

```js
import { useState, useEffect } from 'react';

export default function Form() {
  const [showForm, setShowForm] = useState(true);
  const [message, setMessage] = useState('');

  useEffect(() => {
    if (!showForm) {
      sendMessage(message);
    }
  }, [showForm, message]);

  function handleSubmit(e) {
    e.preventDefault();
    setShowForm(false);
  }

  if (!showForm) {
    return (
      <>
        <h1>Thanks for using our services!</h1>
        <button
          onClick={() => {
            setMessage('');
            setShowForm(true);
          }}
        >
          Open chat
        </button>
      </>
    );
  }

  return (
    <form onSubmit={handleSubmit}>
      <textarea
        placeholder='Message'
        value={message}
        onChange={(e) => setMessage(e.target.value)}
      />
      <button type='submit' disabled={message === ''}>
        Send
      </button>
    </form>
  );
}

function sendMessage(message) {
  console.log('Sending message: ' + message);
}
```

```css
label,
textarea {
  margin-bottom: 10px;
  display: block;
}
```

</Sandpack>
