## Pourquoi un effet

- Certains composants doivent se synchroniser avec des syst√®mes externes
- Voici quelques exemples:
  - Contr√¥ler un composant non-React, bas√© sur un √©tat React
  - Ouvrir une connexion au server
  - Envoyer de la t√©l√©m√©trie quand un composant affiche √† l'√©cran
- Un effet permet de rouler du code apr√®s le rendu et commit.

---

## Les 2 types de code

Le code d'un composant est soit:

- **Code de rendu** (rendering code)
  - Situ√© au top niveau du composant.
  - On prend l'√©tat et les props, on les transforme, et on retourne du JSX
  - Le code doit demeurer pur
  - Ce code "calcule" le r√©sultat, sans effet de bord, comme une formule math√©matique

<hr />

- **Gestionnaires d'√©v√©nements** (Event handler)
  - Ce sont des fonctions imbriqu√©es dans le composant
  - Font des choses plut√¥t que simplement calculer
  - Ex: Modifier un champ de saisie, soumettre un POST HTTP, naviguer vers un autre √©cran.
  - Peut modifier l'√©tat avec setState, provoquant un nouveau rendu

---

## Effect

Que faire s'il y a un effet de bord, mais qu'il n'y a pas d'√©v√©nement sp√©cifique associ√©?

- Un _Effect_ permet de coder des effets de bord suite √† un rendu
- Un _Effect_ roule suite √† la phase "commit", suite √† l'affichage des modifications du DOM

**On n'a pas toujours besoin d'un _Effect_**

- C'est utile pour se synchroniser avec un syst√®me externe
- Mais c'est trop si c'est pour modifier le state en fonction d'un autre state

**Note:** On utilisera _Effect_ pour parler de la fonctionnalit√© offerte par `useEffect`.

---

## √âcrire un Effect

1. **D√©clarer un Effect** Par d√©faut, un _Effect_ ex√©cute apr√®s chaque rendu
2. **Sp√©cifier les d√©pendances** Les _Effects_ ne devraient r√©-ex√©cuter qu'au besoin, plut√¥t qu'apr√®s chaque rendu
3. **Ajouter une fonction de cleanup, au besoin** Certains _Effects_ doivent indiquer comment arr√™ter ce qu'ils font. Ex: `connect` et `disconnect`, `subscribe` et `unsubscribe`, `fetch` et `cancel`

Regardons ces √©tapes en d√©tail :

---

### √âtape 1: Declarer un Effect

Pour d√©clarer un _Effect_, on utilise le `useEffect`

```js
import { useEffect } from 'react';
```

On appelle `useEffect` au "top niveau" du composant.

```js {2-4}
function MyComponent() {
  useEffect(() => {
    // Ce code ex√©cute apr√®s chaque rendu
  });
  return <div />;
}
```

Apr√®s chaque rendu, React met d'abord l'√©cran √† jour, et ensuite ex√©cute le code dans `useEffect`. On attend donc que le rendu soit affich√© √† l'√©cran pour ex√©cuter un _Effect_

---

## Exemple VideoPlayer

Imaginons le composant `<VideoPlayer>`, et une prop `isPlaying`, pour d√©marrer ou arr√™ter la vid√©o:

```js
<VideoPlayer isPlaying={isPlaying} />
```

`VideoPlayer` g√©n√®re la balise `<video>` au rendu :

```js
function VideoPlayer({ src, isPlaying }) {
  // TODO: Ajouter du code pour g√©rer isPlaying
  return <video src={src} />;
}
```

- `<video>` n'a pas de prop `isPlaying`
- Par contre, elle poss√®de des m√©thodes `play()` et `pause()`
- Il faut donc synchroniser `isPlaying` avec les appels `play()` et `pause()`
- Un `ref` permet de r√©f√©rer la balise `<video>` dans le DOM

---

## Ne pas r√©f√©rer au DOM pendant le rendu

On serait tent√© d'appeler `play()` ou `pause()` pendant le rendu, mais √ßa ne fonctionne pas:

<Sandpack >

```js
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  if (isPlaying) {
    ref.current.play(); // plante dans le rendu
  } else {
    ref.current.pause(); // plante dans le rendu
  }

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src='https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4'
      />
    </>
  );
}
```

```css
button {
  display: block;
  margin-bottom: 20px;
}
video {
  width: 250px;
}
```

</Sandpack>

---

## Explications de l'√©chec

- Il ne faut pas manipuler le DOM pendant le rendu
- Un composant React devrait √™tre pur, sans effets de bords
- Quand `VideoPlayer` est appel√© la premi√®re fois, son DOM n'existe pas encore
  - Pas d'√©l√©ment sur lequel appeler `play()` ou `pause()`

---

## La solution

D√©placer les effets de bords dans `useEffect`, (plut√¥t que les garder dans le rendu)

```js {6,12}
import { useEffect, useRef } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}
```

---

## Explications de la solution

- En pla√ßant les manipulation du DOM dans _Effect_, React affiche son r√©sultat avant que _l'Effect_ ne roule.
- Suite au rendu de `VideoPlayer`, une balise `<video>` est g√©n√©r√©e dans le DOM (√©tape Commit).
- Ensuite, _l'Effect_ est appel√©e, permettant l'appel de `play()` ou `pause()` sans erreur

---

## Exemple avec la solution

<Sandpack>

```js
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src='https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4'
      />
    </>
  );
}
```

```css
button {
  display: block;
  margin-bottom: 20px;
}
video {
  width: 250px;
}
```

</Sandpack>

---

## Synchroniser avec un syst√®me externe

- Ici, le "syst√®me externe" est le _Media API_ du navigateur.
- La m√™me approche pourrait √™tre utilis√©e pour g√©rer du code non-React (ex: plugin jQuery).
- Notons que l'exemple pr√©c√©dent est plus complexe si on veut g√©rer toutes les subtilit√©s
  - Ex: L'usager qui utilise les raccourcis navigateurs pour d√©marrer/arr√™ter la vid√©o

---

## Attention

- Par d√©faut, les _Effects_ roulent apr√®s chaque rendu.
- C'est facile de g√©n√©rer une boucle infinie accidentellement.

```js
const [count, setCount] = useState(0);
useEffect(() => {
  setCount(count + 1);
});
```

- Effect ex√©cute suite au rendu
- Modifier le state provoque un rendu

<hr />

- Si on veut modifier l'√©tat bas√© sur un autre √©tat, Effect n'est pas le bon endroit
- Effect existe pour synchroniser un composant √† un syst√®me externe

---

## √âtape 2: Sp√©cifier les d√©pendances

- Par d√©faut, Effect ex√©cute apr√®s chaque rendu
- C'est souvent ind√©sirable

  - C'est parfois lent, et c'est le genre d'impact qu'on veut minimiser. Par exemple, on ne voudrait pas provoquer une connexion au serveur de clavardage √† chaque lettre tap√©e.
  - D'autres fois, c'est de trop. Par exemple, on ne voudrait pas jouer une animation de transition √† chaque lettre tap√©e. (Seulement √† l'apparition originale du composant)

---

## Effect ex√©cute trop souvent

Voici un exemple avec `console.log()`. √Ä chaque lettre tap√©e, l'Effect r√©-ex√©cute.

<Sandpack s="60" >

```js
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      console.log('Calling video.play()');
      ref.current.play();
    } else {
      console.log('Calling video.pause()');
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [text, setText] = useState('');
  return (
    <>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src='https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4'
      />
    </>
  );
}
```

```css
input,
button {
  display: block;
  margin-bottom: 20px;
}
video {
  width: 250px;
}
```

</Sandpack>

---

## Sauter des Effects

On peut sauter des rendus en sp√©cifiant un tableau de _d√©pendances_ comme second argument √† `useEffect()`.

Ajoutons un tableau vide `[]`.

```js {3}
useEffect(() => {
  // ...
}, []);
```

---

## Effect ex√©cute une seule fois

esLint indique que `React Hook useEffect has a missing dependency: 'isPlaying'`:

<Sandpack>

```js
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      console.log('Calling video.play()');
      ref.current.play();
    } else {
      console.log('Calling video.pause()');
      ref.current.pause();
    }
  }, []); // This causes an error

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [text, setText] = useState('');
  return (
    <>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src='https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4'
      />
    </>
  );
}
```

```css
input,
button {
  display: block;
  margin-bottom: 20px;
}
video {
  width: 250px;
}
```

</Sandpack>

---

## Tableau de d√©pendances

Le code Effect d√©pend de la prop `isPlaying`, mais cette d√©pendance n'est pas d√©clar√©e explicitement. Il faut donc ajouter `isPlaying` au tableau de d√©pendances.

```js {2,7}
useEffect(() => {
  if (isPlaying) {
    // c'est utilis√© ici
    // ...
  } else {
    // ...
  }
}, [isPlaying]); // ...il faut le d√©clarer ici!
```

React sait maintenant qu'il doit sauter l'Effect quand `isPlaying` conserve la m√™me valeur que le rendu pr√©c√©dent. Maintenant, taper des lettres ne r√©-ex√©cute plus l'Effect, alors que "Play/Pause" r√©-ex√©cute l'Effect.

---

## Exemple r√©par√©

<Sandpack>

```js
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      console.log('Calling video.play()');
      ref.current.play();
    } else {
      console.log('Calling video.pause()');
      ref.current.pause();
    }
  }, [isPlaying]);

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [text, setText] = useState('');
  return (
    <>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src='https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4'
      />
    </>
  );
}
```

```css
input,
button {
  display: block;
  margin-bottom: 20px;
}
video {
  width: 250px;
}
```

</Sandpack>

---

## Explications

- Le tableau de d√©pendance peut contenir plusieurs d√©pendances
- React saute l'ex√©cution de l'effet quand _toutes_ les valeurs courantes sont √©quivalentes aux valeurs du rendu pr√©c√©dent.
- React utilise `Object.is()` pour comparer les valeurs.
- React ne d√©tecte donc pas les mutationss d'un tableau ou objet.
- L'outil de _Lint_ retourne une erreur quand le code d'Effect et les d√©pendances ne correspondent pas.

---

## Comportements du tableau de d√©pendances

```js {3,7,11}
useEffect(() => {
  // Ex√©cute apr√®s chaque rendu
});

useEffect(() => {
  // Ex√©cute uniquement au montage (apparition du composant)
}, []);

useEffect(() => {
  // Ex√©cute au montage ainsi quand a ou b changent depuis le rendu pr√©c√©dent
}, [a, b]);
```

---

## Pourquoi omettre _ref_ du tableau de d√©pendance

```js {9}
function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);
  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  }, [isPlaying]); //[isPlaying, ref] ??
```

- L'objet `ref` a une identit√© stable.
- React garanti que `useRef()` retourne toujours le m√™me objet.
- On pourrait ajouter `ref` au tableau de d√©pendance, mais cela n'affecte pas le comportement du composant
- Les fonctions `set` ou `setState` ont aussi un identit√© stable.
- Si le linter permet d'omettre une d√©pendance sans erreur, c'est correct de l'√©liminer du tableau.

---

### √âtape 3: Ajouter une fonction de cleanup, au besoin

Imaginons un composant `Chatroom` qui se connecte √† un serveur de clavardage. Il y a un API `createConnection()` qui retourne un objet avec les m√©thodes `connect()` et `disconnect()`. Comment ouvrir la connexion quand le composant est affich√© √† l'usager?

<TwoColumns >
```js
useEffect(() => {
  const connection = createConnection();
  connection.connect();
});
```

Ce code se (re)connecte apr√®s chaque re-rendu (c'est lent). Il faut ajouter un tableau de d√©pendance.

```js {4}
useEffect(() => {
  const connection = createConnection();
  connection.connect();
}, []);
```

Ce code ne roule qu'apr√®s le montage initial, quand le composant appara√Æt √† l'√©cran la premi√®re fois.

</TwoColumns>

---

## Exemple

<Sandpack>

```js
import { useEffect } from 'react';
import { createConnection } from './chat.js';

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}
```

```js src/chat.js
export function createConnection() {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log('‚úÖ Connecting...');
    },
    disconnect() {
      console.log('‚ùå Disconnected.');
    },
  };
}
```

```css
input {
  display: block;
  margin-bottom: 20px;
}
```

</Sandpack>

`Connecting...` appara√Æt deux fois car, en mode _dev_ avec `<StrictMode>`, le rendu roule deux fois, **incluant** les _Effects_.

---

## Probl√®me avec sc√©nario plus complexe

- Dans une application avec routage, on pourrait naviguer entre `ChatRoom` et d'autres routes.
- On navigue vers `ChatRoom`, cela monte (mount) le composant, et appelle le `connection.connect()`.
- Quand on navigue vers une autre route, cela d√©monte (unmount) le composant.
- Quand on re-navigue vers `ChatRoom`, cela monte le composant, appelant `connection.connect()` √† nouveau.
- Ceci cr√©√© une nouvelle connexion, mais la premi√®re connexion n'a jamais √©t√© d√©truite.
- √Ä mesure qu'on navigue, on accumule les connexions.

<hr />

- Ce bogue est subtil et difficile √† trouver.
- Mais en mode `<StrictMode>`, c'est plus facile: √ßa monte le composant deux fois successivement.
- Affichant `"‚úÖ Connecting..."` deux fois de suite, cela permet de saisir qu'on a oubli√© de fermer la connexion au d√©montage.

---

## Solution: Fonction de cleanup (nettoyage)

- Il faut cr√©er une fonction de cleanup (nettoyage) dans l'Effet, et la retourner

```js {4-6}
useEffect(() => {
  const connection = createConnection();
  connection.connect();
  return () => {
    connection.disconnect();
  };
}, []);
```

- React appelle la fonction _cleanup_ juste avant que le prochain Effect n'ex√©cute
- React appelle aussi _cleanup_ une derni√®re fois, avant que le composant ne soit d√©mont√© (au rendu o√π l'on retire celui-ci de l'affichage.)

---

## Exemple r√©par√©

<Sandpack>

```js
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    return () => connection.disconnect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}
```

```js src/chat.js
export function createConnection() {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log('‚úÖ Connecting...');
    },
    disconnect() {
      console.log('‚ùå Disconnected.');
    },
  };
}
```

```css
input {
  display: block;
  margin-bottom: 20px;
}
```

</Sandpack>

---

### R√©sultat

Les logs sont maintenant:

1. `"‚úÖ Connecting..."`
2. `"‚ùå Disconnected."`
3. `"‚úÖ Connecting..."`

- **C'est le comportement attendu en d√©veloppement.**
- Il y a une paire extra d'appels pour se connecter/d√©connecter.
- On pourrait d√©sactiver `<StrictMode>`, mais on recommande de le conserver.
- √áa aide √† trouver les bogues.
- **En production, `"‚úÖ Connecting..."` n'affiche qu'une fois.**

---

## Les diff√©rentes fa√ßons de traiter les effets appel√©s deux fois

- React remonte les composants en d√©veloppement pour aider √† trouver les bogues.
- La question n'est pas "comment ex√©cuter l'effet qu'une fois?"
- Mais plut√¥t **"comment coder l'Effect pour qu'il fonctionne avec le remontage?"**
- La r√©ponse, c'est de coder une fonction _Cleanup_
- Elle doit arr√™ter, annuler ou compenser ce que fait l'Effect
- Le but, c'est que l'on ne puisse pas distinguer entre:
  - ex√©cuter l'Effect une fois (en production)
  - ex√©cuter une s√©quence _Effect ‚Üí Cleanup ‚Üí Effect_ (en dev)

<hr />

- La plupart des Effects utilisent un des patrons suivants:

---

## Controller des widgets non-React

- Imaginons une composante non-React affichant une carte routi√®re, avec une m√©thode `setZoomLevel()`.
- Pour garder la carte synchronis√©e avec l'√©tat `zoomLevel`, il faut le code suivant:

```js
useEffect(() => {
  const map = mapRef.current;
  map.setZoomLevel(zoomLevel);
}, [zoomLevel]);
```

- Pas besoin de Cleanup
- Appeler `setZoomLevel` deux fois avec la m√™me valeur n'affecte pas le r√©sultat final.
- C'est possiblement l√©g√®rement plus lent, √† cause du second appel.
- Mais ce co√ªt n'affecte pas le mode production.

---

## Controller des widgets non-React

- Certains API ne permettent pas de les appeler deux fois de suite.
- Par exemple, la m√©thode `showModal` provenant de l'√©l√©ment `<dialog>`
- Elle lance une exception quand c'est appel√© deux fois.
- La m√©thode cleanup doit fermer la bo√Æte de dialogue.

```js {4}
useEffect(() => {
  const dialog = dialogRef.current;
  dialog.showModal();
  return () => dialog.close();
}, []);
```

- Ce comportement aura le m√™me effet final en dev qu'en production.

---

## S'abonner aux √©v√©nements

Si l'Effect s'abonne, alors le Cleanup se d√©sabonne:

```js {6}
useEffect(() => {
  function handleScroll(e) {
    console.log(window.scrollX, window.scrollY);
  }
  window.addEventListener('scroll', handleScroll);
  return () => window.removeEventListener('scroll', handleScroll);
}, []);
```

- On aura le m√™me nombre d'abonnement en dev qu'en production.

---

## Activer des animations

Si Effect d√©marre une animation, le cleanup ram√®ne les valeurs initiales

```js {4-6}
useEffect(() => {
  const node = ref.current;
  node.style.opacity = 1; // Trigger the animation
  return () => {
    node.style.opacity = 0; // Reset to the initial value
  };
}, []);
```

En d√©veloppement, l'opacit√© passe de `1` √† `0` √† `1`. C'est similaire √† le mettre √† `1` directement, comme on le fait en production.

Si on utilise une librairie en animation qui supporte le tweening, le cleanup doit ramener le `timeline` √† son √©tat initial.

---

### Obtenir des donn√©es (Fetching data)

- Si votre Effect utilise `fetch`, le cleanup doit soit [annuler le fetch](https://developer.mozilla.org/en-US/docs/Web/API/AbortController), soit ignorer le r√©sultat

```js {2,6,13-15}
useEffect(() => {
  let ignore = false;

  async function startFetching() {
    const json = await fetchTodos(userId);
    if (!ignore) {
      setTodos(json);
    }
  }

  startFetching();

  return () => {
    ignore = true;
  };
}, [userId]);
```

---

## G√©rer le fetch

- On peut nettoyer le fetch de 2 fa√ßons:
  - Annuler le fetch via le `abortController` du fetch
  - Simplememt ignorer la valeur retourn√©e par le fetch
- Quand `userId` passe de `'Alice'` √† `'Bob'`
  - Le cleanup assure que la r√©ponse `'Alice'` soit ignor√©e
  - M√™me si elle est re√ßue apr√®s `'Bob'`
- **En mode dev, il y aura deux fetch**, le r√©sultat de la premi√®re requ√™te sera ignor√©
- **En production, il n'y a qu'une seule requ√™te.**

Si la seconde requ√™te g√™ne en dev, on pourrait utiliser une solution tier parti:

```js
function TodoList() {
  const todos = useSomeDataLibrary(`/api/user/${userId}/todos`);
  // ...
```

---

## Probl√®mes du Fetch

Appeler fetch dans un Effect est une fa√ßon r√©pendue d'obtenir des donn√©es. Mais il y a des mauvais c√¥t√©s:

- **Effect ne roule pas sur le serveur.** Le serveur fait un rendu du html avec l'√©tat vide. Il faut attendre le chargement du js pour que le client appelle fetch.
- Les fetch dans diff√©rents Effect **peuvent entrainer une "cascade r√©seau"**. Le composant parent obtient des donn√©es, ce qui entraine un rendu des enfants, qui ont leur propre fetch, entrainant un rendu de leurs enfants, et ainsi de suite.
- **Pas de strat√©gie de preload ou de caching.** Chaque fois que l'on d√©monte et monte le composant, il faut faire un nouvel appel r√©seau.
- **Le code n'est pas √©l√©gant.** Il faut beaucoup de code pour √©crire le code correctement et ne pas souffrir de conditions de concurrence (_[race conditions.](https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect)_).

Ces mauvais c√¥t√©s ne sont pas sp√©cifiques √† React.

---

## Alternatives au Fetch

- Utilisez les fonctionnalit√©s int√©gr√©es √† votre Framework
  - Next, Remix, etc
- Utilisez une cache client
  - [React Query](https://tanstack.com/query/latest)
  - [useSWR](https://swr.vercel.app/)
  - [React Router](https://reactrouter.com/en/main/start/overview)

---

## Envoyer la t√©l√©m√©trie analytique

Ce code envoie des donn√©es analytiques √† chaque visite de la page:

```js
useEffect(() => {
  logVisit(url); // Sends a POST request
}, [url]);
```

- En mode dev, `logVisit` est envoy√© deux fois pour chaque visite
- On serait tent√© de pr√©venir ce d√©doublement de log
- L'√©quipe React recommande de ne pas perdre son temps
- En mode dev, un composant remonte chaque fois qu'on le sauvegarde
  - Comportement ind√©sirable
  - Envoie de l'information √† chaque modification plut√¥t qu'√† chaque visite
- En fait, ce code ne devrait **jamais** rouler en mode d√©veloppement
- En production, le log n'est appel√© qu'une fois

---

## D√©boguer la t√©l√©m√©trie analytique

- Pour d√©boguer les analytiques, on peut soit:
  - Tester en mode production
  - Enlever temporairement le `<StrictMode>`.
- Alternativement, pour √©viter d'utiliser `Effect`, on peut appeler les analytiques via:
  - l'√©v√©nement qui modifie le routage
  - l'√©v√©nement de l'API [Intersection Observer](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)

---

## Pas un Effect: Initialiser l'application

- Le code d'initialisation ne roule qu'une seule fois, au chargement ou d√©marrage de l'app
- Il suffit de mettre ce code √† l'ext√©rieur d'un composant, √† la racine d'un module.

```js {1-2}
// Ceci n'ex√©cute que du c√¥t√© client
if (typeof window !== 'undefined') {
  checkAuthToken();
  loadDataFromLocalStorage();
}

function App() {
  // ...
}
```

- Ce code ex√©cute apr√®s le chargement du module.

---

### Pas un effet: Achat d'un produit

- Parfois, il n'est pas possible d'annuler les cons√©quences d'ex√©cuter l'Effect deux fois
- Imaginons un Effect qui envoie un POST pour acheter un produit

```js {2-3}
useEffect(() => {
  // üî¥ Mauvais: cet Effect est appel√© deux fois en mode dev.
  fetch('/api/buy', { method: 'POST' });
}, []);
```

- On ne voudrait pas acheter le produit deux fois
- Que se passe-t-il si un usager navigue ailleurs et ensuite navigue pour revenir en arri√®re?
- On ne veut pas faire un achat avec le bouton "back", mais quand on clique le bouton "acheter"

---

## L'achat d'un produit doit √™tre plac√© dans un gestionnaire d'√©v√©nement

- L'achat ne doit pas √™tre caus√© par le rendu, mais par un usager cliquant le bouton "acheter".

```js {2-3}
function handleClick() {
  // ‚úÖ L'achat est plac√© dans un gestionnaire d'√©v√©nement
  fetch('/api/buy', { method: 'POST' });
}
```

- Si remonter le composant brise la logique de l'application, √ßa signifie que c'est un bogue.
- C'est pour cela que React remonte les composants en mode dev: √ßa aide √† trouver les bogues.

---

## Un exemple complet

Cet exemple utilise [`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout) pour afficher un log 3 secondes apr√®s l'ex√©cution de l'Effect. La fonction _cleanup_ annule le _timeout_.

<Sandpack>

```js
import { useState, useEffect } from 'react';

function Playground() {
  const [text, setText] = useState('a');

  useEffect(() => {
    function onTimeout() {
      console.log('‚è∞ ' + text);
    }

    console.log('üîµ Schedule "' + text + '" log');
    const timeoutId = setTimeout(onTimeout, 3000);

    return () => {
      console.log('üü° Cancel "' + text + '" log');
      clearTimeout(timeoutId);
    };
  }, [text]);

  return (
    <>
      <label>
        What to log:{' '}
        <input value={text} onChange={(e) => setText(e.target.value)} />
      </label>
      <h1>{text}</h1>
    </>
  );
}

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(!show)}>
        {show ? 'Unmount' : 'Mount'} the component
      </button>
      {show && <hr />}
      {show && <Playground />}
    </>
  );
}
```

</Sandpack>

---

## Explications

- Commentez (ou enlevez) le _cleanup_ de l'exemple de la diapo pr√©c√©dente.
- Que se passe-t-il?

<hr />

- Ce comportement est li√© aux Closures de JavaScript.

---

## Chaque rendu g√©n√®re des Effects

`useEffect` "attache" un comportement √† la suite du rendu.

```js
export default function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Welcome to {roomId}!</h1>;
}
```

---

## Rendu initial

L'utilisateur visite `<ChatRoom roomId="general" />`. Ce qui g√©n√®re:

```js
// JSX pour le premier rendu (roomId = "general")
return <h1>Welcome to general!</h1>;
```

L'Effect est imm√©diatement ex√©cut√© suite au rendu

```js
// Effect du premier rendu (roomId = "general")
() => {
  const connection = createConnection('general');
  connection.connect();
  return () => connection.disconnect();
},
  // D√©pendance du premier rendu (roomId = "general")
  ['general'];
```

Ceci nous connecte au chat `'general'`

---

## Second rendu avec les m√™mes d√©pendances

Au re-rendu de `<ChatRoom roomId="general" />`, le m√™me jsx est g√©n√©r√©.

```js
// JSX pour le second rendu (roomId = "general")
return <h1>Welcome to general!</h1>;
```

React r√©alise que le second rendu est le m√™me, et ne modifie pas le DOM.

```js
// Effect pour le 2e rendu (roomId = "general")
() => {
  const connection = createConnection('general');
  connection.connect();
  return () => connection.disconnect();
},
  // D√©pendances du 2e rendu (roomId = "general")
  ['general'];
```

- React compare le `['general']` du rendu pr√©c√©dent `['general']`
- **Puisque toutes les d√©pendances sont les m√™mes, React saute l'Effect.**

---

## 3e rendu avec d√©pendances diff√©rentes

Quand l'utilisateur visite `<ChatRoom roomId="travel" />`, le rendu est diff√©rent:

```js
// JSX pour le 3e rendu (roomId = "travel")
return <h1>Welcome to travel!</h1>;
```

React modfie alors le DOM de `"Welcome to general"` √† `"Welcome to travel"`.

<div style={{fontSize:'.9em'}}>
```js
// Effect pour le 3e rendu (roomId = "travel")
() => {
  const connection = createConnection('travel');
  connection.connect();
  return () => connection.disconnect();
},
  // D√©pendances du 3e rendu (roomId = "travel")
  ['travel'];
```
</div>

- `['travel']` est diff√©rent de `['general']`. L'Effect n'est pas saut√©
- **Le _Cleanup_ est appel√© juste avant l'ex√©cution de l'Effect** √áa d√©connecte `'general'`
- L'Effect ex√©cute et se connecte sur `'travel'`

---

## D√©montage (Unmount)

- Quand l'utilisateur navigue ailleurs
  - le composant `ChatRoom` d√©monte (unmounts) (car il n'est plus g√©n√©r√© au rendu)
  - Le dernier _Cleanup_ roule √† ce moment
- Si le dernier Effect, c'est celui du 3e rendu, appel√© avec `travel`
  - React appelle donc le _Cleanup_ associ√© √† ce 3e rendu, celui de `travel`
  - Ce qui d√©connecte `travel`

---

## Comportement en d√©veloppement

- Avec Strict Mode, React remonte les composants au premier rendu
- L'√©tat et le DOM sont pr√©serv√©s
- permet de d√©tecter les Effects qui ont besoin de cleanup
- permet de r√©v√®ler les conditions de concurrence (racing conditions)
- React remonte les composants chaque fois qu'on sauvegarde un fichier
- Strict mode ne fonctionne que dans le mode dev

---

## R√©sum√©

- Un Effect est similaire √† un √©v√©nement
- Plut√¥t que d'√™tre caus√© par une interaction, c'est appel√© suite √† un rendu
- Un Effect permet de synchroniser avec un syst√®me externe
- Par d√©faut, un Effect ex√©cute apr√®s chaque rendu
- Il est possible de sauter l'ex√©cution de l'Effect quand toutes les d√©pendances conservent leurs valeurs (du dernier rendu)
- Les d√©pendances sont d√©termin√©es par le contenu du code de l'Effect
- Le tableau de d√©pendance vide (`[]`) correspond au "montage" _(mount)_ du composant (au moment o√π il est ajout√© √† l'√©cran)
- En "Mode Strict", Les composants sont mont√©s deux fois (mais en mode dev seulement)
- √áa permet de tester pour des bogues et des effets de bord
- Si un Effect brise au remontage, il manque possiblement une fonction _cleanup_.
- Le cleanup roule avant l'√©x√©cution du prochain Effect
- Le cleanup roule aussi au moment du d√©montage (unmount)

---

## D√©fi 1

#### Focus sur le point d'insertion au montage

Le composant `<MyInput>` a besoin de d'avoir le focus du point d'insertion au moment de son apparition √† l'√©cran. Une implantation est en commentaires. R√©parez ce code, (Imaginez que l'attribut `autoFocus` n'existe pas.)

<Sandpack>

```js src/MyInput.js active
import { useEffect, useRef } from 'react';

export default function MyInput({ value, onChange }) {
  const ref = useRef(null);

  // TODO: ca ne fonctionne pas ici.
  // ref.current.focus()

  return <input ref={ref} value={value} onChange={onChange} />;
}
```

```js src/App.js hidden
import { useState } from 'react';
import MyInput from './MyInput.js';

export default function Form() {
  const [show, setShow] = useState(false);
  const [name, setName] = useState('Taylor');
  const [upper, setUpper] = useState(false);
  return (
    <>
      <button onClick={() => setShow((s) => !s)}>
        {show ? 'Hide' : 'Show'} form
      </button>
      <br />
      <hr />
      {show && (
        <>
          <label>
            Enter your name:
            <MyInput value={name} onChange={(e) => setName(e.target.value)} />
          </label>
          <label>
            <input
              type='checkbox'
              checked={upper}
              onChange={(e) => setUpper(e.target.checked)}
            />
            Make it uppercase
          </label>
          <p>
            Hello, <b>{upper ? name.toUpperCase() : name}</b>
          </p>
        </>
      )}
    </>
  );
}
```

```css
label {
  display: block;
  margin-top: 20px;
  margin-bottom: 20px;
}

body {
  min-height: 150px;
}
```

</Sandpack>

- Validez que le focus est bien bien plac√© quand on alterne "hide" et "show form"
- Validez que ca n'affecte que le montage initial. "Make it uppercase" ne ram√®ne pas le focus au champ de texte

---

## D√©fi 2

#### Focus sur le premier champ

s
Avec deux champs `<MyInput>`, le dernier composant gagne. Pour qu'un autre composant gagne le focus, on ajoute la prop `shouldFocus`. Le `focus()` doit √™tre appel√© quand `shouldFocus` est `true`

<Sandpack>

```js src/MyInput.js active
import { useEffect, useRef } from 'react';

export default function MyInput({ shouldFocus, value, onChange }) {
  const ref = useRef(null);

  // TODO: call focus() only if shouldFocus is true.
  useEffect(() => {
    ref.current.focus();
  }, []);

  return <input ref={ref} value={value} onChange={onChange} />;
}
```

```js src/App.js hidden
import { useState } from 'react';
import MyInput from './MyInput.js';

export default function Form() {
  const [show, setShow] = useState(false);
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');
  const [upper, setUpper] = useState(false);
  const name = firstName + ' ' + lastName;
  return (
    <>
      <button onClick={() => setShow((s) => !s)}>
        {show ? 'Hide' : 'Show'} form
      </button>
      <br />
      <hr />
      {show && (
        <>
          <label>
            Enter your first name:
            <MyInput
              value={firstName}
              onChange={(e) => setFirstName(e.target.value)}
              shouldFocus={true}
            />
          </label>
          <label>
            Enter your last name:
            <MyInput
              value={lastName}
              onChange={(e) => setLastName(e.target.value)}
              shouldFocus={false}
            />
          </label>
          <p>
            Hello, <b>{upper ? name.toUpperCase() : name}</b>
          </p>
        </>
      )}
    </>
  );
}
```

```css
label {
  display: block;
  margin-top: 20px;
  margin-bottom: 20px;
}

body {
  min-height: 150px;
}
```

</Sandpack>

<Hint>

Un `useEffect()` ne peut √™tre appel√© de fa√ßon conditionnelle. Mais le code de l'Effect peut inclure de la logique conditionnelle.

</Hint>

---

## D√©fi 3

#### R√©parer un intervalle qui est appel√© deux fois

Ce `Counter` affiche un compte incr√©ment√© √† chaque seconde. `setInterval` est appel√© pour initialiser un intervalle appelant `onTick` √† chaque seconde

Mais, l'intervalle incr√©mente deux fois. Trouvez la cause du bogue et r√©parez.

<Hint>

`setInterval()` retourne un ID, que l'on peut passer √† [`clearInterval()`](https://developer.mozilla.org/en-US/docs/Web/API/clearInterval) pour stopper l'intevalle.

</Hint>

<Sandpack>

```js src/Counter.js active
import { useState, useEffect } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    function onTick() {
      setCount((c) => c + 1);
    }

    setInterval(onTick, 1000);
  }, []);

  return <h1>{count}</h1>;
}
```

```js src/App.js hidden
import { useState } from 'react';
import Counter from './Counter.js';

export default function Form() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow((s) => !s)}>
        {show ? 'Hide' : 'Show'} counter
      </button>
      <br />
      <hr />
      {show && <Counter />}
    </>
  );
}
```

```css
label {
  display: block;
  margin-top: 20px;
  margin-bottom: 20px;
}

body {
  min-height: 150px;
}
```

</Sandpack>

---

## D√©fi 4

#### R√©parer le fetch dans l'Effect

Ce composant utilise une `Promise` pour aller chercher des bios associ√©s √† des personnes. Si on passe de `Alice` √† `Bob` √† `Taylor` rapidement, il est possible que ce soit la bio de Bob qui affiche plut√¥t que celle de Taylor. Il faut r√©parer.

<Sandpack>

```js src/App.js active
import { useState, useEffect } from 'react';
import { fetchBio } from './api.js';

export default function Page() {
  const [person, setPerson] = useState('Alice');
  const [bio, setBio] = useState(null);

  useEffect(() => {
    setBio(null);
    fetchBio(person).then((result) => {
      setBio(result);
    });
  }, [person]);

  return (
    <>
      <select
        value={person}
        onChange={(e) => {
          setPerson(e.target.value);
        }}
      >
        <option value='Alice'>Alice</option>
        <option value='Bob'>Bob</option>
        <option value='Taylor'>Taylor</option>
      </select>
      <hr />
      <p>
        <i>{bio ?? 'Loading...'}</i>
      </p>
    </>
  );
}
```

```js src/api.js hidden
export async function fetchBio(person) {
  const delay = person === 'Bob' ? 2000 : 200;
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve('This is ' + person + '‚Äôs bio.');
    }, delay);
  });
}
```

</Sandpack>

<Hint>

Quand un Effect charge de fa√ßon asynchrone, il faut ajouter un _cleanup_.

</Hint>
