---
title: État avancé
description: other
---

# État avancé

---

## Réagir aux saisies avec l'état

React utilise une approche **déclarative** pour manipuler l'interface.
Plutôt que de manipuler des pièces individuelles de l'interface, on
décrit les états du composant, et on bascule d'après les interaction
de l'usager.

---

## Approche impérative

Quand on conçoit des interactions, on pense à comment l'interface _change_ en réaction aux actions d'un usager. Considérez un fomulaire avec lequel l'usager envoie une réponse.

- Quand on tape dans le formulaire, le bouton "Envoyer" **devient actif.**
- Quand on presse "Envoyer", le bouton et le formulaire **sont désactivés** et un disque rotatif **apparaît.**
- Si la requête réseau complète avec succès, le formulaire **est chaché** et le message "Merci" **apparaît**.
- Si la requète réseau échoue, un message d'erreur **apparaît** et le formulaire est **réactivé**.

En **programmation impérative**, ces verbes correspondent à comment implanter l'interaction.
Il faut traduire ces verbes en instructions et séquences dans un langage de programmation.

---

## Exemple impératif

Ça se nomme programmation _impérative_ car il faut donner une "commande" pour chaque élément du résultat. Du plateau rotatif au bouton, il faut expliquer _comment_ modifier l'interface.

Voici un exemple de formulaire impératif **sans** React. Cela utilise le [DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model):

<Sandpack>

```js src/index.js active
async function handleFormSubmit(e) {
  e.preventDefault();
  disable(textarea);
  disable(button);
  show(loadingMessage);
  hide(errorMessage);
  try {
    await submitForm(textarea.value);
    show(successMessage);
    hide(form);
  } catch (err) {
    show(errorMessage);
    errorMessage.textContent = err.message;
  } finally {
    hide(loadingMessage);
    enable(textarea);
    enable(button);
  }
}

function handleTextareaChange() {
  if (textarea.value.length === 0) {
    disable(button);
  } else {
    enable(button);
  }
}

function hide(el) {
  el.style.display = 'none';
}

function show(el) {
  el.style.display = '';
}

function enable(el) {
  el.disabled = false;
}

function disable(el) {
  el.disabled = true;
}

function submitForm(answer) {
  // Faire semblant de communiquer avec le réseau
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (answer.toLowerCase() == 'ottawa') {
        resolve();
      } else {
        reject(
          new Error(
            "Bien essayé mais c'est la mauvaise réponse. Tentez à nouveau!"
          )
        );
      }
    }, 1500);
  });
}

let form = document.getElementById('form');
let textarea = document.getElementById('textarea');
let button = document.getElementById('button');
let loadingMessage = document.getElementById('loading');
let errorMessage = document.getElementById('error');
let successMessage = document.getElementById('success');
form.onsubmit = handleFormSubmit;
textarea.oninput = handleTextareaChange;
```

```js src/sandbox.config.json hidden
{
  "hardReloadOnChange": true
}
```

```html public/index.html
<form id="form">
  <h2>Quiz</h2>
  <p>Quelle est la capitale du Canada?</p>
  <textarea id="textarea"></textarea>
  <br />
  <button id="button" disabled>Envoyer</button>
  <p id="loading" style="display: none">Chargement...</p>
  <p id="error" style="display: none; color: red;"></p>
</form>
<h1 id="success" style="display: none">C'est exact!</h1>

<style>
  * {
    box-sizing: border-box;
  }
  body {
    font-family: sans-serif;
    margin: 20px;
    padding: 0;
  }
</style>
```

</Sandpack>

C'est beaucoup de manipulation de toucher à l'interface: désactiver, réactiver, afficher, cacher.

Ça fonctionne pour de petits exemples. Mais ça devient compliqué pour des plus gros.

---

## Approche Déclarative

C'est beaucoup de manipulation de toucher à l'interface. Désactiver, réactiver, afficher, cacher.

Ce qu'on fait en React, on **déclare ce que l'on veut montrer** et React détermine comment mettre à jour l'interface.

C'est comme entrer dans un taxi, donner la destination, et laisser le chauffeur (React) déterminer le meilleur chemin. Il est fort possible que le chauffeur connaisse des raccourcis.

---

## Penser déclarativment

Prenons l'exemple impératif et convertissons-le en React. Voici les étapes:

1. **Identifier** les différents états visuels du composant
2. **Déterminer** ce qui provoque ces changements
3. **Modéliser** l'état en mémoire avec `useState`
4. **Élminer** toute variable d'état non-nécessaire
5. **Connecter** les gestionnaires d'événements à l'état

---

## Étape 1: Identifier les différents états visuels du composant {/* step-1-identify-your-components-different-visual-states */}

En informatique, il existe le concept de ["state machine"](https://en.wikipedia.org/wiki/Finite-state_machine) qui sont dans un “état” particulier. En graphisme, il y a les maquettes des "visual states". React se situe entre ces deux mondes.

Visualisons les états de l'interface usager:

- **Vide**: Bouton "Envoyé" est désactivé.
- **Tape**: Bouton "Envoyé" est activé.
- **Envoyer**: On désactive le formulaire. Un icône d'attente est affiché
- **Succès**: "Merci" est affiché plutôt que le formulaire
- **Erreur**: Similaire à l'état tape, mais avec un message d'erreur visible

---

## Maquette des états (V1)

Comme un graphiste, on veut créer une maquette (mock) des états. Ici, on gère l'état via une prop `status` (initialement au mode vide)

<Sandpack>

```js
export default function Form({ status = 'vide' }) {
  if (status === 'succès') {
    return <h1>C'est exact!</h1>;
  }
  return (
    <>
      <h2>Quiz</h2>
      <p>Quelle est la capitale du Canada?</p>
      <form>
        <textarea />
        <br />
        <button>Envoyer</button>
      </form>
    </>
  );
}
```

</Sandpack>

On peut modifier la valeur de la prop (Essayez de modifier `status = 'vide'` en `status = 'succès'`)

---

## Exemple plus complet (v2)

<Sandpack>

```js
export default function Form({
  // Essayez 'vide', 'envoi', 'erreur', 'succès' :
  status = 'vide',
}) {
  if (status === 'succès') {
    return <h1>C'est exact!</h1>;
  }
  return (
    <>
      <h2>Quiz</h2>
      <p>Quelle est la capitale du Canada?</p>
      <form>
        <textarea disabled={status === 'envoi'} />
        <br />
        <button disabled={status === 'vide' || status === 'envoi'}>
          Envoyer
        </button>
        {status === 'erreur' && (
          <p className='Error'>
            Bien essayé mais c'est la mauvaise réponse. Tentez à nouveau!
          </p>
        )}
      </form>
    </>
  );
}
```

```css
.Error {
  color: red;
}
```

</Sandpack>

---

## Afficher de multiples états visuels

<Sandpack>

```js src/App.js active
import Form from './Form.js';

let statuses = ['vide', 'taper', 'envoi', 'succès', 'erreur'];

export default function App() {
  return (
    <>
      {statuses.map((status) => (
        <section key={status}>
          <h4>Formulaire ({status}):</h4>
          <Form status={status} />
        </section>
      ))}
    </>
  );
}
```

```js src/Form.js
export default function Form({ status }) {
  if (status === 'succès') {
    return <h1>C'est exact!</h1>;
  }
  return (
    <form>
      <textarea disabled={status === 'envoi'} />
      <br />
      <button disabled={status === 'vide' || status === 'envoi'}>Submit</button>
      {status === 'erreur' && (
        <p className='Error'>
          Bien essayé mais c'est la mauvaise réponse. Tentez à nouveau!
        </p>
      )}
    </form>
  );
}
```

```css
section {
  border-bottom: 1px solid #aaa;
  padding: 20px;
}
h4 {
  color: #222;
}
body {
  margin: 0;
}
.Error {
  color: red;
}
```

</Sandpack>

Ces pages sont nommées "guide de styles dynamiques" et _"storybooks"_.

---

## Étape 2: Déterminer ce qui provoque les changements d'états

On catégorise les déclancheurs en deux familles:

- **Événements utilisateurs** : cliquer un bouton, taper dans un champ, naviguer un lien.
- **Événements techniques** : réponse d'une requête réseau, un délai qui timeout, une image qui complète son chargeement.

Dans les deux cas, **il faut modifier des variables d'état (state) pour mettre à jour le IU.**

---

## Exemple de modification de State

- **Modifier le champ de saisie** (utilisateur) passe du mode _vide_ au mode _taper_ (ou vice-versa)
- **Cliquer le bouton envoyer** (utilisateur) passe au mode _Envoi_.
- **Succès de réponse réseau** (technique) passe au mode _Succès_.
- **Échec de réponse réseau** (technique) passe au mode _Erreur_ avec le message .

Pour visualiser ce flot, dessinez les états sur du papier comme des cercles nommés. Les flèches indiquent les changements possibles.

<Diagram name='responding_to_input_flow' width={688} height={350} />

---

### Étape 3: **Modéliser** l'état en mémoire avec `useState`

Représentez l'état visuel de votre composant avec `useState`. Gardez cela simple.

Débutez avec les états _absolument nécéssaires_. Par exemple, la réponse ou la dernière erreur:

```js
const [answer, setAnswer] = useState('');
const [error, setError] = useState(null);
```

Il faudra ajouter les variables qui représentent l'état visuel:

```js
const [isEmpty, setIsEmpty] = useState(true);
const [isTyping, setIsTyping] = useState(false);
const [isSubmitting, setIsSubmitting] = useState(false);
const [isSuccess, setIsSuccess] = useState(false);
const [isError, setIsError] = useState(false);
```

Il faudra réessayer quelques fois avant d'arriver à un "state" optimal.

---

### Étape 4 : Éliminer toute variable d'état non-nécessaire

Refactorisez l'état pour ne garder que l'essentiel.

Le but est d'empêcher les cas où l'état ne représente pas une IU valide pour l'utilisateur.

Par exemple, si on affiche un message d'erreur, il ne faut pas cacher la boîte de saisie qui provoque le message d'erreur. Il faut que l'utilisateur puisse corriger la saisie.

---

## Exemples de questions à propos de l'état

- **Un état provoque-il un paradoxe?** `isTyping` et `isSubmitting` ne peuvent simultanément être `true`. Un paradoxe indique que l'état manque de contraintes. Il y a 4 cominaisons de 2 booléens, mais seulement 3 états valides. Éliminez l'état "impossible", avec un `status` de 3 modes: `'tape'`, `'envoi'`, ou `'succès'`.
- **La même info est-elle disponble ailleurs dans l'état?** un autre paradoxe: `isEmpty` et `isTyping` ne peuvent être `true` simultanément. Enlevons `isEmpty` et validons plutôt `answer.length === 0`.
- **L'information serait-elle l'inverse d'un autre état?** `isError` n'est pas nécéssaire si on peut plutôt valider `error !== null`

Après le nettoyage, on passe de 7 à 3 variables d'états:

```js
const [answer, setAnswer] = useState('');
const [error, setError] = useState(null);
const [status, setStatus] = useState('taper'); // 'taper', 'envoi', ou 'succès'
```

Ils sont essentiels. On ne pourrait en retirer un sans briser la fonctionalité.

---

## Éliminez les états “impossibles” avec un reducteur

<div className='alert alert-warning px-5 py-4 text-body'>

Certains états intermédiaires ne font pas de sens.

Par exemple, un état `error` non-null n'est pas simultanément possible avec un `status` de `succès`.

Pour mieux modéliser l'état, on pourrait utiliser un **réducteur** (reducer).

Les réducteurs permettent d'unifier plusieurs variables d'état dans un seul objet. Ils consolident toute la logique de modification.

Nous verrons les réducteurs plus tard.

</div>

---

### Étape 5: Connecter les gestionnaires d'événements à l'état

Finalement, créez des gestionnaires d'événement qui modifient l'état.

<Sandpack>

```js
import { useState } from 'react';

export default function Form() {
  const [answer, setAnswer] = useState('');
  const [error, setError] = useState(null);
  const [status, setStatus] = useState('taper');

  if (status === 'succès') {
    return <h1>C'est exact!</h1>;
  }

  async function handleSubmit(e) {
    e.preventDefault();
    setStatus('envoi');
    try {
      await submitForm(answer);
      setStatus('succès');
    } catch (err) {
      setStatus('taper');
      setError(err);
    }
  }

  function handleTextareaChange(e) {
    setAnswer(e.target.value);
  }

  return (
    <>
      <h2>Quiz</h2>
      <p>Quelle est la capitale du Canada?</p>
      <form onSubmit={handleSubmit}>
        <textarea
          value={answer}
          onChange={handleTextareaChange}
          disabled={status === 'envoi'}
        />
        <br />
        <button disabled={answer.length === 0 || status === 'envoi'}>
          Envoyer
        </button>
        {error !== null && <p className='Error'>{error.message}</p>}
      </form>
    </>
  );
}

function submitForm(answer) {
  // Prétendre qu'il y a un accès réseau.
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      let shouldError = answer.toLowerCase() !== 'ottawa';
      if (shouldError) {
        reject(
          new Error(
            "Bien essayé mais c'est la mauvaise réponse. Tentez à nouveau!"
          )
        );
      } else {
        resolve();
      }
    }, 1500);
  });
}
```

```css
.Error {
  color: red;
}
```

</Sandpack>

Le code semble plus long, mais il est moins fragile que dans l'exemple original. Il est plus facile de modifier ou d'ajouter des états.

---

## Défi 1

#### Ajouter et enlever des classes css

Quand on clique sur l'image, on devrait enlever la classe `background--active` du `<div>` externe, et ajouter le `picture--active` du `<img>`. Cliquer sur le fond devrait restaurer le CSS originel.

Visuellement, cliquer sur l'image devrait enlever le fond mauve et encadrer l'image. Cliquer le fond l'inverse.

<Sandpack>

```js
export default function Picture() {
  return (
    <div className='background background--active'>
      <img
        className='picture'
        alt='Rainbow houses in Kampung Pelangi, Indonesia'
        src='https://i.imgur.com/5qwVYb1.jpeg'
      />
    </div>
  );
}
```

```css
body {
  margin: 0;
  padding: 0;
  height: 250px;
}

.background {
  width: 100vw;
  height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  background: #eee;
}

.background--active {
  background: #a6b5ff;
}

.picture {
  width: 200px;
  height: 200px;
  border-radius: 10px;
}

.picture--active {
  border: 5px solid #a6b5ff;
}
```

</Sandpack>

[Solution](https://fr.react.dev/learn/reacting-to-input-with-state#challenges)

---

## Défi 2a

#### Édition de Profile

Voici un formulaire écrite en JS et DOM. Jouez avec pour comprendre le fonctionnement.

<Sandpack>

```js src/index.js active
function handleFormSubmit(e) {
  e.preventDefault();
  if (editButton.textContent === 'Edit Profile') {
    editButton.textContent = 'Save Profile';
    hide(firstNameText);
    hide(lastNameText);
    show(firstNameInput);
    show(lastNameInput);
  } else {
    editButton.textContent = 'Edit Profile';
    hide(firstNameInput);
    hide(lastNameInput);
    show(firstNameText);
    show(lastNameText);
  }
}

function handleFirstNameChange() {
  firstNameText.textContent = firstNameInput.value;
  helloText.textContent =
    'Hello ' + firstNameInput.value + ' ' + lastNameInput.value + '!';
}

function handleLastNameChange() {
  lastNameText.textContent = lastNameInput.value;
  helloText.textContent =
    'Hello ' + firstNameInput.value + ' ' + lastNameInput.value + '!';
}

function hide(el) {
  el.style.display = 'none';
}

function show(el) {
  el.style.display = '';
}

let form = document.getElementById('form');
let editButton = document.getElementById('editButton');
let firstNameInput = document.getElementById('firstNameInput');
let firstNameText = document.getElementById('firstNameText');
let lastNameInput = document.getElementById('lastNameInput');
let lastNameText = document.getElementById('lastNameText');
let helloText = document.getElementById('helloText');
form.onsubmit = handleFormSubmit;
firstNameInput.oninput = handleFirstNameChange;
lastNameInput.oninput = handleLastNameChange;
```

```js src/sandbox.config.json hidden
{
  "hardReloadOnChange": true
}
```

```html public/index.html
<form id="form">
  <label>
    First name:
    <b id="firstNameText">Jane</b>
    <input id="firstNameInput" value="Jane" style="display: none" />
  </label>
  <label>
    Last name:
    <b id="lastNameText">Jacobs</b>
    <input id="lastNameInput" value="Jacobs" style="display: none" />
  </label>
  <button type="submit" id="editButton">Edit Profile</button>
  <p><i id="helloText">Hello, Jane Jacobs!</i></p>
</form>

<style>
  * {
    box-sizing: border-box;
  }
  body {
    font-family: sans-serif;
    margin: 20px;
    padding: 0;
  }
  label {
    display: block;
    margin-bottom: 20px;
  }
</style>
```

</Sandpack>

Le formulaire bascule entre deux modes: mode Édition, où l'on peut saisir, et le mode Visionnement, où l'on peut consulter les infos. Le bouton change en "Edit" et "Save", dépendant du mode. Le mesage de bienvenue (en bas) se met à jour avec la saisie.

---

## Défi 2b

Réécrivez le code en React. On a déjà converti le HTML en JSX.

Il faut émuler tous les autres comportements.

<Sandpack>

```js
export default function EditProfile() {
  return (
    <form>
      <label>
        First name: <b>Jane</b>
        <input />
      </label>
      <label>
        Last name: <b>Jacobs</b>
        <input />
      </label>
      <button type='submit'>Edit Profile</button>
      <p>
        <i>Hello, Jane Jacobs!</i>
      </p>
    </form>
  );
}
```

```css
label {
  display: block;
  margin-bottom: 20px;
}
```

</Sandpack>

---

## Défi 3a

#### Visionnez le code sans React

Voici le code sans React

<Sandpack>

```js src/index.js active
function handleFormSubmit(e) {
  e.preventDefault();
  if (editButton.textContent === 'Edit Profile') {
    editButton.textContent = 'Save Profile';
    hide(firstNameText);
    hide(lastNameText);
    show(firstNameInput);
    show(lastNameInput);
  } else {
    editButton.textContent = 'Edit Profile';
    hide(firstNameInput);
    hide(lastNameInput);
    show(firstNameText);
    show(lastNameText);
  }
}

function handleFirstNameChange() {
  firstNameText.textContent = firstNameInput.value;
  helloText.textContent =
    'Hello ' + firstNameInput.value + ' ' + lastNameInput.value + '!';
}

function handleLastNameChange() {
  lastNameText.textContent = lastNameInput.value;
  helloText.textContent =
    'Hello ' + firstNameInput.value + ' ' + lastNameInput.value + '!';
}

function hide(el) {
  el.style.display = 'none';
}

function show(el) {
  el.style.display = '';
}

let form = document.getElementById('form');
let editButton = document.getElementById('editButton');
let firstNameInput = document.getElementById('firstNameInput');
let firstNameText = document.getElementById('firstNameText');
let lastNameInput = document.getElementById('lastNameInput');
let lastNameText = document.getElementById('lastNameText');
let helloText = document.getElementById('helloText');
form.onsubmit = handleFormSubmit;
firstNameInput.oninput = handleFirstNameChange;
lastNameInput.oninput = handleLastNameChange;
```

```js src/sandbox.config.json hidden
{
  "hardReloadOnChange": true
}
```

```html public/index.html
<form id="form">
  <label>
    First name:
    <b id="firstNameText">Jane</b>
    <input id="firstNameInput" value="Jane" style="display: none" />
  </label>
  <label>
    Last name:
    <b id="lastNameText">Jacobs</b>
    <input id="lastNameInput" value="Jacobs" style="display: none" />
  </label>
  <button type="submit" id="editButton">Edit Profile</button>
  <p><i id="helloText">Hello, Jane Jacobs!</i></p>
</form>

<style>
  * {
    box-sizing: border-box;
  }
  body {
    font-family: sans-serif;
    margin: 20px;
    padding: 0;
  }
  label {
    display: block;
    margin-bottom: 20px;
  }
</style>
```

</Sandpack>

Modifiez sur la page suivante

---

## Défi 3b

Si React n'existait pas, pourrait-on réécrire le code pour que cela ressemble à l'approche de React?

Commencez par la méthode updateDOM

<Sandpack>

```js src/index.js active
let firstName = 'Jane';
let lastName = 'Jacobs';
let isEditing = false;

function handleFormSubmit(e) {
  e.preventDefault();
  setIsEditing(!isEditing);
}

function handleFirstNameChange(e) {
  setFirstName(e.target.value);
}

function handleLastNameChange(e) {
  setLastName(e.target.value);
}

function setFirstName(value) {
  firstName = value;
  updateDOM();
}

function setLastName(value) {
  lastName = value;
  updateDOM();
}

function setIsEditing(value) {
  isEditing = value;
  updateDOM();
}

function updateDOM() {
  if (isEditing) {
    editButton.textContent = 'Save Profile';
    // TODO: show inputs, hide content
  } else {
    editButton.textContent = 'Edit Profile';
    // TODO: hide inputs, show content
  }
  // TODO: update text labels
}

function hide(el) {
  el.style.display = 'none';
}

function show(el) {
  el.style.display = '';
}

let form = document.getElementById('form');
let editButton = document.getElementById('editButton');
let firstNameInput = document.getElementById('firstNameInput');
let firstNameText = document.getElementById('firstNameText');
let lastNameInput = document.getElementById('lastNameInput');
let lastNameText = document.getElementById('lastNameText');
let helloText = document.getElementById('helloText');
form.onsubmit = handleFormSubmit;
firstNameInput.oninput = handleFirstNameChange;
lastNameInput.oninput = handleLastNameChange;
```

```js src/sandbox.config.json hidden
{
  "hardReloadOnChange": true
}
```

```html public/index.html
<form id="form">
  <label>
    First name:
    <b id="firstNameText">Jane</b>
    <input id="firstNameInput" value="Jane" style="display: none" />
  </label>
  <label>
    Last name:
    <b id="lastNameText">Jacobs</b>
    <input id="lastNameInput" value="Jacobs" style="display: none" />
  </label>
  <button type="submit" id="editButton">Edit Profile</button>
  <p><i id="helloText">Hello, Jane Jacobs!</i></p>
</form>

<style>
  * {
    box-sizing: border-box;
  }
  body {
    font-family: sans-serif;
    margin: 20px;
    padding: 0;
  }
  label {
    display: block;
    margin-bottom: 20px;
  }
</style>
```

</Sandpack>

[Solution](https://fr.react.dev/learn/reacting-to-input-with-state#challenges)

---

## Bien structurer l'état

Bien structurer l'état, c'est la différence entre un composant qui est plaisant à modifier et déboguer, et un qui est la source de bogues.

Quelles sont les bonnes pratiques de gérer l'état?

---

## Principes pour structurer l'état

1. **Regrouper l'état commun.** Si on met à jour des variables d'état au même moment, fusionnez dans une seule variable d'état.
2. **Éliminez les contradictions.** Des états qui peuvent se contredire pourrait mener à des erreurs et bogues.
3. **Éliminez la redondance.** S'il est possible de calculer une valeur à partir de props ou de d'autres variables d'état, il n'est pas nécessaire de la stocker dans l'état.
4. **Éliminer la duplication.** Si la même valeur est dupliquée entre différentes variables d'état, ou des objets imbriqués, c'est alors difficile de les garder tous synchronisés.
5. **Éliminer les objets profondément imbriqués.** Un état profondément hierarchique n'est pas facile à mettre à jour. Privilégiez une structure plate ou peu profonde.

Le but, c'est de _faciliter les mises à jour d'état et d'éviter les erreurs_. Éliminer la redondance assure la cohérence de l'état. (De la même façon qu'on "normalise" une structure de Base de Données). On pourrait modifier la citation d'Albert Einstein: **"Faites que votre état soit le plus simple possible — mais pas plus simple."**

---

## Regrouper l'état commun

Deux approches possibles:

<TwoColumns>

<div>
Deux variables d'états:

```js
const [x, setX] = useState(0);
const [y, setY] = useState(0);
```

</div>
<div>

Une seule variable d'état:

```js
const [position, setPos] = useState({ x: 0, y: 0 });
//
```

</div>
</TwoColumns>

Les deux approches sont valables. Mais si des variables sont **toujours modifiées ensemble, on devrait les unifier dans une seule variable d'état.** Alors, on ne pourra pas oublier de les modifier ensemble.

---

## Exemple d'état unifié

<Sandpack>

```js
import { useState } from 'react';

export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0,
  });
  return (
    <div
      onPointerMove={(e) => {
        setPosition({
          x: e.clientX,
          y: e.clientY,
        });
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}
    >
      <div
        style={{
          position: 'absolute',
          backgroundColor: 'red',
          borderRadius: '50%',
          transform: `translate(${position.x}px, ${position.y}px)`,
          left: -10,
          top: -10,
          width: 20,
          height: 20,
        }}
      />
    </div>
  );
}
```

```css
body {
  margin: 0;
  padding: 0;
  height: 250px;
}
```

</Sandpack>

Un autre exemple d'unification: un tableau pour stocker différentes valeurs d'état. Idéal pour stocker les données d'un formulaire où l'utilisateur ajoute des champs de saisie personalisés.

---

## Attention aux objets dans l'état

Si la variable d'état est un objet, il faut cloner l'objet au complet.

On ne pourrait faire `setPosition({ x: 100 })`, car on perdrait alors la valeur de y.

Pour résoudre ce problème, il faut:

- Soit cloner les autres valeurs:

```js
setPosition({ ...position, x: 100 });
```

- Soit séparer en deux variables d'états:

```js
setX(100);
```

---

## Éliminez les contradictions

Voici un formulaire de la satisfaction d'un séjour. `isSending` et `isSent` sont les variables d'état:

<Sandpack>

```js
import { useState } from 'react';

export default function FeedbackForm() {
  const [text, setText] = useState('');
  const [isSending, setIsSending] = useState(false);
  const [isSent, setIsSent] = useState(false);

  async function handleSubmit(e) {
    e.preventDefault();
    setIsSending(true);
    await sendMessage(text);
    setIsSending(false);
    setIsSent(true);
  }

  if (isSent) {
    return <h1>Thanks for feedback!</h1>;
  }

  return (
    <form onSubmit={handleSubmit}>
      <p>How was your stay at The Prancing Pony?</p>
      <textarea
        disabled={isSending}
        value={text}
        onChange={(e) => setText(e.target.value)}
      />
      <br />
      <button disabled={isSending} type='submit'>
        Send
      </button>
      {isSending && <p>Sending...</p>}
    </form>
  );
}

// Pretend to send a message.
function sendMessage(text) {
  return new Promise((resolve) => {
    setTimeout(resolve, 2000);
  });
}
```

</Sandpack>

Ce code fonctionne. Mais il laisse la porte ouverte aux états impossibles: si on oublie d'appeler `setIsSent` et `setIsSending` ensemble, on pourrait se trouver dans un monde où `isSending` et `isSent` sont simultanément `true`.

Plus le composant est complexe, plus c'est difficile à prévenir.

---

## Refactoriser pour éliminer la contradiction

**Puisque `isSending` et `isSent` ne doivent jamais être simultanément à `true`, on devrait remplacer l'état par un `status` ayant l'un des 3 états valables** : `'typing'` (initial), `'sending'`, et `'sent'`:

<Sandpack>

```js
import { useState } from 'react';

export default function FeedbackForm() {
  const [text, setText] = useState('');
  const [status, setStatus] = useState('typing');

  async function handleSubmit(e) {
    e.preventDefault();
    setStatus('sending');
    await sendMessage(text);
    setStatus('sent');
  }

  const isSending = status === 'sending';
  const isSent = status === 'sent';

  if (isSent) {
    return <h1>Thanks for feedback!</h1>;
  }

  return (
    <form onSubmit={handleSubmit}>
      <p>How was your stay at The Prancing Pony?</p>
      <textarea
        disabled={isSending}
        value={text}
        onChange={(e) => setText(e.target.value)}
      />
      <br />
      <button disabled={isSending} type='submit'>
        Send
      </button>
      {isSending && <p>Sending...</p>}
    </form>
  );
}

// Pretend to send a message.
function sendMessage(text) {
  return new Promise((resolve) => {
    setTimeout(resolve, 2000);
  });
}
```

</Sandpack>

On peut déclarer des constantes pour aider la lecture:

<aside style={{display:'grid', gridTemplateColumns:"1fr 1fr", columnGap:10}}>

```jsx
const isSending = status === 'sending';
const isSent = status === 'sent';
```

Ce ne sont pas des variables d'état, nul besoin de craindre un état impossible.

</aside>

---

## Éliminer la redondance

S'il est possible de calculer une info à partir de props ou de l'état, cette info ne devrait **PAS** se trouver dans l'état.

Le formulaire suivant fonctionne bien, mais possède un état redondant.

<Sandpack>

```js
import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [fullName, setFullName] = useState('');

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
    setFullName(e.target.value + ' ' + lastName);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
    setFullName(firstName + ' ' + e.target.value);
  }

  return (
    <>
      <h2>Let’s check you in</h2>
      <label>
        First name: <input value={firstName} onChange={handleFirstNameChange} />
      </label>
      <label>
        Last name: <input value={lastName} onChange={handleLastNameChange} />
      </label>
      <p>
        Your ticket will be issued to: <b>{fullName}</b>
      </p>
    </>
  );
}
```

```css
label {
  display: block;
  margin-bottom: 5px;
}
```

</Sandpack>

Ce fomulaire a 3 variable d'états: `firstName`, `lastName`, et `fullName`. Mais `fullName` est redondant. **On peut obtenir `fullName` en combinant `firstName` et `lastName` pendant le rendu. Il faut l'éliminer de l'état.**

---

## Exemple avec la redondance éliminée

Le fomulaire précédent a 3 variable d'états: `firstName`, `lastName`, et `fullName`. Mais `fullName` est redondant. **On peut obtenir `fullName` en combinant `firstName` et `lastName` pendant le rendu.**

Il faut éliminer `fullName` de l'état.

<Sandpack>

```js
import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  const fullName = firstName + ' ' + lastName;

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
  }

  return (
    <>
      <h2>Let’s check you in</h2>
      <label>
        First name: <input value={firstName} onChange={handleFirstNameChange} />
      </label>
      <label>
        Last name: <input value={lastName} onChange={handleLastNameChange} />
      </label>
      <p>
        Your ticket will be issued to: <b>{fullName}</b>
      </p>
    </>
  );
}
```

```css
label {
  display: block;
  margin-bottom: 5px;
}
```

</Sandpack>

<aside style={{display:'grid', gridTemplateColumns:"10fr 9fr", columnGap:10}}>

```js
const fullName = firstName + ' ' + lastName;
```

`fullName` n'est plus une variable d'état. Maintenant, on recalcule la variable à chaque rendu:

 </aside>

---

## Ne pas recopier les props dans l'état

Un exemple d'état redondant:

```jsx
function Message({ messageColor }) {
  const [color, setColor] = useState(messageColor);
```

Ici, la variable d'état `color` est initialisé à la prop `messageColor`.

**Problème :**

Quand le parent pousse un `messageColor` différent (par exemple, de `'red'` à `'blue'`), l'état `color` n'est pas modifié!

L'état n'est initialisé qu'au premier rendu.

---

## Éliminier l'état provenant des props

Utilisez la prop plutôt que l'état.

On pourrait lui donner un nom plus court avec une constante:

```js
function Message({ messageColor }) {
  const color = messageColor;
```

De cette façon, la couleur sera toujours synchronisé à la valeur passée par le parent.

---

## Dupliquer une prop dans l'état pour une valeur initiale

Dupliquer une prop dans l'état, ça pourrait être utile quand il faut ignorer les mises à jour de ce prop. Par convention, on ajoute alors au prop le préfixe `initial` or `default`.

```js
function Message({ initialColor }) {
  // La variable d'état `color` contient la *première* valeur de `initialColor`.
  // Les changements apportés à la prop `initialColor` sont ignorés.
  const [color, setColor] = useState(initialColor);
  ...
}
```

---

## Évitez la duplication

Cette liste de menu permet de choisir un seul snack de cette collection.

<Sandpack>

```js
import { useState } from 'react';

const initialItems = [
  { title: 'pretzels', id: 0 },
  { title: 'crispy seaweed', id: 1 },
  { title: 'granola bar', id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedItem, setSelectedItem] = useState(items[0]);

  return (
    <>
      <h2>What's your travel snack?</h2>
      <ul>
        {items.map((item) => (
          <li key={item.id}>
            {item.title}{' '}
            <button
              onClick={() => {
                setSelectedItem(item);
              }}
            >
              Choose
            </button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}
```

```css
button {
  margin-top: 10px;
}
```

</Sandpack>

Présentement, on stocke la sélection en tant qu'objet dans la variable d'état `selectedItem`. Mais c'est problématique. Le contenu de `selectedItem` est le même que celui contenu dans la liste. Nous avons une duplication d'information.

---

## Description du problème

Pourquoi est-ce un problème? C'est clair en ajoutant l'édition :

<Sandpack>

```js
import { useState } from 'react';

const initialItems = [
  { title: 'pretzels', id: 0 },
  { title: 'crispy seaweed', id: 1 },
  { title: 'granola bar', id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedItem, setSelectedItem] = useState(items[0]);

  function handleItemChange(id, e) {
    setItems(
      items.map((item) => {
        if (item.id === id) {
          return {
            ...item,
            title: e.target.value,
          };
        } else {
          return item;
        }
      })
    );
  }

  return (
    <>
      <h2>What's your travel snack?</h2>
      <ul>
        {items.map((item, index) => (
          <li key={item.id}>
            <input
              value={item.title}
              onChange={(e) => {
                handleItemChange(item.id, e);
              }}
            />{' '}
            <button
              onClick={() => {
                setSelectedItem(item);
              }}
            >
              Choose
            </button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}
```

```css
button {
  margin-top: 10px;
}
```

</Sandpack>

Si on clique "Choose" sur un item, et qu'on le modifie par la suite, l'item de la liste est mis à jour, mais l'item sélectionné en bas de la liste demeure le même. Nous avons avons un état dupliqué, et nous mettons à jour la liste, mais pas `selectedItem`.

On pourrait mettre à jour `selectedItem`, mais c'est mieux d'éliminer la duplication.

---

## Éliminer la duplication

Dans cet exemple, plutôt que de stocker un objet `selectedItem` (qui duplique un objet de la liste), nous stockons un `selectedId` dans l'état. Nous obtenons le `selectedItem` en utilisant la méthode `.find()` pour trouver le bon item de la liste.

<Sandpack>

```js
import { useState } from 'react';

const initialItems = [
  { title: 'pretzels', id: 0 },
  { title: 'crispy seaweed', id: 1 },
  { title: 'granola bar', id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedId, setSelectedId] = useState(0);

  const selectedItem = items.find((item) => item.id === selectedId);

  function handleItemChange(id, e) {
    setItems(
      items.map((item) => {
        if (item.id === id) {
          return {
            ...item,
            title: e.target.value,
          };
        } else {
          return item;
        }
      })
    );
  }

  return (
    <>
      <h2>What's your travel snack?</h2>
      <ul>
        {items.map((item, index) => (
          <li key={item.id}>
            <input
              value={item.title}
              onChange={(e) => {
                handleItemChange(item.id, e);
              }}
            />{' '}
            <button
              onClick={() => {
                setSelectedId(item.id);
              }}
            >
              Choose
            </button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}
```

```css
button {
  margin-top: 10px;
}
```

</Sandpack>

(Alternative, on utilise `selectedIndex` plutôt que `selectedId`, pour retrouver l'item par sa position dans la liste.)

---

## Après la modification

L'état dupliqué

- `items = [{ id: 0, title: 'pretzels'}, ...]`
- `selectedItem = {id: 0, title: 'pretzels'}`

L'état optimal:

- `items = [{ id: 0, title: 'pretzels'}, ...]`
- `selectedId = 0`

Il n'y a plus de duplication, on ne garde que l'état essentiel.

Après la modification de l'item sélectionné, le message en bas est mis à jour immédiatement. C'est qu'avec le re-render, la méthode `items.find(...)` trouve l'item modifié.

Inutile de stocker l'objet sélectionné quand **seul l'id sélectionné suffit**. Le reste de l'objet est retrouvé pendant le rendu.

---

## Éliminer les objets profondémment imbrqués

Imaginez une planification de voyage constitué de planètes, continents et pays. On pourrait structurer l'état en utilisant des objets et tableaux imbriqués multi-niveaux:

<Sandpack>

```js
import { useState } from 'react';
import { initialTravelPlan } from './places.js';

function PlaceTree({ place }) {
  const childPlaces = place.childPlaces;
  return (
    <li>
      {place.title}
      {childPlaces.length > 0 && (
        <ol>
          {childPlaces.map((place) => (
            <PlaceTree key={place.id} place={place} />
          ))}
        </ol>
      )}
    </li>
  );
}

export default function TravelPlan() {
  const [plan, setPlan] = useState(initialTravelPlan);
  const planets = plan.childPlaces;
  return (
    <>
      <h2>Places to visit</h2>
      <ol>
        {planets.map((place) => (
          <PlaceTree key={place.id} place={place} />
        ))}
      </ol>
    </>
  );
}
```

```js src/places.js active
export const initialTravelPlan = {
  id: 0,
  title: '(Root)',
  childPlaces: [
    {
      id: 1,
      title: 'Earth',
      childPlaces: [
        {
          id: 2,
          title: 'Africa',
          childPlaces: [
            {
              id: 3,
              title: 'Botswana',
              childPlaces: [],
            },
            {
              id: 4,
              title: 'Egypt',
              childPlaces: [],
            },
            {
              id: 5,
              title: 'Kenya',
              childPlaces: [],
            },
            {
              id: 6,
              title: 'Madagascar',
              childPlaces: [],
            },
            {
              id: 7,
              title: 'Morocco',
              childPlaces: [],
            },
            {
              id: 8,
              title: 'Nigeria',
              childPlaces: [],
            },
            {
              id: 9,
              title: 'South Africa',
              childPlaces: [],
            },
          ],
        },
        {
          id: 10,
          title: 'Americas',
          childPlaces: [
            {
              id: 11,
              title: 'Argentina',
              childPlaces: [],
            },
            {
              id: 12,
              title: 'Brazil',
              childPlaces: [],
            },
            {
              id: 13,
              title: 'Barbados',
              childPlaces: [],
            },
            {
              id: 14,
              title: 'Canada',
              childPlaces: [],
            },
            {
              id: 15,
              title: 'Jamaica',
              childPlaces: [],
            },
            {
              id: 16,
              title: 'Mexico',
              childPlaces: [],
            },
            {
              id: 17,
              title: 'Trinidad and Tobago',
              childPlaces: [],
            },
            {
              id: 18,
              title: 'Venezuela',
              childPlaces: [],
            },
          ],
        },
        {
          id: 19,
          title: 'Asia',
          childPlaces: [
            {
              id: 20,
              title: 'China',
              childPlaces: [],
            },
            {
              id: 21,
              title: 'India',
              childPlaces: [],
            },
            {
              id: 22,
              title: 'Singapore',
              childPlaces: [],
            },
            {
              id: 23,
              title: 'South Korea',
              childPlaces: [],
            },
            {
              id: 24,
              title: 'Thailand',
              childPlaces: [],
            },
            {
              id: 25,
              title: 'Vietnam',
              childPlaces: [],
            },
          ],
        },
        {
          id: 26,
          title: 'Europe',
          childPlaces: [
            {
              id: 27,
              title: 'Croatia',
              childPlaces: [],
            },
            {
              id: 28,
              title: 'France',
              childPlaces: [],
            },
            {
              id: 29,
              title: 'Germany',
              childPlaces: [],
            },
            {
              id: 30,
              title: 'Italy',
              childPlaces: [],
            },
            {
              id: 31,
              title: 'Portugal',
              childPlaces: [],
            },
            {
              id: 32,
              title: 'Spain',
              childPlaces: [],
            },
            {
              id: 33,
              title: 'Turkey',
              childPlaces: [],
            },
          ],
        },
        {
          id: 34,
          title: 'Oceania',
          childPlaces: [
            {
              id: 35,
              title: 'Australia',
              childPlaces: [],
            },
            {
              id: 36,
              title: 'Bora Bora (French Polynesia)',
              childPlaces: [],
            },
            {
              id: 37,
              title: 'Easter Island (Chile)',
              childPlaces: [],
            },
            {
              id: 38,
              title: 'Fiji',
              childPlaces: [],
            },
            {
              id: 39,
              title: 'Hawaii (the USA)',
              childPlaces: [],
            },
            {
              id: 40,
              title: 'New Zealand',
              childPlaces: [],
            },
            {
              id: 41,
              title: 'Vanuatu',
              childPlaces: [],
            },
          ],
        },
      ],
    },
    {
      id: 42,
      title: 'Moon',
      childPlaces: [
        {
          id: 43,
          title: 'Rheita',
          childPlaces: [],
        },
        {
          id: 44,
          title: 'Piccolomini',
          childPlaces: [],
        },
        {
          id: 45,
          title: 'Tycho',
          childPlaces: [],
        },
      ],
    },
    {
      id: 46,
      title: 'Mars',
      childPlaces: [
        {
          id: 47,
          title: 'Corn Town',
          childPlaces: [],
        },
        {
          id: 48,
          title: 'Green Hill',
          childPlaces: [],
        },
      ],
    },
  ],
};
```

</Sandpack>

Imaginez qu'on ajoute un bouton pour éliminer un endroit déjà visité. Comment faire? Mettre à jour notre état imbriqué signifie qu'il faut cloner les différents niveaux d'objets touchés par la modification pour générer de nouvelles références. C'est une copie qui affecte la chaine d'imbrication. C'est du code complexe.

---

## Aplatir la structure

**Si l'état est complexe à mettre à jour, on peut modifier l'imbrication et rendre la structure "plate".**

Plutôt qu'une structure d'arborescence où chaque place a un tableau de _places_, on pourrait remplacer par un tableau de _place ID_.

Ce genre de structure sans imbrication (plate) fait penser à une base de données relationnelle.

<Sandpack>

```js
import { useState } from 'react';
import { initialTravelPlan } from './places.js';

function PlaceTree({ id, placesById }) {
  const place = placesById[id];
  const childIds = place.childIds;
  return (
    <li>
      {place.title}
      {childIds.length > 0 && (
        <ol>
          {childIds.map((childId) => (
            <PlaceTree key={childId} id={childId} placesById={placesById} />
          ))}
        </ol>
      )}
    </li>
  );
}

export default function TravelPlan() {
  const [plan, setPlan] = useState(initialTravelPlan);
  const root = plan[0];
  const planetIds = root.childIds;
  return (
    <>
      <h2>Places to visit</h2>
      <ol>
        {planetIds.map((id) => (
          <PlaceTree key={id} id={id} placesById={plan} />
        ))}
      </ol>
    </>
  );
}
```

```js src/places.js active
export const initialTravelPlan = {
  0: {
    id: 0,
    title: '(Root)',
    childIds: [1, 42, 46],
  },
  1: {
    id: 1,
    title: 'Earth',
    childIds: [2, 10, 19, 26, 34],
  },
  2: {
    id: 2,
    title: 'Africa',
    childIds: [3, 4, 5, 6, 7, 8, 9],
  },
  3: {
    id: 3,
    title: 'Botswana',
    childIds: [],
  },
  4: {
    id: 4,
    title: 'Egypt',
    childIds: [],
  },
  5: {
    id: 5,
    title: 'Kenya',
    childIds: [],
  },
  6: {
    id: 6,
    title: 'Madagascar',
    childIds: [],
  },
  7: {
    id: 7,
    title: 'Morocco',
    childIds: [],
  },
  8: {
    id: 8,
    title: 'Nigeria',
    childIds: [],
  },
  9: {
    id: 9,
    title: 'South Africa',
    childIds: [],
  },
  10: {
    id: 10,
    title: 'Americas',
    childIds: [11, 12, 13, 14, 15, 16, 17, 18],
  },
  11: {
    id: 11,
    title: 'Argentina',
    childIds: [],
  },
  12: {
    id: 12,
    title: 'Brazil',
    childIds: [],
  },
  13: {
    id: 13,
    title: 'Barbados',
    childIds: [],
  },
  14: {
    id: 14,
    title: 'Canada',
    childIds: [],
  },
  15: {
    id: 15,
    title: 'Jamaica',
    childIds: [],
  },
  16: {
    id: 16,
    title: 'Mexico',
    childIds: [],
  },
  17: {
    id: 17,
    title: 'Trinidad and Tobago',
    childIds: [],
  },
  18: {
    id: 18,
    title: 'Venezuela',
    childIds: [],
  },
  19: {
    id: 19,
    title: 'Asia',
    childIds: [20, 21, 22, 23, 24, 25],
  },
  20: {
    id: 20,
    title: 'China',
    childIds: [],
  },
  21: {
    id: 21,
    title: 'India',
    childIds: [],
  },
  22: {
    id: 22,
    title: 'Singapore',
    childIds: [],
  },
  23: {
    id: 23,
    title: 'South Korea',
    childIds: [],
  },
  24: {
    id: 24,
    title: 'Thailand',
    childIds: [],
  },
  25: {
    id: 25,
    title: 'Vietnam',
    childIds: [],
  },
  26: {
    id: 26,
    title: 'Europe',
    childIds: [27, 28, 29, 30, 31, 32, 33],
  },
  27: {
    id: 27,
    title: 'Croatia',
    childIds: [],
  },
  28: {
    id: 28,
    title: 'France',
    childIds: [],
  },
  29: {
    id: 29,
    title: 'Germany',
    childIds: [],
  },
  30: {
    id: 30,
    title: 'Italy',
    childIds: [],
  },
  31: {
    id: 31,
    title: 'Portugal',
    childIds: [],
  },
  32: {
    id: 32,
    title: 'Spain',
    childIds: [],
  },
  33: {
    id: 33,
    title: 'Turkey',
    childIds: [],
  },
  34: {
    id: 34,
    title: 'Oceania',
    childIds: [35, 36, 37, 38, 39, 40, 41],
  },
  35: {
    id: 35,
    title: 'Australia',
    childIds: [],
  },
  36: {
    id: 36,
    title: 'Bora Bora (French Polynesia)',
    childIds: [],
  },
  37: {
    id: 37,
    title: 'Easter Island (Chile)',
    childIds: [],
  },
  38: {
    id: 38,
    title: 'Fiji',
    childIds: [],
  },
  39: {
    id: 40,
    title: 'Hawaii (the USA)',
    childIds: [],
  },
  40: {
    id: 40,
    title: 'New Zealand',
    childIds: [],
  },
  41: {
    id: 41,
    title: 'Vanuatu',
    childIds: [],
  },
  42: {
    id: 42,
    title: 'Moon',
    childIds: [43, 44, 45],
  },
  43: {
    id: 43,
    title: 'Rheita',
    childIds: [],
  },
  44: {
    id: 44,
    title: 'Piccolomini',
    childIds: [],
  },
  45: {
    id: 45,
    title: 'Tycho',
    childIds: [],
  },
  46: {
    id: 46,
    title: 'Mars',
    childIds: [47, 48],
  },
  47: {
    id: 47,
    title: 'Corn Town',
    childIds: [],
  },
  48: {
    id: 48,
    title: 'Green Hill',
    childIds: [],
  },
};
```

</Sandpack>

**Avec une structure "plate" (ou normalisée), les mises à jours sont plus simples.**

---

## La mise à jour est simplifiée

Maitenant, pour enlever une place, on n'a besoin que de mettre à jour deux choses:

- Nous créons un clone du _parent_ qui exclut l'ID à éliminer du tableau `childIds`.
- On intègre cet objet dans l'objet "table" racine.

<Sandpack>

```js
import { useState } from 'react';
import { initialTravelPlan } from './places.js';

export default function TravelPlan() {
  const [plan, setPlan] = useState(initialTravelPlan);

  function handleComplete(parentId, childId) {
    const parent = plan[parentId];
    // Create a new version of the parent place
    // that doesn't include this child ID.
    const nextParent = {
      ...parent,
      childIds: parent.childIds.filter((id) => id !== childId),
    };
    // Update the root state object...
    setPlan({
      ...plan,
      // ...so that it has the updated parent.
      [parentId]: nextParent,
    });
  }

  const root = plan[0];
  const planetIds = root.childIds;
  return (
    <>
      <h2>Places to visit</h2>
      <ol>
        {planetIds.map((id) => (
          <PlaceTree
            key={id}
            id={id}
            parentId={0}
            placesById={plan}
            onComplete={handleComplete}
          />
        ))}
      </ol>
    </>
  );
}

function PlaceTree({ id, parentId, placesById, onComplete }) {
  const place = placesById[id];
  const childIds = place.childIds;
  return (
    <li>
      {place.title}
      <button
        onClick={() => {
          onComplete(parentId, id);
        }}
      >
        Complete
      </button>
      {childIds.length > 0 && (
        <ol>
          {childIds.map((childId) => (
            <PlaceTree
              key={childId}
              id={childId}
              parentId={id}
              placesById={placesById}
              onComplete={onComplete}
            />
          ))}
        </ol>
      )}
    </li>
  );
}
```

```js src/places.js
export const initialTravelPlan = {
  0: {
    id: 0,
    title: '(Root)',
    childIds: [1, 42, 46],
  },
  1: {
    id: 1,
    title: 'Earth',
    childIds: [2, 10, 19, 26, 34],
  },
  2: {
    id: 2,
    title: 'Africa',
    childIds: [3, 4, 5, 6, 7, 8, 9],
  },
  3: {
    id: 3,
    title: 'Botswana',
    childIds: [],
  },
  4: {
    id: 4,
    title: 'Egypt',
    childIds: [],
  },
  5: {
    id: 5,
    title: 'Kenya',
    childIds: [],
  },
  6: {
    id: 6,
    title: 'Madagascar',
    childIds: [],
  },
  7: {
    id: 7,
    title: 'Morocco',
    childIds: [],
  },
  8: {
    id: 8,
    title: 'Nigeria',
    childIds: [],
  },
  9: {
    id: 9,
    title: 'South Africa',
    childIds: [],
  },
  10: {
    id: 10,
    title: 'Americas',
    childIds: [11, 12, 13, 14, 15, 16, 17, 18],
  },
  11: {
    id: 11,
    title: 'Argentina',
    childIds: [],
  },
  12: {
    id: 12,
    title: 'Brazil',
    childIds: [],
  },
  13: {
    id: 13,
    title: 'Barbados',
    childIds: [],
  },
  14: {
    id: 14,
    title: 'Canada',
    childIds: [],
  },
  15: {
    id: 15,
    title: 'Jamaica',
    childIds: [],
  },
  16: {
    id: 16,
    title: 'Mexico',
    childIds: [],
  },
  17: {
    id: 17,
    title: 'Trinidad and Tobago',
    childIds: [],
  },
  18: {
    id: 18,
    title: 'Venezuela',
    childIds: [],
  },
  19: {
    id: 19,
    title: 'Asia',
    childIds: [20, 21, 22, 23, 24, 25],
  },
  20: {
    id: 20,
    title: 'China',
    childIds: [],
  },
  21: {
    id: 21,
    title: 'India',
    childIds: [],
  },
  22: {
    id: 22,
    title: 'Singapore',
    childIds: [],
  },
  23: {
    id: 23,
    title: 'South Korea',
    childIds: [],
  },
  24: {
    id: 24,
    title: 'Thailand',
    childIds: [],
  },
  25: {
    id: 25,
    title: 'Vietnam',
    childIds: [],
  },
  26: {
    id: 26,
    title: 'Europe',
    childIds: [27, 28, 29, 30, 31, 32, 33],
  },
  27: {
    id: 27,
    title: 'Croatia',
    childIds: [],
  },
  28: {
    id: 28,
    title: 'France',
    childIds: [],
  },
  29: {
    id: 29,
    title: 'Germany',
    childIds: [],
  },
  30: {
    id: 30,
    title: 'Italy',
    childIds: [],
  },
  31: {
    id: 31,
    title: 'Portugal',
    childIds: [],
  },
  32: {
    id: 32,
    title: 'Spain',
    childIds: [],
  },
  33: {
    id: 33,
    title: 'Turkey',
    childIds: [],
  },
  34: {
    id: 34,
    title: 'Oceania',
    childIds: [35, 36, 37, 38, 39, 40, 41],
  },
  35: {
    id: 35,
    title: 'Australia',
    childIds: [],
  },
  36: {
    id: 36,
    title: 'Bora Bora (French Polynesia)',
    childIds: [],
  },
  37: {
    id: 37,
    title: 'Easter Island (Chile)',
    childIds: [],
  },
  38: {
    id: 38,
    title: 'Fiji',
    childIds: [],
  },
  39: {
    id: 39,
    title: 'Hawaii (the USA)',
    childIds: [],
  },
  40: {
    id: 40,
    title: 'New Zealand',
    childIds: [],
  },
  41: {
    id: 41,
    title: 'Vanuatu',
    childIds: [],
  },
  42: {
    id: 42,
    title: 'Moon',
    childIds: [43, 44, 45],
  },
  43: {
    id: 43,
    title: 'Rheita',
    childIds: [],
  },
  44: {
    id: 44,
    title: 'Piccolomini',
    childIds: [],
  },
  45: {
    id: 45,
    title: 'Tycho',
    childIds: [],
  },
  46: {
    id: 46,
    title: 'Mars',
    childIds: [47, 48],
  },
  47: {
    id: 47,
    title: 'Corn Town',
    childIds: [],
  },
  48: {
    id: 48,
    title: 'Green Hill',
    childIds: [],
  },
};
```

```css
button {
  margin: 10px;
}
```

</Sandpack>

On peut imbriquer les objets d'état autant qu'on veut, mais aplatir peut résoudre bien des problèmes. Ça rend l'état plus simple à mettre à jour, et ça évite la duplication de parties de nos objets imbriqués.

---

## Optimiser la consommation de la mémoire

Idéalement, on élimine les items effacés (et leurs enfants!) de la "table" pour optimiser la consommation de la mémoire.

On utilise Immer pour simplifier les mises à jour.

<Sandpack>

```js
import { useImmer } from 'use-immer';
import { initialTravelPlan } from './places.js';

export default function TravelPlan() {
  const [plan, updatePlan] = useImmer(initialTravelPlan);

  function handleComplete(parentId, childId) {
    updatePlan((draft) => {
      // Remove from the parent place's child IDs.
      const parent = draft[parentId];
      parent.childIds = parent.childIds.filter((id) => id !== childId);

      // Forget this place and all its subtree.
      deleteAllChildren(childId);
      function deleteAllChildren(id) {
        const place = draft[id];
        place.childIds.forEach(deleteAllChildren);
        delete draft[id];
      }
    });
  }

  const root = plan[0];
  const planetIds = root.childIds;
  return (
    <>
      <h2>Places to visit</h2>
      <ol>
        {planetIds.map((id) => (
          <PlaceTree
            key={id}
            id={id}
            parentId={0}
            placesById={plan}
            onComplete={handleComplete}
          />
        ))}
      </ol>
    </>
  );
}

function PlaceTree({ id, parentId, placesById, onComplete }) {
  const place = placesById[id];
  const childIds = place.childIds;
  return (
    <li>
      {place.title}
      <button
        onClick={() => {
          onComplete(parentId, id);
        }}
      >
        Complete
      </button>
      {childIds.length > 0 && (
        <ol>
          {childIds.map((childId) => (
            <PlaceTree
              key={childId}
              id={childId}
              parentId={id}
              placesById={placesById}
              onComplete={onComplete}
            />
          ))}
        </ol>
      )}
    </li>
  );
}
```

```js src/places.js
export const initialTravelPlan = {
  0: {
    id: 0,
    title: '(Root)',
    childIds: [1, 42, 46],
  },
  1: {
    id: 1,
    title: 'Earth',
    childIds: [2, 10, 19, 26, 34],
  },
  2: {
    id: 2,
    title: 'Africa',
    childIds: [3, 4, 5, 6, 7, 8, 9],
  },
  3: {
    id: 3,
    title: 'Botswana',
    childIds: [],
  },
  4: {
    id: 4,
    title: 'Egypt',
    childIds: [],
  },
  5: {
    id: 5,
    title: 'Kenya',
    childIds: [],
  },
  6: {
    id: 6,
    title: 'Madagascar',
    childIds: [],
  },
  7: {
    id: 7,
    title: 'Morocco',
    childIds: [],
  },
  8: {
    id: 8,
    title: 'Nigeria',
    childIds: [],
  },
  9: {
    id: 9,
    title: 'South Africa',
    childIds: [],
  },
  10: {
    id: 10,
    title: 'Americas',
    childIds: [11, 12, 13, 14, 15, 16, 17, 18],
  },
  11: {
    id: 11,
    title: 'Argentina',
    childIds: [],
  },
  12: {
    id: 12,
    title: 'Brazil',
    childIds: [],
  },
  13: {
    id: 13,
    title: 'Barbados',
    childIds: [],
  },
  14: {
    id: 14,
    title: 'Canada',
    childIds: [],
  },
  15: {
    id: 15,
    title: 'Jamaica',
    childIds: [],
  },
  16: {
    id: 16,
    title: 'Mexico',
    childIds: [],
  },
  17: {
    id: 17,
    title: 'Trinidad and Tobago',
    childIds: [],
  },
  18: {
    id: 18,
    title: 'Venezuela',
    childIds: [],
  },
  19: {
    id: 19,
    title: 'Asia',
    childIds: [20, 21, 22, 23, 24, 25],
  },
  20: {
    id: 20,
    title: 'China',
    childIds: [],
  },
  21: {
    id: 21,
    title: 'India',
    childIds: [],
  },
  22: {
    id: 22,
    title: 'Singapore',
    childIds: [],
  },
  23: {
    id: 23,
    title: 'South Korea',
    childIds: [],
  },
  24: {
    id: 24,
    title: 'Thailand',
    childIds: [],
  },
  25: {
    id: 25,
    title: 'Vietnam',
    childIds: [],
  },
  26: {
    id: 26,
    title: 'Europe',
    childIds: [27, 28, 29, 30, 31, 32, 33],
  },
  27: {
    id: 27,
    title: 'Croatia',
    childIds: [],
  },
  28: {
    id: 28,
    title: 'France',
    childIds: [],
  },
  29: {
    id: 29,
    title: 'Germany',
    childIds: [],
  },
  30: {
    id: 30,
    title: 'Italy',
    childIds: [],
  },
  31: {
    id: 31,
    title: 'Portugal',
    childIds: [],
  },
  32: {
    id: 32,
    title: 'Spain',
    childIds: [],
  },
  33: {
    id: 33,
    title: 'Turkey',
    childIds: [],
  },
  34: {
    id: 34,
    title: 'Oceania',
    childIds: [35, 36, 37, 38, 39, 40, , 41],
  },
  35: {
    id: 35,
    title: 'Australia',
    childIds: [],
  },
  36: {
    id: 36,
    title: 'Bora Bora (French Polynesia)',
    childIds: [],
  },
  37: {
    id: 37,
    title: 'Easter Island (Chile)',
    childIds: [],
  },
  38: {
    id: 38,
    title: 'Fiji',
    childIds: [],
  },
  39: {
    id: 39,
    title: 'Hawaii (the USA)',
    childIds: [],
  },
  40: {
    id: 40,
    title: 'New Zealand',
    childIds: [],
  },
  41: {
    id: 41,
    title: 'Vanuatu',
    childIds: [],
  },
  42: {
    id: 42,
    title: 'Moon',
    childIds: [43, 44, 45],
  },
  43: {
    id: 43,
    title: 'Rheita',
    childIds: [],
  },
  44: {
    id: 44,
    title: 'Piccolomini',
    childIds: [],
  },
  45: {
    id: 45,
    title: 'Tycho',
    childIds: [],
  },
  46: {
    id: 46,
    title: 'Mars',
    childIds: [47, 48],
  },
  47: {
    id: 47,
    title: 'Corn Town',
    childIds: [],
  },
  48: {
    id: 48,
    title: 'Green Hill',
    childIds: [],
  },
};
```

```css
button {
  margin: 10px;
}
```

```json package.json
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

</Sandpack>

On peut aussi réduire l'imbrication profonde en déplaçant des morceaux de l'état dans des composants enfants. Ça fonctionne bien pour les états éphémères de l'interface. Ex: un item sur le lequel on place le curseur (hover) qui affiche alors une boîte d'explication (tooltip).

---

## Défi: Réparer la mise à jour

La composante `Clock` deçoit deux props: `color` et `time`. Quand on sélectionne une nouvelle couleur, la composante `Clock` reçoit une nouvelle prop `color`. Mais la nouvelle couleur ne s'affiche pas. Pourquoi? Réparez.

<Sandpack>

```js src/Clock.js active
import { useState } from 'react';

export default function Clock(props) {
  const [color, setColor] = useState(props.color);
  return <h1 style={{ color: color }}>{props.time}</h1>;
}
```

```js src/App.js hidden
import { useState, useEffect } from 'react';
import Clock from './Clock.js';

function useTime() {
  const [time, setTime] = useState(() => new Date());
  useEffect(() => {
    const id = setInterval(() => {
      setTime(new Date());
    }, 1000);
    return () => clearInterval(id);
  }, []);
  return time;
}

export default function App() {
  const time = useTime();
  const [color, setColor] = useState('lightcoral');
  return (
    <div>
      <p>
        Pick a color:{' '}
        <select value={color} onChange={(e) => setColor(e.target.value)}>
          <option value='lightcoral'>lightcoral</option>
          <option value='midnightblue'>midnightblue</option>
          <option value='rebeccapurple'>rebeccapurple</option>
        </select>
      </p>
      <Clock color={color} time={time.toLocaleTimeString()} />
    </div>
  );
}
```

</Sandpack>

---

## Défi: Réparer une liste

Cette liste d'affaires affiche un pied de page qui indique le nombre d'items dans les bagages, et le nombre d'items total.

Il y a un bogue: Si on marque un item "packed" et qu'on le "delete" après, le compteur sera incorrect.

Y aurait-il un état redondant?

<Sandpack>

```js src/App.js
import { useState } from 'react';
import AddItem from './AddItem.js';
import PackingList from './PackingList.js';

let nextId = 3;
const initialItems = [
  { id: 0, title: 'Warm socks', packed: true },
  { id: 1, title: 'Travel journal', packed: false },
  { id: 2, title: 'Watercolors', packed: false },
];

export default function TravelPlan() {
  const [items, setItems] = useState(initialItems);
  const [total, setTotal] = useState(3);
  const [packed, setPacked] = useState(1);

  function handleAddItem(title) {
    setTotal(total + 1);
    setItems([
      ...items,
      {
        id: nextId++,
        title: title,
        packed: false,
      },
    ]);
  }

  function handleChangeItem(nextItem) {
    if (nextItem.packed) {
      setPacked(packed + 1);
    } else {
      setPacked(packed - 1);
    }
    setItems(
      items.map((item) => {
        if (item.id === nextItem.id) {
          return nextItem;
        } else {
          return item;
        }
      })
    );
  }

  function handleDeleteItem(itemId) {
    setTotal(total - 1);
    setItems(items.filter((item) => item.id !== itemId));
  }

  return (
    <>
      <AddItem onAddItem={handleAddItem} />
      <PackingList
        items={items}
        onChangeItem={handleChangeItem}
        onDeleteItem={handleDeleteItem}
      />
      <hr />
      <b>
        {packed} out of {total} packed!
      </b>
    </>
  );
}
```

```js src/AddItem.js hidden
import { useState } from 'react';

export default function AddItem({ onAddItem }) {
  const [title, setTitle] = useState('');
  return (
    <>
      <input
        placeholder='Add item'
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />
      <button
        onClick={() => {
          setTitle('');
          onAddItem(title);
        }}
      >
        Add
      </button>
    </>
  );
}
```

```js src/PackingList.js hidden
import { useState } from 'react';

export default function PackingList({ items, onChangeItem, onDeleteItem }) {
  return (
    <ul>
      {items.map((item) => (
        <li key={item.id}>
          <label>
            <input
              type='checkbox'
              checked={item.packed}
              onChange={(e) => {
                onChangeItem({
                  ...item,
                  packed: e.target.checked,
                });
              }}
            />{' '}
            {item.title}
          </label>
          <button onClick={() => onDeleteItem(item.id)}>Delete</button>
        </li>
      ))}
    </ul>
  );
}
```

```css
button {
  margin: 5px;
}
li {
  list-style-type: none;
}
ul,
li {
  margin: 0;
  padding: 0;
}
```

</Sandpack>

---

## Défi : Réparer la sélection qui disparait

L'état contient une liste de `letters`. Quand on flotte ou focus sur une lettre, elle est mise en évidence en surligné (highlight). C'est stocké dans la variable d'état `highlightedLetter`. On peut aussi ajouter une "star" et enlever avec "unstar" des lettres individuelles.

Le code fonctionne, mais avec un un petit problème: si on clique sur "Star" ou "Unstar", le surlignage disparait un moment. Il réapparaît dès qu'on déplace le curseur ou qu'on déplace le focus avec le clavier. Pourquoi?? Réparez pour que le surlignage ne disparaisse plus.

<Sandpack>

```js src/App.js
import { useState } from 'react';
import { initialLetters } from './data.js';
import Letter from './Letter.js';

export default function MailClient() {
  const [letters, setLetters] = useState(initialLetters);
  const [highlightedLetter, setHighlightedLetter] = useState(null);

  function handleHover(letter) {
    setHighlightedLetter(letter);
  }

  function handleStar(starred) {
    setLetters(
      letters.map((letter) => {
        if (letter.id === starred.id) {
          return {
            ...letter,
            isStarred: !letter.isStarred,
          };
        } else {
          return letter;
        }
      })
    );
  }

  return (
    <>
      <h2>Inbox</h2>
      <ul>
        {letters.map((letter) => (
          <Letter
            key={letter.id}
            letter={letter}
            isHighlighted={letter === highlightedLetter}
            onHover={handleHover}
            onToggleStar={handleStar}
          />
        ))}
      </ul>
    </>
  );
}
```

```js src/Letter.js
export default function Letter({
  letter,
  isHighlighted,
  onHover,
  onToggleStar,
}) {
  return (
    <li
      className={isHighlighted ? 'highlighted' : ''}
      onFocus={() => {
        onHover(letter);
      }}
      onPointerMove={() => {
        onHover(letter);
      }}
    >
      <button
        onClick={() => {
          onToggleStar(letter);
        }}
      >
        {letter.isStarred ? 'Unstar' : 'Star'}
      </button>
      {letter.subject}
    </li>
  );
}
```

```js src/data.js
export const initialLetters = [
  {
    id: 0,
    subject: 'Ready for adventure?',
    isStarred: true,
  },
  {
    id: 1,
    subject: 'Time to check in!',
    isStarred: false,
  },
  {
    id: 2,
    subject: 'Festival Begins in Just SEVEN Days!',
    isStarred: false,
  },
];
```

```css
button {
  margin: 5px;
}
li {
  border-radius: 5px;
}
.highlighted {
  background: #d2eaff;
}
```

</Sandpack>

---

## Défi: Implanter une séléction multiple

Chaque `Letter` possède une prop `isSelected` et un gestionnaire `onToggle` pour basculer. L'état est conservé dans `selectedId` (soit `null` ou un ID), une seule lettre est sélectionnée à la fois.

Changez la structure de l'étate pour permettre la sélection multiple. (Quelle serait la structure? réfléchssez avant de coder.) Chaque boite est indépendante des autres. Cliquer un élément sélectionné enlève la sélection. Le pied de page doit afficher le nombre d'éléments.

<Hint>
  Plutôt que de stocker un ID, on pourrait stocker un tableau ou un
  [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)
  dans l'état.
</Hint>

<Sandpack>

```js src/App.js
import { useState } from 'react';
import { letters } from './data.js';
import Letter from './Letter.js';

export default function MailClient() {
  const [selectedId, setSelectedId] = useState(null);

  // TODO: allow multiple selection
  const selectedCount = 1;

  function handleToggle(toggledId) {
    // TODO: allow multiple selection
    setSelectedId(toggledId);
  }

  return (
    <>
      <h2>Inbox</h2>
      <ul>
        {letters.map((letter) => (
          <Letter
            key={letter.id}
            letter={letter}
            isSelected={
              // TODO: allow multiple selection
              letter.id === selectedId
            }
            onToggle={handleToggle}
          />
        ))}
        <hr />
        <p>
          <b>You selected {selectedCount} letters</b>
        </p>
      </ul>
    </>
  );
}
```

```js src/Letter.js
export default function Letter({ letter, onToggle, isSelected }) {
  return (
    <li className={isSelected ? 'selected' : ''}>
      <label>
        <input
          type='checkbox'
          checked={isSelected}
          onChange={() => {
            onToggle(letter.id);
          }}
        />
        {letter.subject}
      </label>
    </li>
  );
}
```

```js src/data.js
export const letters = [
  {
    id: 0,
    subject: 'Ready for adventure?',
    isStarred: true,
  },
  {
    id: 1,
    subject: 'Time to check in!',
    isStarred: false,
  },
  {
    id: 2,
    subject: 'Festival Begins in Just SEVEN Days!',
    isStarred: false,
  },
];
```

```css
input {
  margin: 5px;
}
li {
  border-radius: 5px;
}
label {
  width: 100%;
  padding: 5px;
  display: inline-block;
}
.selected {
  background: #d2eaff;
}
```

</Sandpack>

---

## Partager l'état entre les composants

Pour partager l'état entre deux composants,

- Enlever l'état local
- Remonter l'état au parent commun
- passer cette valeur via les props

Ça se nomme _remonter l'état_

---

## L'état non-partagé

Voici un exemple d'un composant `Accordion` parent qui affiche deux `Panel`s:

- `Accordion`
  - `Panel`
  - `Panel`

Chaque composant `Panel` possède un état booléen `isActive` qui détermine la visibilité.

<Sandpack>

```js
import { useState } from 'react';

function Panel({ title, children }) {
  const [isActive, setIsActive] = useState(false);
  return (
    <section className='panel'>
      <h3>{title}</h3>
      {isActive ? (
        <p>{children}</p>
      ) : (
        <button onClick={() => setIsActive(true)}>Show</button>
      )}
    </section>
  );
}

export default function Accordion() {
  return (
    <>
      <h2>Almaty, Kazakhstan</h2>
      <Panel title='About'>
        With a population of about 2 million, Almaty is Kazakhstan's largest
        city. From 1929 to 1997, it was its capital city.
      </Panel>
      <Panel title='Etymology'>
        The name comes from <span lang='kk-KZ'>алма</span>, the Kazakh word for
        "apple" and is often translated as "full of apples". In fact, the region
        surrounding Almaty is thought to be the ancestral home of the apple, and
        the wild <i lang='la'>Malus sieversii</i> is considered a likely
        candidate for the ancestor of the modern domestic apple.
      </Panel>
    </>
  );
}
```

```css
h3,
p {
  margin: 5px 0px;
}
.panel {
  padding: 10px;
  border: 1px solid #aaa;
}
```

</Sandpack>

---

## États indépendants

Les deux états sont indépendants. Cliquer l'un n'affecte pas l'autre.

<aside style={{display:'grid', gridTemplateColumns:"1fr 1fr", columnGap:10}}>
<Diagram name="sharing_state_child" height={367} width={477} alt="Diagram showing a tree of three components, one parent labeled Accordion and two children labeled Panel. Both Panel components contain isActive with value false.">

Initially, each `Panel`'s `isActive` state is `false`, so they both appear collapsed

</Diagram>

<Diagram name="sharing_state_child_clicked" height={367} width={480} alt="The same diagram as the previous, with the isActive of the first child Panel component highlighted indicating a click with the isActive value set to true. The second Panel component still contains value false." >

Clicking either `Panel`'s button will only update that `Panel`'s `isActive` state alone

</Diagram>
</aside>

---

## Un seul panel visible à la fois

Pour n'avoir qu'un seul panel visible à la fois, que faire? (Sélectionner un second panel, enlèvera la sélection précédente.)

Pour coordonner les 2 panels, il faut "remonter l'état" vers un composant parent:

1. **Enlever** l'état des composants enfants.
2. **Passer** des données du parent commun.
3. **Ajouter** l'état au parent commun et passer cette valeur et les gestionnaires d'états vers les enfants

La composante `Accordion` pourra gérer l'état pour n'en avoir qu'un seul `Panel` visible.

---

## Étape 1: Enlever l'état des composants enfants

Dans les `Panel`s, l'état `isActive` devient la prop `isActive`.

On doit remplacer l'état du `Panel`:

```js
const [isActive, setIsActive] = useState(false);
```

Par une prop:

```js
function Panel({ title, children, isActive }) {
```

Le parent du `Panel` pourra controller `isActive` en passant des Props. La composante `Panel` n'a plus de contrôle sur la valeur de `isActive`. C'est maintenant géré par le parent.

---

## Étape 2: Passer des données du parent commun.

Pour remonter l'état, il faut trouver le parent commun des deux composants enfants à synchroniser.

- `Accordion` _(parent commun le plus proche)_
  - `Panel`
  - `Panel`

Dans cet exemple, c'est la composante `Accordion`.

---

## Pousser des données statiques

On peut passer, du composant `Accordion`, des données statiques pour `isActive` (par exemple: `true`) vers les 2 `Panels`:

<Sandpack>

```js
import { useState } from 'react';

export default function Accordion() {
  return (
    <>
      <h2>Almaty, Kazakhstan</h2>
      <Panel title='About' isActive={true}>
        With a population of about 2 million, Almaty is Kazakhstan's largest
        city. From 1929 to 1997, it was its capital city.
      </Panel>
      <Panel title='Etymology' isActive={true}>
        The name comes from <span lang='kk-KZ'>алма</span>, the Kazakh word for
        "apple" and is often translated as "full of apples". In fact, the region
        surrounding Almaty is thought to be the ancestral home of the apple, and
        the wild <i lang='la'>Malus sieversii</i> is considered a likely
        candidate for the ancestor of the modern domestic apple.
      </Panel>
    </>
  );
}

function Panel({ title, children, isActive }) {
  return (
    <section className='panel'>
      <h3>{title}</h3>
      {isActive ? (
        <p>{children}</p>
      ) : (
        <button onClick={() => setIsActive(true)}>Show</button>
      )}
    </section>
  );
}
```

```css
h3,
p {
  margin: 5px 0px;
}
.panel {
  padding: 10px;
  border: 1px solid #aaa;
}
```

</Sandpack>

Modifiez les valeurs de `isActive` dans `Accordion` et validez l'affichage sur l'écran.

---

## Étape 3: Ajouter l'état au parent commun

Remonter l'état peut modifier la structure des données.

Dans ce cas, il n'y a qu'un seul paneau de visble. Plutôt qu'une valeur booléene, un nombre pourrait stocker l'index du paneau visible.

```js
const [activeIndex, setActiveIndex] = useState(0);
```

---

## Gestionnaires d'événements sont poussés

Cliquer le bouton "Show" dans un `Panel` modifie l'index actif d'`Accordion`. Un `Panel` ne peut modifier `activeIndex` directement, car cet état se trouve dans `Accordion`. La composante `Accordion` doit _explicitement permettre_ la modification de l'état en passant un [gestionnaire d'état en tant que prop](/learn/responding-to-events#passing-event-handlers-as-props):

```js
<>
  <Panel isActive={activeIndex === 0} onShow={() => setActiveIndex(0)}>
    ...
  </Panel>
  <Panel isActive={activeIndex === 1} onShow={() => setActiveIndex(1)}>
    ...
  </Panel>
</>
```

---

## Exemple avec état partagé

Le `<button>` dans le `Panel` utilise la prop `onShow` pour gérer le click:

<Sandpack>

```js
import { useState } from 'react';

export default function Accordion() {
  const [activeIndex, setActiveIndex] = useState(0);
  return (
    <>
      <h2>Almaty, Kazakhstan</h2>
      <Panel
        title='About'
        isActive={activeIndex === 0}
        onShow={() => setActiveIndex(0)}
      >
        With a population of about 2 million, Almaty is Kazakhstan's largest
        city. From 1929 to 1997, it was its capital city.
      </Panel>
      <Panel
        title='Etymology'
        isActive={activeIndex === 1}
        onShow={() => setActiveIndex(1)}
      >
        The name comes from <span lang='kk-KZ'>алма</span>, the Kazakh word for
        "apple" and is often translated as "full of apples". In fact, the region
        surrounding Almaty is thought to be the ancestral home of the apple, and
        the wild <i lang='la'>Malus sieversii</i> is considered a likely
        candidate for the ancestor of the modern domestic apple.
      </Panel>
    </>
  );
}

function Panel({ title, children, isActive, onShow }) {
  return (
    <section className='panel'>
      <h3>{title}</h3>
      {isActive ? <p>{children}</p> : <button onClick={onShow}>Show</button>}
    </section>
  );
}
```

```css
h3,
p {
  margin: 5px 0px;
}
.panel {
  padding: 10px;
  border: 1px solid #aaa;
}
```

</Sandpack>
 
---

## Diagramme de l'état remonté

- Utiliser l'index actif (plutôt que des valeurs booléenes) assure qu'un seul panneau est affiché à la fois.

- Passer le gestonnaire d'événements aux enfants permet à ces derniers de modifier l'état du parent.

<aside style={{display:'grid', gridTemplateColumns:"1fr 1fr", columnGap:10}}>
<Diagram name="sharing_state_parent" height={385} width={487} alt="Diagram showing a tree of three components, one parent labeled Accordion and two children labeled Panel. Accordion contains an activeIndex value of zero which turns into isActive value of true passed to the first Panel, and isActive value of false passed to the second Panel." >

Initially, `Accordion`'s `activeIndex` is `0`, so the first `Panel` receives `isActive = true`

</Diagram>

<Diagram name="sharing_state_parent_clicked" height={385} width={521} alt="The same diagram as the previous, with the activeIndex value of the parent Accordion component highlighted indicating a click with the value changed to one. The flow to both of the children Panel components is also highlighted, and the isActive value passed to each child is set to the opposite: false for the first Panel and true for the second one." >

When `Accordion`'s `activeIndex` state changes to `1`, the second `Panel` receives `isActive = true` instead

</Diagram>
</aside >

---

## Composants controllés vs. composants non-controllés

Il est commun d'appeler un composant avec un état interne "non-contollé". (Par exemple, le composant `Panel` original, avec son état booléen `ìsActive`, est non-controllée. Le parent ne peut influencer si le `Panel` est affiché ou non.)

Un composant est "controllé" quand l'information importante est gérée par ses props plutôt que son état interne. C'est le parent qui gère le comportement global. (ex: le composant `Panel` final, avec une prop `isActive` controllée par le composant `Accordion`)

| Composants non-controllés                   | Composants controllés                                             |
| ------------------------------------------- | ----------------------------------------------------------------- |
| - Plus simples                              | - Nécessitent l'état dans un parent                               |
| - Moins de props à passer                   | - Doivent utiliser des props                                      |
| - Ne peuvent se coordonner entre composants | - Flexibles, car le parent peut coordorner les composants enfants |

---

## La distinction controllée et non-controllée est floue

Les termes "controllés" et "non-controllés" ne sont pas des termes techniques stricts. La plupart des composants ont un mélange des deux approches, avec de l'état interne, ainsi que des props. Ces termes permettent de décrire comment les composants sont conçus et les capacités qu'ils offrent.

Quand on écrit un composant, il faut réfléchir: quelle information devrait être controllée (via les props) et quelle information devrait être non-controllée (via l'état)?

Il est toujours possible de changer d'idée plus tard, en refactorisant les composants.

---

## Une source de vérité pour chaque composant

L'état peut soit être stocké près des composants en bas de l'arborescence (ex: un champ de saisie "input"), soit être stocké en haut de l'arborescence (ex: le routage client).

**Pour chaque état unique, il faut choisir quelle composante la stocke.** C'est le principe de la ["source de vérité unique".](https://en.wikipedia.org/wiki/Single_source_of_truth)

Ça ne signifie pas que tout l'état est stocké à un seul endroit. Ça signifie plutôt que pour chaque morceau d'état, il y a une composante spécifique qui stocke l'information. Plutôt que de dupliquer l'état partagé entre les composants, remontez l'état vers un parent commun, et passez l'info vers les enfants via des props.

L'application évolue à mesure que l'on programme. L'état se déplacera à mesure que l'on complète la solution.

Consultez [Thinking in React.](https://react.dev/learn/thinking-in-react)

---

## Résumé

- Pour coordoner deux composants, déplacez leur état vers un parent commun
- Passez l'info du parent aux enfants via les props
- Passez des gestionnaires d'événement pour que les enfants puissent modifier l'état du parent
- Il y deux approches aux composants:
  - Composants controllés (gérés par des props)
  - Composants non-controllés (gérés par l'état)

---

## Défi: Inputs synchronisés

Ces deux champs de saisis (inputs) sont indépendants. Il faudrait qu'ils soient synchronisés (modifier l'un devrait modifier l'autre) .

<Hint> Il faudra remonter l'état dans le parent. </Hint>

<Sandpack>

```js
import { useState } from 'react';

export default function SyncedInputs() {
  return (
    <>
      <Input label='First input' />
      <Input label='Second input' />
    </>
  );
}

function Input({ label }) {
  const [text, setText] = useState('');

  function handleChange(e) {
    setText(e.target.value);
  }

  return (
    <label>
      {label} <input value={text} onChange={handleChange} />
    </label>
  );
}
```

```css
input {
  margin: 5px;
}
label {
  display: block;
}
```

</Sandpack>

---

## Défi: Filtrer une liste

Dans cet exemple, le `SearchBar` a un état `query` controllant le champ de saisie. Le composant parent `FilterableList` affiche une `List` d'items, mais ignore le `query`.

Avec la fonction `filterItems(foods, query)`, filtrez la liste d'après la requête `query`. Pour tester, validez que taper "s" va filtrer "Sushi", "Shish kebab", and "Dim sum".

<Hint>
  Il faudra remonter `query` et `handleChange`. Notez que `filterItems` est déjà
  correctement écrit.
</Hint>

<Sandpack>

```js
import { useState } from 'react';
import { foods, filterItems } from './data.js';

export default function FilterableList() {
  return (
    <>
      <SearchBar />
      <hr />
      <List items={foods} />
    </>
  );
}

function SearchBar() {
  const [query, setQuery] = useState('');

  function handleChange(e) {
    setQuery(e.target.value);
  }

  return (
    <label>
      Search: <input value={query} onChange={handleChange} />
    </label>
  );
}

function List({ items }) {
  return (
    <table>
      <tbody>
        {items.map((food) => (
          <tr key={food.id}>
            <td>{food.name}</td>
            <td>{food.description}</td>
          </tr>
        ))}
      </tbody>
    </table>
  );
}
```

```js src/data.js
export function filterItems(items, query) {
  query = query.toLowerCase();
  return items.filter((item) =>
    item.name.split(' ').some((word) => word.toLowerCase().startsWith(query))
  );
}

export const foods = [
  {
    id: 0,
    name: 'Sushi',
    description:
      'Sushi is a traditional Japanese dish of prepared vinegared rice',
  },
  {
    id: 1,
    name: 'Dal',
    description:
      'The most common way of preparing dal is in the form of a soup to which onions, tomatoes and various spices may be added',
  },
  {
    id: 2,
    name: 'Pierogi',
    description:
      'Pierogi are filled dumplings made by wrapping unleavened dough around a savoury or sweet filling and cooking in boiling water',
  },
  {
    id: 3,
    name: 'Shish kebab',
    description:
      'Shish kebab is a popular meal of skewered and grilled cubes of meat.',
  },
  {
    id: 4,
    name: 'Dim sum',
    description:
      'Dim sum is a large range of small dishes that Cantonese people traditionally enjoy in restaurants for breakfast and lunch',
  },
];
```

</Sandpack>

---

## Préserver et réinitialiser l'état

L'état est isolé entre les composants.

React conserve l'état de chaque composant d'après sa position dans l'arborescence.

Il est possible de controller quand conserver l'état et quand la réinitialiser pour chaque re-rendu.

---

## Contenu

- Comment React conserve et réinitialise l'état
- Comment forcer React à réinitialiser son état
- Comment la conservation de l'état est affecté par la clé et le type.

---

## L'état est lié à une position dans l'arborescence du rendu

React génère une arborescence du rendu pour la structure de vos composants.

Quand un composant possède un état, on pourrait croire que cet état est stocké dans le composant. Mais en fait, l'état est stocké par React.

React associe chaque état avec son compoosant dans l'arborescence, dépendant de sa position.

---

## Exemple

Dans cet exemple, il n'y a qu'une seule balise JSX `<Counter />`, mais la composante est rendue dans deux endroits différents de l'arborescence. Il y a donc deux états stockés.

<Sandpack>

```js
import { useState } from 'react';

export default function App() {
  const counter = <Counter />;
  return (
    <div>
      {counter}
      {counter}
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>Add one</button>
    </div>
  );
}
```

```css
label {
  display: block;
  clear: both;
}

.counter {
  width: 100px;
  text-align: center;
  border: 1px solid gray;
  border-radius: 4px;
  padding: 20px;
  margin: 0 20px 20px 0;
  float: left;
}

.hover {
  background: #ffffd8;
}
```

</Sandpack>

---

## Explications

Voici l'arborescence:

<Diagram name="preserving_state_tree" height={248} width={395} alt="Diagram of a tree of React components. The root node is labeled 'div' and has two children. Each of the children are labeled 'Counter' and both contain a state bubble labeled 'count' with value 0.">

React tree

</Diagram>

Ce sont deux compteurs indépendants, car chacun est rendu à sa propre position dans l'arborescence.

Chaque composant conserve son propre état isolé. Par exemple, chaque `Counter` possède son propre état `score` et `hover`.

---

## L'état des composants est isolé

Cliquez les deux compteurs, ils ne s'affectent pas l'un l'autre.

<Sandpack>

```js
import { useState } from 'react';

export default function App() {
  return (
    <div>
      <Counter />
      <Counter />
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>Add one</button>
    </div>
  );
}
```

```css
.counter {
  width: 100px;
  text-align: center;
  border: 1px solid gray;
  border-radius: 4px;
  padding: 20px;
  margin: 0 20px 20px 0;
  float: left;
}

.hover {
  background: #ffffd8;
}
```

</Sandpack>

---

## Explications

Quand un `Counter` est mis à jour, seul son état est affecté.

<Diagram name="preserving_state_increment" height={248} width={441} alt="Diagram of a tree of React components. The root node is labeled 'div' and has two children. The left child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The right child is labeled 'Counter' and contains a state bubble labeled 'count' with value 1. The state bubble of the right child is highlighted in yellow to indicate its value has updated.">

Updating state

</Diagram>

React conserve l'état tant que la composante est générée à la même position dans l'arborescence. Si un composant n'est plus rendu, l'état est éliminé.

---

## Perdre l'état en enlevant le composant

<Sandpack>

```js
import { useState } from 'react';

export default function App() {
  const [showB, setShowB] = useState(true);
  return (
    <div>
      <Counter />
      {showB && <Counter />}
      <label>
        <input
          type='checkbox'
          checked={showB}
          onChange={(e) => {
            setShowB(e.target.checked);
          }}
        />
        Render the second counter
      </label>
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>Add one</button>
    </div>
  );
}
```

```css
label {
  display: block;
  clear: both;
}

.counter {
  width: 100px;
  text-align: center;
  border: 1px solid gray;
  border-radius: 4px;
  padding: 20px;
  margin: 0 20px 20px 0;
  float: left;
}

.hover {
  background: #ffffd8;
}
```

</Sandpack>

Quand qu'on arrête le rendu du second compteur, son état disparait. Dès que que React enlève un composant, il enlève son état.

---

## Diagramme de perte de l'état

<aside style={{display:'grid', gridTemplateColumns:"1fr 1fr", columnGap:10}}>
<div>
<Diagram name="preserving_state_remove_component" height={253} width={422} alt="Diagram of a tree of React components. The root node is labeled 'div' and has two children. The left child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The right child is missing, and in its place is a yellow 'poof' image, highlighting the component being deleted from the tree.">

Deleting a component

</Diagram>

React conserve l'état d'un composant tant qu'il est rendu dans l'arborescence. Dès qu'il est enlevé (ou déplacé ailleurs), React perd l'état associé.

</div>
<div>
<Diagram name="preserving_state_add_component" height={258} width={500} alt="Diagram of a tree of React components. The root node is labeled 'div' and has two children. The left child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The right child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The entire right child node is highlighted in yellow, indicating that it was just added to the tree.">

Adding a component

</Diagram>

Quand on coche "Render the second counter", un nouveau `Counter` est créé, et son état est initialisé (`score = 0`).

</div>
</aside>

---

## Un même composant à la même position conserve l'état

Dans cet exemple, il y a deux balises `Counter`:

<Sandpack>

```js
import { useState } from 'react';

export default function App() {
  const [isFancy, setIsFancy] = useState(false);
  return (
    <div>
      {isFancy ? <Counter isFancy={true} /> : <Counter isFancy={false} />}
      <label>
        <input
          type='checkbox'
          checked={isFancy}
          onChange={(e) => {
            setIsFancy(e.target.checked);
          }}
        />
        Use fancy styling
      </label>
    </div>
  );
}

function Counter({ isFancy }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }
  if (isFancy) {
    className += ' fancy';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>Add one</button>
    </div>
  );
}
```

```css
label {
  display: block;
  clear: both;
}

.counter {
  width: 100px;
  text-align: center;
  border: 1px solid gray;
  border-radius: 4px;
  padding: 20px;
  margin: 0 20px 20px 0;
  float: left;
}

.fancy {
  border: 5px solid gold;
  color: #ff6767;
}

.hover {
  background: #ffffd8;
}
```

</Sandpack>

Quand on bascule le checkbox, le compteur n'est pas réinitialisé. Que `isFancy` soit à `true` ou `false`, c'est toujours un `<Counter>` qui est le premier enfant du `div`.

---

## Diagramme de la conservation

<Diagram name="preserving_state_same_component" height={461} width={600} alt="Diagram with two sections separated by an arrow transitioning between them. Each section contains a layout of components with a parent labeled 'App' containing a state bubble labeled isFancy. This component has one child labeled 'div', which leads to a prop bubble containing isFancy (highlighted in purple) passed down to the only child. The last child is labeled 'Counter' and contains a state bubble with label 'count' and value 3 in both diagrams. In the left section of the diagram, nothing is highlighted and the isFancy parent state value is false. In the right section of the diagram, the isFancy parent state value has changed to true and it is highlighted in yellow, and so is the props bubble below, which has also changed its isFancy value to true.">

Updating the `App` state does not reset the `Counter` because `Counter` stays in the same position

</Diagram>

C'est le même composant à la même position. Du point de vue de React, c'est donc le même compteur.

---

## Attention

C'est la position dans l'arborescence qui importe pour React, pas la position dans le JSX. Ce composant a deux `return` avec des `<Counter>` différents.

<Sandpack>

```js
import { useState } from 'react';

export default function App() {
  const [isFancy, setIsFancy] = useState(false);
  if (isFancy) {
    return (
      <div>
        <Counter isFancy={true} />
        <label>
          <input
            type='checkbox'
            checked={isFancy}
            onChange={(e) => {
              setIsFancy(e.target.checked);
            }}
          />
          Use fancy styling
        </label>
      </div>
    );
  }
  return (
    <div>
      <Counter isFancy={false} />
      <label>
        <input
          type='checkbox'
          checked={isFancy}
          onChange={(e) => {
            setIsFancy(e.target.checked);
          }}
        />
        Use fancy styling
      </label>
    </div>
  );
}

function Counter({ isFancy }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }
  if (isFancy) {
    className += ' fancy';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>Add one</button>
    </div>
  );
}
```

```css
label {
  display: block;
  clear: both;
}

.counter {
  width: 100px;
  text-align: center;
  border: 1px solid gray;
  border-radius: 4px;
  padding: 20px;
  margin: 0 20px 20px 0;
  float: left;
}

.fancy {
  border: 5px solid gold;
  color: #ff6767;
}

.hover {
  background: #ffffd8;
}
```

</Sandpack>

Parce que les deux `<Counter>` sont rendus à la même position, react conserve le state. React ne saisi pas que ces blocks ont été générés dans des blocs `if` séparés.

---

## Différents composants à la même position réinitialisent l'état

Dans cet exemple, cliquer la boîte d'option remplace le `<Counter>` par un `<p>`:

<Sandpack>

```js
import { useState } from 'react';

export default function App() {
  const [isPaused, setIsPaused] = useState(false);
  return (
    <div>
      {isPaused ? <p>See you later!</p> : <Counter />}
      <label>
        <input
          type='checkbox'
          checked={isPaused}
          onChange={(e) => {
            setIsPaused(e.target.checked);
          }}
        />
        Take a break
      </label>
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>Add one</button>
    </div>
  );
}
```

```css
label {
  display: block;
  clear: both;
}

.counter {
  width: 100px;
  text-align: center;
  border: 1px solid gray;
  border-radius: 4px;
  padding: 20px;
  margin: 0 20px 20px 0;
  float: left;
}

.hover {
  background: #ffffd8;
}
```

</Sandpack>

Ici, on bascule entre différents types de composants à la même position. Le premier enfant du `<div>` passe de `<Counter>` à `<p>`, ce qui entraine la perte de l'état du compteur.

---

## Diagramme du changement du type de composant

<Diagram name="preserving_state_diff_pt1" height={250} width={690} alt="Diagram with three sections, with an arrow transitioning each section in between. The first section contains a React component labeled 'div' with a single child labeled 'Counter' containing a state bubble labeled 'count' with value 3. The middle section has the same 'div' parent, but the child component has now been deleted, indicated by a yellow 'proof' image. The third section has the same 'div' parent again, now with a new child labeled 'p', highlighted in yellow.">

Quand `Counter` change vers `p`, le `Counter` est effacé et `p` est ajouté

</Diagram>

<Diagram name="preserving_state_diff_pt2" height={290} width={753} alt="Diagram with three sections, with an arrow transitioning each section in between. The first section contains a React component labeled 'p'. The middle section has the same 'div' parent, but the child component has now been deleted, indicated by a yellow 'proof' image. The third section has the same 'div' parent again, now with a new child labeled 'Counter' containing a state bubble labeled 'count' with value 0, highlighted in yellow.">

When switching back, the `p` is deleted and the `Counter` is added

</Diagram>

---

## Regénérer la sous-arborescence

Quand on génère le rendu d'un composant différent à la même position, cela réinitialise aussi tous les enfants de la sous-arborescence

<Sandpack>

```js
import { useState } from 'react';

export default function App() {
  const [isFancy, setIsFancy] = useState(false);
  return (
    <div>
      {isFancy ? (
        <div>
          <Counter isFancy={true} />
        </div>
      ) : (
        <section>
          <Counter isFancy={false} />
        </section>
      )}
      <label>
        <input
          type='checkbox'
          checked={isFancy}
          onChange={(e) => {
            setIsFancy(e.target.checked);
          }}
        />
        Use fancy styling
      </label>
    </div>
  );
}

function Counter({ isFancy }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }
  if (isFancy) {
    className += ' fancy';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>Add one</button>
    </div>
  );
}
```

```css
label {
  display: block;
  clear: both;
}

.counter {
  width: 100px;
  text-align: center;
  border: 1px solid gray;
  border-radius: 4px;
  padding: 20px;
  margin: 0 20px 20px 0;
  float: left;
}

.fancy {
  border: 5px solid gold;
  color: #ff6767;
}

.hover {
  background: #ffffd8;
}
```

</Sandpack>

L'état de `Counter` est réinitialisé quand on clique la case à cocher. Quand on change du `div` à une `section`, les enfants de l'arborescence en dessous sont détruits aussi.

---

## Diagramme de la génération de la sous-arborescence

<aside style={{display:'grid', gridTemplateColumns:"1fr 1fr", columnGap:10}}>

<div>

<Diagram name="preserving_state_diff_same_pt1" height={280} width={660} alt=
"Diagram with three sections, with an arrow transitioning each section in between. The first section contains a React component labeled 'div' with a single child labeled 'section', which has a single child labeled 'Counter' containing a state bubble labeled 'count' with value 3. The middle section has the same 'div' parent, but the child components have now been deleted, indicated by a yellow 'proof' image. The third section has the same 'div' parent again, now with a new child labeled 'div', highlighted in yellow, also with a new child labeled 'Counter' containing a state bubble labeled 'count' with value 0, all highlighted in yellow."
>

When `section` changes to `div`, the `section` is deleted and the new `div` is added

</Diagram>

<Diagram name="preserving_state_diff_same_pt2" height={280} width={660} alt="Diagram with three sections, with an arrow transitioning each section in between. The first section contains a React component labeled 'div' with a single child labeled 'div', which has a single child labeled 'Counter' containing a state bubble labeled 'count' with value 0. The middle section has the same 'div' parent, but the child components have now been deleted, indicated by a yellow 'proof' image. The third section has the same 'div' parent again, now with a new child labeled 'section', highlighted in yellow, also with a new child labeled 'Counter' containing a state bubble labeled 'count' with value 0, all highlighted in yellow.">

When switching back, the `div` is deleted and the new `section` is added

</Diagram>
</div>
En général, **pour conserver les états entre les re-rendus, la structure de l'arboresence doit correspondre** d'un rendu à l'autre. Si la structure est différente, l'état est perdu quand React détruit un composant de l'arborescence

</aside >

---

## Ne pas imbriquer des composants

Ici, le composant `MyTextField` est défini _dans_ `MyComponent`:

<Sandpack>

```js
import { useState } from 'react';

export default function MyComponent() {
  const [counter, setCounter] = useState(0);

  function MyTextField() {
    const [text, setText] = useState('');

    return <input value={text} onChange={(e) => setText(e.target.value)} />;
  }

  return (
    <>
      <MyTextField />
      <button
        onClick={() => {
          setCounter(counter + 1);
        }}
      >
        Clicked {counter} times
      </button>
    </>
  );
}
```

</Sandpack>

Chaque fois qu'on clique le bouton, la valeur du champ est perdue. C'est qu'une nouvelle fonction `MyTextField` est créée à chaque rendu de `MyComponent`. Parce que c'est un nouveau composant à la même position, on perd l'état. Ceci entraine des bogues et des problèmes de performances.

Pour éviter ce problème, **déclarez vos composants au top niveau, sans imbriquer dans des fonctions**.

---

## Réinitialiser l'état à la même position

React conserve l'état d'un composant lorsqu'il reste à la même position. Que faire si on veut réinitaliser l'état?
Considérons une app qui conserve le pointage:

<Sandpack>

```js
import { useState } from 'react';

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA ? <Counter person='Taylor' /> : <Counter person='Sarah' />}
      <button
        onClick={() => {
          setIsPlayerA(!isPlayerA);
        }}
      >
        Next player!
      </button>
    </div>
  );
}

function Counter({ person }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>
        {person}'s score: {score}
      </h1>
      <button onClick={() => setScore(score + 1)}>Add one</button>
    </div>
  );
}
```

```css
h1 {
  font-size: 18px;
}

.counter {
  width: 100px;
  text-align: center;
  border: 1px solid gray;
  border-radius: 4px;
  padding: 20px;
  margin: 0 20px 20px 0;
}

.hover {
  background: #ffffd8;
}
```

</Sandpack>

Présentement, quand on change de joueur, le pointage est conservé. Les deux `Counter` apparaissent à la même position, donc React considère que c'est le même `Counter`, avec une prop `person` différente.

Mais ça ne devrait pas être le cas. Il y a deux joueurs, donc deux pointages différents.

---

## Solutions pour réinitialiser un composant

Il y a deux approches pour réinitialiser l'étate entre les deux joueurs:

1. Afficher les composants dans des positions différentes
2. Offrir un identité explicite au composant avec `key`

---

## Approche 1: Afficher les composants dans des positions différentes

Si on désire que les 2 `Counter` soient indépendants, on pourrait faire le rendu dans deux position différentes:

<Sandpack>

```js
import { useState } from 'react';

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA && <Counter person='Taylor' />}
      {!isPlayerA && <Counter person='Sarah' />}
      <button
        onClick={() => {
          setIsPlayerA(!isPlayerA);
        }}
      >
        Next player!
      </button>
    </div>
  );
}

function Counter({ person }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>
        {person}'s score: {score}
      </h1>
      <button onClick={() => setScore(score + 1)}>Add one</button>
    </div>
  );
}
```

```css
h1 {
  font-size: 18px;
}

.counter {
  width: 100px;
  text-align: center;
  border: 1px solid gray;
  border-radius: 4px;
  padding: 20px;
  margin: 0 20px 20px 0;
}

.hover {
  background: #ffffd8;
}
```

</Sandpack>

- Au départ, `isPlayerA` est `true`. La première position contient `Counter`, et la seconde est vide.
- Quand on clique "Next player", la première position est vidée, et on ajoute un `Counter` à la seconde position.

---

## Détails du positionnement

<aside style={{display:'grid', gridTemplateColumns:"1fr 1fr 1fr", columnGap:10}}>

<Diagram name="preserving_state_diff_position_p1" height={250} width={350} alt="Diagram with a tree of React components. The parent is labeled 'Scoreboard' with a state bubble labeled isPlayerA with value 'true'. The only child, arranged to the left, is labeled Counter with a state bubble labeled 'count' and value 0. All of the left child is highlighted in yellow, indicating it was added.">

Initial state

</Diagram>

<Diagram name="preserving_state_diff_position_p2" height={250} width={350} alt="Diagram with a tree of React components. The parent is labeled 'Scoreboard' with a state bubble labeled isPlayerA with value 'false'. The state bubble is highlighted in yellow, indicating that it has changed. The left child is replaced with a yellow 'poof' image indicating that it has been deleted and there is a new child on the right, highlighted in yellow indicating that it was added. The new child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0.">

Clicking "next"

</Diagram>

<Diagram name="preserving_state_diff_position_p3" height={250} width={350} alt="Diagram with a tree of React components. The parent is labeled 'Scoreboard' with a state bubble labeled isPlayerA with value 'true'. The state bubble is highlighted in yellow, indicating that it has changed. There is a new child on the left, highlighted in yellow indicating that it was added. The new child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The right child is replaced with a yellow 'poof' image indicating that it has been deleted.">

Clicking "next" again

</Diagram>

</aside >

Chaque état du `Counter` se fait détruire chaque fois qu'il est retiré. C'est pourquoi cela réinitialise chaque fois que l'on clique le bouton,

Cette solution est pratique quand on a quelques composants indépendants à afficher.

---

### Approche 2: Réinitialiser l'état avec une `key`

Il y a une autre façon, plus générique, de réinitialiser l'état d'un composant.

Les clés (keys) sont utiles pour le rendu de listes. Mais les clés ne sont pas seulement pour les listes. On peut utiliser des clés pour que React distingue entre les composants. Par défaut, React utilise le positionnement pour distinguer entre les composants. Mais les clés permettent plus. Plutôt que de distinguer entre le Counter de la première position et de la seconde position, on peut maintenant spécifier le counter dans la clé. Par exemple, la clé de _Justin_.

---

## Exemple avec `key`

Dans cet exemple, les deux `<Counter />` ne partagent pas d'état, même s'ils ont la même position:

<Sandpack>

```js
import { useState } from 'react';

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA ? (
        <Counter key='Taylor' person='Taylor' />
      ) : (
        <Counter key='Sarah' person='Sarah' />
      )}
      <button
        onClick={() => {
          setIsPlayerA(!isPlayerA);
        }}
      >
        Next player!
      </button>
    </div>
  );
}

function Counter({ person }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>
        {person}'s score: {score}
      </h1>
      <button onClick={() => setScore(score + 1)}>Add one</button>
    </div>
  );
}
```

```css
h1 {
  font-size: 18px;
}

.counter {
  width: 100px;
  text-align: center;
  border: 1px solid gray;
  border-radius: 4px;
  padding: 20px;
  margin: 0 20px 20px 0;
}

.hover {
  background: #ffffd8;
}
```

</Sandpack>

---

## Détails sur `key`

Basculer entre les joueurs ne conserve pas l'état, car la clé `key` est différente

```js
{
  isPlayerA ? (
    <Counter key='Taylor' person='Taylor' />
  ) : (
    <Counter key='Sarah' person='Sarah' />
  );
}
```

Spécifier une clé indique à React d'utiliser la clé comme une partie de la position du composant. Quand la clé change, c'est comme une nouvelle position, et React créé un nouvel état (et perd l'ancien état du composant détruit).

**Les clés n'ont pas besoin d'être globalement uniques. Elles doivent seulement spécifier la position _sous le parent_.**

---

## Réinitialiser un fomulaire avec une clé

Réinitialiser l'état avec un clé est très pratique avec les formulaire

Dans cette application, le composant `<Chat>` contient un champ de saisie controllé par l'état:

<Sandpack>

```js src/App.js
import { useState } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';

export default function Messenger() {
  const [to, setTo] = useState(contacts[0]);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedContact={to}
        onSelect={(contact) => setTo(contact)}
      />
      <Chat contact={to} />
    </div>
  );
}

const contacts = [
  { id: 0, name: 'Taylor', email: 'taylor@mail.com' },
  { id: 1, name: 'Alice', email: 'alice@mail.com' },
  { id: 2, name: 'Bob', email: 'bob@mail.com' },
];
```

```js src/ContactList.js
export default function ContactList({ selectedContact, contacts, onSelect }) {
  return (
    <section className='contact-list'>
      <ul>
        {contacts.map((contact) => (
          <li key={contact.id}>
            <button
              onClick={() => {
                onSelect(contact);
              }}
            >
              {contact.name}
            </button>
          </li>
        ))}
      </ul>
    </section>
  );
}
```

```js src/Chat.js
import { useState } from 'react';

export default function Chat({ contact }) {
  const [text, setText] = useState('');
  return (
    <section className='chat'>
      <textarea
        value={text}
        placeholder={'Chat to ' + contact.name}
        onChange={(e) => setText(e.target.value)}
      />
      <br />
      <button>Send to {contact.email}</button>
    </section>
  );
}
```

```css
.chat,
.contact-list {
  float: left;
  margin-bottom: 20px;
}
ul,
li {
  list-style: none;
  margin: 0;
  padding: 0;
}
li button {
  width: 100px;
  padding: 10px;
  margin-right: 10px;
}
textarea {
  height: 150px;
}
```

</Sandpack>

Mais il y a un bogue: si on change de destinataire, la valeur dans le formulaire est conservée.

---

## Réparer le bogue avec une clé

```js
<Chat key={to.id} contact={to} />
```

Ceci réinitialise l'état du `<Chat>`. Le re-rendu génère le composant `<Chat>` et toute l'arborescence en dessous.

<Sandpack>

```js src/App.js
import { useState } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';

export default function Messenger() {
  const [to, setTo] = useState(contacts[0]);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedContact={to}
        onSelect={(contact) => setTo(contact)}
      />
      <Chat key={to.id} contact={to} />
    </div>
  );
}

const contacts = [
  { id: 0, name: 'Taylor', email: 'taylor@mail.com' },
  { id: 1, name: 'Alice', email: 'alice@mail.com' },
  { id: 2, name: 'Bob', email: 'bob@mail.com' },
];
```

```js src/ContactList.js
export default function ContactList({ selectedContact, contacts, onSelect }) {
  return (
    <section className='contact-list'>
      <ul>
        {contacts.map((contact) => (
          <li key={contact.id}>
            <button
              onClick={() => {
                onSelect(contact);
              }}
            >
              {contact.name}
            </button>
          </li>
        ))}
      </ul>
    </section>
  );
}
```

```js src/Chat.js
import { useState } from 'react';

export default function Chat({ contact }) {
  const [text, setText] = useState('');
  return (
    <section className='chat'>
      <textarea
        value={text}
        placeholder={'Chat to ' + contact.name}
        onChange={(e) => setText(e.target.value)}
      />
      <br />
      <button>Send to {contact.email}</button>
    </section>
  );
}
```

```css
.chat,
.contact-list {
  float: left;
  margin-bottom: 20px;
}
ul,
li {
  list-style: none;
  margin: 0;
  padding: 0;
}
li button {
  width: 100px;
  padding: 10px;
  margin-right: 10px;
}
textarea {
  height: 150px;
}
```

</Sandpack>

---

## Conserver l'état pour les composants enlevés

Comment conserver l'état pour une composante qui n'est plus visible?

- On fait un rendu de tous les `<Chat>`, on cache ceux-ci via CSS, sauf celui sélectionné. Les `<chat>` ne sont pas enlevés de l'arborescence, donc leur état local sera préservé. Cette solution fonctionne bien pour une petite interface, mais devient lourde avec une app plus complexe.
- On prourrait remonter l'état et conserver le message de chaque destinataire dans la composante parent. Quand les composants enfants sont détruits, l'état n'est pas impacté car il est stocké dans le parent. C'est la solution la plus commune.
- On pourrait stocker les données ailleurs, en plus du state. Par exemple, stocker dans le localStorage du navigateur.

---

## Résumé

- React keeps state for as long as the same component is rendered at the same position.
- State is not kept in JSX tags. It's associated with the tree position in which you put that JSX.
- You can force a subtree to reset its state by giving it a different key.
- Don't nest component definitions, or you'll reset state by accident.

---

## Défi: Réparer les champs de saisie

Cet exemple affiche un message quand on clique le bouton. Mais, cela réinitialise aussi le champ de saisie. Réparez pour que le bouton ne réinitialise pas le champ de saisie.

<Sandpack>

```js src/App.js
import { useState } from 'react';

export default function App() {
  const [showHint, setShowHint] = useState(false);
  if (showHint) {
    return (
      <div>
        <p>
          <i>Hint: Your favorite city?</i>
        </p>
        <Form />
        <button
          onClick={() => {
            setShowHint(false);
          }}
        >
          Hide hint
        </button>
      </div>
    );
  }
  return (
    <div>
      <Form />
      <button
        onClick={() => {
          setShowHint(true);
        }}
      >
        Show hint
      </button>
    </div>
  );
}

function Form() {
  const [text, setText] = useState('');
  return <textarea value={text} onChange={(e) => setText(e.target.value)} />;
}
```

```css
textarea {
  display: block;
  margin: 10px 0;
}
```

</Sandpack>

---

## Défi: Basculer entre deux champs de saisie

This form lets you enter first and last name. It also has a checkbox controlling which field goes first. When you tick the checkbox, the "Last name" field will appear before the "First name" field.

It almost works, but there is a bug. If you fill in the "First name" input and tick the checkbox, the text will stay in the first input (which is now "Last name"). Fix it so that the input text _also_ moves when you reverse the order.

<Hint>
  It seems like for these fields, their position within the parent is not
  enough. Is there some way to tell React how to match up the state between
  re-renders?
</Hint>

<Sandpack>

```js src/App.js
import { useState } from 'react';

export default function App() {
  const [reverse, setReverse] = useState(false);
  let checkbox = (
    <label>
      <input
        type='checkbox'
        checked={reverse}
        onChange={(e) => setReverse(e.target.checked)}
      />
      Reverse order
    </label>
  );
  if (reverse) {
    return (
      <>
        <Field label='Last name' />
        <Field label='First name' />
        {checkbox}
      </>
    );
  } else {
    return (
      <>
        <Field label='First name' />
        <Field label='Last name' />
        {checkbox}
      </>
    );
  }
}

function Field({ label }) {
  const [text, setText] = useState('');
  return (
    <label>
      {label}:{' '}
      <input
        type='text'
        value={text}
        placeholder={label}
        onChange={(e) => setText(e.target.value)}
      />
    </label>
  );
}
```

```css
label {
  display: block;
  margin: 10px 0;
}
```

</Sandpack>

---

## Défi: Réinitialiser un formulaire de détails

This is an editable contact list. You can edit the selected contact's details and then either press "Save" to update it, or "Reset" to undo your changes.

When you select a different contact (for example, Alice), the state updates but the form keeps showing the previous contact's details. Fix it so that the form gets reset when the selected contact changes.

<Sandpack>

```js src/App.js
import { useState } from 'react';
import ContactList from './ContactList.js';
import EditContact from './EditContact.js';

export default function ContactManager() {
  const [contacts, setContacts] = useState(initialContacts);
  const [selectedId, setSelectedId] = useState(0);
  const selectedContact = contacts.find((c) => c.id === selectedId);

  function handleSave(updatedData) {
    const nextContacts = contacts.map((c) => {
      if (c.id === updatedData.id) {
        return updatedData;
      } else {
        return c;
      }
    });
    setContacts(nextContacts);
  }

  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedId={selectedId}
        onSelect={(id) => setSelectedId(id)}
      />
      <hr />
      <EditContact initialData={selectedContact} onSave={handleSave} />
    </div>
  );
}

const initialContacts = [
  { id: 0, name: 'Taylor', email: 'taylor@mail.com' },
  { id: 1, name: 'Alice', email: 'alice@mail.com' },
  { id: 2, name: 'Bob', email: 'bob@mail.com' },
];
```

```js src/ContactList.js
export default function ContactList({ contacts, selectedId, onSelect }) {
  return (
    <section>
      <ul>
        {contacts.map((contact) => (
          <li key={contact.id}>
            <button
              onClick={() => {
                onSelect(contact.id);
              }}
            >
              {contact.id === selectedId ? <b>{contact.name}</b> : contact.name}
            </button>
          </li>
        ))}
      </ul>
    </section>
  );
}
```

```js src/EditContact.js
import { useState } from 'react';

export default function EditContact({ initialData, onSave }) {
  const [name, setName] = useState(initialData.name);
  const [email, setEmail] = useState(initialData.email);
  return (
    <section>
      <label>
        Name:{' '}
        <input
          type='text'
          value={name}
          onChange={(e) => setName(e.target.value)}
        />
      </label>
      <label>
        Email:{' '}
        <input
          type='email'
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
      </label>
      <button
        onClick={() => {
          const updatedData = {
            id: initialData.id,
            name: name,
            email: email,
          };
          onSave(updatedData);
        }}
      >
        Save
      </button>
      <button
        onClick={() => {
          setName(initialData.name);
          setEmail(initialData.email);
        }}
      >
        Reset
      </button>
    </section>
  );
}
```

```css
ul,
li {
  list-style: none;
  margin: 0;
  padding: 0;
}
li {
  display: inline-block;
}
li button {
  padding: 10px;
}
label {
  display: block;
  margin: 10px 0;
}
button {
  margin-right: 10px;
  margin-bottom: 10px;
}
```

</Sandpack>

---

## Défi: Effacer une image pendant qu'elle charge

When you press "Next", the browser starts loading the next image. However, because it's displayed in the same `<img>` tag, by default you would still see the previous image until the next one loads. This may be undesirable if it's important for the text to always match the image. Change it so that the moment you press "Next", the previous image immediately clears.

<Hint>
  Is there a way to tell React to re-create the DOM instead of reusing it?
</Hint>

<Sandpack>

```js
import { useState } from 'react';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const hasNext = index < images.length - 1;

  function handleClick() {
    if (hasNext) {
      setIndex(index + 1);
    } else {
      setIndex(0);
    }
  }

  let image = images[index];
  return (
    <>
      <button onClick={handleClick}>Next</button>
      <h3>
        Image {index + 1} of {images.length}
      </h3>
      <img src={image.src} />
      <p>{image.place}</p>
    </>
  );
}

let images = [
  {
    place: 'Penang, Malaysia',
    src: 'https://i.imgur.com/FJeJR8M.jpg',
  },
  {
    place: 'Lisbon, Portugal',
    src: 'https://i.imgur.com/dB2LRbj.jpg',
  },
  {
    place: 'Bilbao, Spain',
    src: 'https://i.imgur.com/z08o2TS.jpg',
  },
  {
    place: 'Valparaíso, Chile',
    src: 'https://i.imgur.com/Y3utgTi.jpg',
  },
  {
    place: 'Schwyz, Switzerland',
    src: 'https://i.imgur.com/JBbMpWY.jpg',
  },
  {
    place: 'Prague, Czechia',
    src: 'https://i.imgur.com/QwUKKmF.jpg',
  },
  {
    place: 'Ljubljana, Slovenia',
    src: 'https://i.imgur.com/3aIiwfm.jpg',
  },
];
```

```css
img {
  width: 150px;
  height: 150px;
}
```

</Sandpack>

---

## Défi: Réparer un état mal positionné

In this list, each `Contact` has state that determines whether "Show email" has been pressed for it. Press "Show email" for Alice, and then tick the "Show in reverse order" checkbox. You will notice that it's _Taylor's_ email that is expanded now, but Alice's--which has moved to the bottom--appears collapsed.

Fix it so that the expanded state is associated with each contact, regardless of the chosen ordering.

<Sandpack>

```js src/App.js
import { useState } from 'react';
import Contact from './Contact.js';

export default function ContactList() {
  const [reverse, setReverse] = useState(false);

  const displayedContacts = [...contacts];
  if (reverse) {
    displayedContacts.reverse();
  }

  return (
    <>
      <label>
        <input
          type='checkbox'
          value={reverse}
          onChange={(e) => {
            setReverse(e.target.checked);
          }}
        />{' '}
        Show in reverse order
      </label>
      <ul>
        {displayedContacts.map((contact, i) => (
          <li key={i}>
            <Contact contact={contact} />
          </li>
        ))}
      </ul>
    </>
  );
}

const contacts = [
  { id: 0, name: 'Alice', email: 'alice@mail.com' },
  { id: 1, name: 'Bob', email: 'bob@mail.com' },
  { id: 2, name: 'Taylor', email: 'taylor@mail.com' },
];
```

```js src/Contact.js
import { useState } from 'react';

export default function Contact({ contact }) {
  const [expanded, setExpanded] = useState(false);
  return (
    <>
      <p>
        <b>{contact.name}</b>
      </p>
      {expanded && (
        <p>
          <i>{contact.email}</i>
        </p>
      )}
      <button
        onClick={() => {
          setExpanded(!expanded);
        }}
      >
        {expanded ? 'Hide' : 'Show'} email
      </button>
    </>
  );
}
```

```css
ul,
li {
  list-style: none;
  margin: 0;
  padding: 0;
}
li {
  margin-bottom: 20px;
}
label {
  display: block;
  margin: 10px 0;
}
button {
  margin-right: 10px;
  margin-bottom: 10px;
}
```

</Sandpack>

---

## Extraire la logique d'état dans un réducteur

Les composants avec des mises à jour éparpillées à travers de multiples gestionnaires d'événements, ça devient complexe. Dans ces cas, on peut consoloider toute la logique de mise à jour à l'extérieur du composant, dans une seule fonction appelée le **réducteur**.

---

## Concepts

- Qu'est-ce qu'une fonction de réducteur
- Comment refactoriser `useState` vers `useReducer`
- Quand utiliser un réducteur
- Comment écrire un bon réducteur

---

## La logique d'état peut devenir complexe

Dans l'exemple suivant, le composant `TaskApp` contient, dans son état, un tableau de `tasks`. Il y a 3 gestionnaires d'événements pour ajouter, enlever et modifier les `tasks`:

<Sandpack>

```js src/App.js
import { useState } from 'react';
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';

export default function TaskApp() {
  const [tasks, setTasks] = useState(initialTasks);

  function handleAddTask(text) {
    setTasks([
      ...tasks,
      {
        id: nextId++,
        text: text,
        done: false,
      },
    ]);
  }

  function handleChangeTask(task) {
    setTasks(
      tasks.map((t) => {
        if (t.id === task.id) {
          return task;
        } else {
          return t;
        }
      })
    );
  }

  function handleDeleteTask(taskId) {
    setTasks(tasks.filter((t) => t.id !== taskId));
  }

  return (
    <>
      <h1>Prague itinerary</h1>
      <AddTask onAddTask={handleAddTask} />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}

let nextId = 3;
const initialTasks = [
  { id: 0, text: 'Visit Kafka Museum', done: true },
  { id: 1, text: 'Watch a puppet show', done: false },
  { id: 2, text: 'Lennon Wall pic', done: false },
];
```

```js src/AddTask.js hidden
import { useState } from 'react';

export default function AddTask({ onAddTask }) {
  const [text, setText] = useState('');
  return (
    <>
      <input
        placeholder='Add task'
        value={text}
        onChange={(e) => setText(e.target.value)}
      />
      <button
        onClick={() => {
          setText('');
          onAddTask(text);
        }}
      >
        Add
      </button>
    </>
  );
}
```

```js src/TaskList.js hidden
import { useState } from 'react';

export default function TaskList({ tasks, onChangeTask, onDeleteTask }) {
  return (
    <ul>
      {tasks.map((task) => (
        <li key={task.id}>
          <Task task={task} onChange={onChangeTask} onDelete={onDeleteTask} />
        </li>
      ))}
    </ul>
  );
}

function Task({ task, onChange, onDelete }) {
  const [isEditing, setIsEditing] = useState(false);
  let taskContent;
  if (isEditing) {
    taskContent = (
      <>
        <input
          value={task.text}
          onChange={(e) => {
            onChange({
              ...task,
              text: e.target.value,
            });
          }}
        />
        <button onClick={() => setIsEditing(false)}>Save</button>
      </>
    );
  } else {
    taskContent = (
      <>
        {task.text}
        <button onClick={() => setIsEditing(true)}>Edit</button>
      </>
    );
  }
  return (
    <label>
      <input
        type='checkbox'
        checked={task.done}
        onChange={(e) => {
          onChange({
            ...task,
            done: e.target.checked,
          });
        }}
      />
      {taskContent}
      <button onClick={() => onDelete(task.id)}>Delete</button>
    </label>
  );
}
```

```css
button {
  margin: 5px;
}
li {
  list-style-type: none;
}
ul,
li {
  margin: 0;
  padding: 0;
}
```

</Sandpack>

Chacun des gestionnaires d'événements appelle `setTasks` dans le but de mettre à jour l'état. À mesure que le composant évolue, la complexité de la logique d'état se complexifie aussi.

---

## Consolider la logique d'état avec un réducteur

Pour réduire la complexité et conserver toute la logique dans un seul endroit facile à maintenir, on doit déplacer toute cette logique dans une seule fonction à l'extérieur du composant. Ça se nomme un **réducteur**.

Les réducteurs sont une façon différente de gérer l'état. On peut migrer de useState à useReducer en 3 étapes:

1. **Passer** de l'écriture d'état au dispatch d'actions
2. **Écrire** la fonction du réducteur
3. **Utiliser** le reducteur du composant

---

## Étape 1: Passer de l'écriture d'état au dispatch d'actions

Les gestionnaires d'événements spécifient comment modifier l'état:

<aside style={{display:'grid', gridTemplateColumns:"1fr 1fr", columnGap:10, fontSize:"0.8em"}}>
```js
function handleAddTask(text) {
  setTasks([
    ...tasks,
    {
      id: nextId++,
      text: text,
      done: false,
    },
  ]);
}

````

```js
function handleChangeTask(task) {
  setTasks(
    tasks.map((t) => {
      if (t.id === task.id) {
        return task;
      } else {
        return t;
      }
    })
  );
}
````

</aside>

```js
function handleDeleteTask(taskId) {
  setTasks(tasks.filter((t) => t.id !== taskId));
}
```

---

## Description des gestionnaires d'événements

- `handleAddTask(text)` est appelée quand on clique "Add".
- `handleChangeTask(task)` est appelée quand on tape la case à cocher, ou le bouton "Save".
- `handleDeleteTask(taskId)` est appelée quant on clique "Delete".

Gérer l'état avec un réducteur est légèrement différent de le gérer en modifiant l'état. Plutôt que de dire comment modifier l'état, on décrit "ce que l'utilisateur désire" en faisant un _dispatch_ d'action dans le gestionnaire d'événement. pltôt que de modifier les `tasks`dans le gestionnaire d'événement, on _dispatch_ une action "ajouter/changer/enlever une tâche". L'intention est plus claire.

---

## Code

L'objet passé à `dispatch` est une "action".

<aside style={{display:'grid', gridTemplateColumns:"1fr 1fr", columnGap:10}}>

```js
function handleAddTask(text) {
  dispatch({
    type: 'added',
    id: nextId++,
    text: text,
  });
}
```

```js
function handleChangeTask(task) {
  dispatch({
    type: 'changed',
    task: task,
  });
}

function handleDeleteTask(taskId) {
  dispatch({
    type: 'deleted',
    id: taskId,
  });
}
```

</aside>

---

## Action

Une action est un objet JavaScript. La structure de l'action n'est pas spécifique, elledécrit l'information miminale de ce qui change.

**note:** L'objet action n'a pas de forme précise.

Par convention, on lui donne un `type` qui décrit le type de modification, et les autres champs décrivent les détails de la modification.

```js
dispatch({
  // specific to component
  type: 'what_happened',
  // other fields go here
});
```

---

### Étape 2: Écrire la fonction réducteur

C'est dans la fonction reducteur que l'on place la logique d'état. Il y a deux arguments: l'état courant et l'objet action. Cela retourne l'état suivant.

```js
function yourReducer(state, action) {
  // return next state for React to set
}
```

React conserve l'état de ce qui est retourné du réducteur

Dans notre exemple:

1. Déclarer l'état courant (`tasks`) comme premier argument
2. Déclarer l'objet `action` comme second argment
3. Retourner le prochain état du réducteur (que React conserve)

---

## Fonction réducteur

<aside style={{display:'grid', gridTemplateColumns:"1fr 1fr", columnGap:10, fontSize:'0.8em'}}>

```js
function tasksReducer(tasks, action) {
  if (action.type === 'added') {
    return [
      ...tasks,
      {
        id: action.id,
        text: action.text,
        done: false,
      },
    ];
  } else if (action.type === 'deleted') {
    return tasks.filter((t) => t.id !== action.id);
  }

```

```js
  //...
  else if (action.type === 'changed') {
    return tasks.map((t) => {
      if (t.id === action.task.id) {
        return action.task;
      } else {
        return t;
      }
    });
  } else {
    throw Error('Unknown action: ' + action.type);
  }
}
```

</aside>

Parce que le réducteur prend l'état en argument, on peut le déclarer à l'extérieur du composant. C'est plus facile à lire et maintenir

---

## Convention du switch

Le code précédent utilise `if/else`, mais la convention, c'est d'utiliser le `switch`.

<aside style={{display:'grid', gridTemplateColumns:"1fr 1fr", columnGap:10, fontSize:"0.8em"}}>

```js
function tasksReducer(tasks, action) {
  switch (action.type) {
    case 'added': {
      return [
        ...tasks,
        {
          id: action.id,
          text: action.text,
          done: false,
        },
      ];
    }
    case 'deleted': {
      return tasks.filter((t) => t.id !== action.id);
    }
```

```js
    case 'changed': {
      return tasks.map((t) => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```

</aside>

On recommande d'englober chaque block case entre des accolades `{` et `}` pour que les variables des blocs soient isolées les unes des autres. De plus, chaque `case` se termine par `return` (ou `break`). Si on oublie le `return`, le code continue au prochain `case`, ce qui est une erreur.

---

## Pourquoi on appelle cela un réducteur?

C'est à cause de l'opération `reduce()` des tableaux JS.

L'opération `reduce()` permet de prendre un tableau et d'"accumuler" une valeur unique à partir de l'ensemble.

```js
const arr = [1, 2, 3, 4, 5];
const sum = arr.reduce((result, number) => result + number); // 1 + 2 + 3 + 4 + 5
```

La fonction passée à `reduce` est le "réducteur". Cela prend deux arguments: le _résultat accumulé_ jusqu'à maintenant, et _l'item courant_. On retourne retourne le nouveau résultat accumulé.

Le réducteur React est similaire: on prend deux aguments _l'état précédent_, et _l'action_. On retourne le nouvel _état suivant_.

---

## Exemple avec reduce (sans React)

On appelle `reduce()` avec un `initialState` et un tableau d'`actions` pour calculer l'état final, en passant la fonction du réducteur.

<Sandpack>

```js src/index.js active
import tasksReducer from './tasksReducer.js';

let initialState = [];
let actions = [
  { type: 'added', id: 1, text: 'Visit Kafka Museum' },
  { type: 'added', id: 2, text: 'Watch a puppet show' },
  { type: 'deleted', id: 1 },
  { type: 'added', id: 3, text: 'Lennon Wall pic' },
];

let finalState = actions.reduce(tasksReducer, initialState);

const output = document.getElementById('output');
output.textContent = JSON.stringify(finalState, null, 2);
```

```js src/tasksReducer.js
export default function tasksReducer(tasks, action) {
  switch (action.type) {
    case 'added': {
      return [
        ...tasks,
        {
          id: action.id,
          text: action.text,
          done: false,
        },
      ];
    }
    case 'changed': {
      return tasks.map((t) => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case 'deleted': {
      return tasks.filter((t) => t.id !== action.id);
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```

```html public/index.html
<pre id="output"></pre>
```

</Sandpack>

Pas besoin de React pour utiliser un réducteur.

---

## Étape 3: Utiliser le réducteur de votre composant

Importez le hook `useReducer` de React:

```js
import { useReducer } from 'react';
```

On doit remplacer `useState`:

```js
const [tasks, setTasks] = useState(initialTasks);
```

par `useReducer`:

```js
const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
```

---

## Détails de useReducer

Le Hook `useReducer` est similaire à `useState`.

On passe une valeur initiale, on reçoit la valeur de l'état, et une fonction pour modifier l'état (ici une fonction dispatch).

Le hook `useReducer` prend 2 arguments

1. une fonction de réducteur
2. l'état initial

et cela retourne:

1. La valeur de l'état
2. la fonction dispatch (pour "dispatcher" les actions au réducteur)

---

## Exemple complété (Version 1)

C'est complété! Ici, le réducteur est en bas du fichier.

<Sandpack>

```js src/App.js
import { useReducer } from 'react';
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';

export default function TaskApp() {
  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

  function handleAddTask(text) {
    dispatch({
      type: 'added',
      id: nextId++,
      text: text,
    });
  }

  function handleChangeTask(task) {
    dispatch({
      type: 'changed',
      task: task,
    });
  }

  function handleDeleteTask(taskId) {
    dispatch({
      type: 'deleted',
      id: taskId,
    });
  }

  return (
    <>
      <h1>Prague itinerary</h1>
      <AddTask onAddTask={handleAddTask} />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}

function tasksReducer(tasks, action) {
  switch (action.type) {
    case 'added': {
      return [
        ...tasks,
        {
          id: action.id,
          text: action.text,
          done: false,
        },
      ];
    }
    case 'changed': {
      return tasks.map((t) => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case 'deleted': {
      return tasks.filter((t) => t.id !== action.id);
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}

let nextId = 3;
const initialTasks = [
  { id: 0, text: 'Visit Kafka Museum', done: true },
  { id: 1, text: 'Watch a puppet show', done: false },
  { id: 2, text: 'Lennon Wall pic', done: false },
];
```

```js src/AddTask.js hidden
import { useState } from 'react';

export default function AddTask({ onAddTask }) {
  const [text, setText] = useState('');
  return (
    <>
      <input
        placeholder='Add task'
        value={text}
        onChange={(e) => setText(e.target.value)}
      />
      <button
        onClick={() => {
          setText('');
          onAddTask(text);
        }}
      >
        Add
      </button>
    </>
  );
}
```

```js src/TaskList.js hidden
import { useState } from 'react';

export default function TaskList({ tasks, onChangeTask, onDeleteTask }) {
  return (
    <ul>
      {tasks.map((task) => (
        <li key={task.id}>
          <Task task={task} onChange={onChangeTask} onDelete={onDeleteTask} />
        </li>
      ))}
    </ul>
  );
}

function Task({ task, onChange, onDelete }) {
  const [isEditing, setIsEditing] = useState(false);
  let taskContent;
  if (isEditing) {
    taskContent = (
      <>
        <input
          value={task.text}
          onChange={(e) => {
            onChange({
              ...task,
              text: e.target.value,
            });
          }}
        />
        <button onClick={() => setIsEditing(false)}>Save</button>
      </>
    );
  } else {
    taskContent = (
      <>
        {task.text}
        <button onClick={() => setIsEditing(true)}>Edit</button>
      </>
    );
  }
  return (
    <label>
      <input
        type='checkbox'
        checked={task.done}
        onChange={(e) => {
          onChange({
            ...task,
            done: e.target.checked,
          });
        }}
      />
      {taskContent}
      <button onClick={() => onDelete(task.id)}>Delete</button>
    </label>
  );
}
```

```css
button {
  margin: 5px;
}
li {
  list-style-type: none;
}
ul,
li {
  margin: 0;
  padding: 0;
}
```

</Sandpack>

---

## Exemple complété (Version 2)

Le même exemple, avec le réducteur dans son propre fichier séparé.

<Sandpack>

```js src/App.js
import { useReducer } from 'react';
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';
import tasksReducer from './tasksReducer.js';

export default function TaskApp() {
  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

  function handleAddTask(text) {
    dispatch({
      type: 'added',
      id: nextId++,
      text: text,
    });
  }

  function handleChangeTask(task) {
    dispatch({
      type: 'changed',
      task: task,
    });
  }

  function handleDeleteTask(taskId) {
    dispatch({
      type: 'deleted',
      id: taskId,
    });
  }

  return (
    <>
      <h1>Prague itinerary</h1>
      <AddTask onAddTask={handleAddTask} />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}

let nextId = 3;
const initialTasks = [
  { id: 0, text: 'Visit Kafka Museum', done: true },
  { id: 1, text: 'Watch a puppet show', done: false },
  { id: 2, text: 'Lennon Wall pic', done: false },
];
```

```js src/tasksReducer.js
export default function tasksReducer(tasks, action) {
  switch (action.type) {
    case 'added': {
      return [
        ...tasks,
        {
          id: action.id,
          text: action.text,
          done: false,
        },
      ];
    }
    case 'changed': {
      return tasks.map((t) => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case 'deleted': {
      return tasks.filter((t) => t.id !== action.id);
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```

```js src/AddTask.js hidden
import { useState } from 'react';

export default function AddTask({ onAddTask }) {
  const [text, setText] = useState('');
  return (
    <>
      <input
        placeholder='Add task'
        value={text}
        onChange={(e) => setText(e.target.value)}
      />
      <button
        onClick={() => {
          setText('');
          onAddTask(text);
        }}
      >
        Add
      </button>
    </>
  );
}
```

```js src/TaskList.js hidden
import { useState } from 'react';

export default function TaskList({ tasks, onChangeTask, onDeleteTask }) {
  return (
    <ul>
      {tasks.map((task) => (
        <li key={task.id}>
          <Task task={task} onChange={onChangeTask} onDelete={onDeleteTask} />
        </li>
      ))}
    </ul>
  );
}

function Task({ task, onChange, onDelete }) {
  const [isEditing, setIsEditing] = useState(false);
  let taskContent;
  if (isEditing) {
    taskContent = (
      <>
        <input
          value={task.text}
          onChange={(e) => {
            onChange({
              ...task,
              text: e.target.value,
            });
          }}
        />
        <button onClick={() => setIsEditing(false)}>Save</button>
      </>
    );
  } else {
    taskContent = (
      <>
        {task.text}
        <button onClick={() => setIsEditing(true)}>Edit</button>
      </>
    );
  }
  return (
    <label>
      <input
        type='checkbox'
        checked={task.done}
        onChange={(e) => {
          onChange({
            ...task,
            done: e.target.checked,
          });
        }}
      />
      {taskContent}
      <button onClick={() => onDelete(task.id)}>Delete</button>
    </label>
  );
}
```

```css
button {
  margin: 5px;
}
li {
  list-style-type: none;
}
ul,
li {
  margin: 0;
  padding: 0;
}
```

</Sandpack>

C'est plus facile à lire quand le code est séparé. Les gestionnaires d'événements appellent dispatch avec une action qui _décrit la modification_. Le réducteur détermine comment _mettre à jour l'état_.

---

## Comparer `useState` et `useReducer`

Réducteurs sont différents des états.

- **Taille du code:** il y a moins de code avec `useState`. Tandis qu'avec `useReducer`, on doit fournir une fonction réducteur, ainsi qu'appeler dispatch avec des actions. `useReducer` aide si plusieurs gestionnaires d'événements modifient les données de façon similaire.
- **Lisibilité:**
- **Lisibilité:** `useState` est facile à lire pour les scénarios simples. `useReducer` simplifie les scénarios plus complexes, en séparant le _quoi_ du _comment_.
- **Débogage:** les bogues avec `useState` sont difficiles à trouver. Avec `useReducer`, il est facile d'ajouter un `console.log` dans un réducteur et de décortiquer l'action, l'état précédent et l'état suivant.

---

## Suite des différences

- **Testing:** Un réducteur est fonction pure, sans dépendance sur aucune composante. C'est facile à tester de façon séparée et isolée. Pour un scénario comlexe, c'est facile de tester un résultat à partir d'un état initial et d'une action.
- **Préférence Personnelle:** Certains préfèrent les réducteurs, d'autres pas. c'est correcty. c'est une question de goût. On peut convertir entre `useState` et `useReducer` dans les deux sens: ils sont équivalents

On recommande d'utiliser un réducteur quand il y a beaucoup de bogues suite à des modifications d'états, ou quand on veut du code plus structuré.

Pas besoin d'utiliser des réducteurs partout. On peut mélanger les deux approches dans une solution.

---

## Bonnes pratiques pour écrire un réducteur

- **Les réducteurs sont purs.** Les réducteurs roulent pendant le render. Les réducteurs doivent être purs. Les actions sont mis en file jusqu'au prochain rendu. Les mêmes entrées génèrent la même sortie. Un réducteur ne doit pas envoyer de requêtes, ni gérer de timeout, ne générer d'effets de bord. Ils doivent mettre à jour les objets et tableaux sans mutations.
- **Chaque action décrit une interaction, même si cela entraîne de multiples changements.**
  Par exemple, si un utilisateur clique "Reset" sur un formulaire de 5 champs, il vaut mieux faire un dispatch de l'action `reset_form` que 5 dispatch d'actions `set_field`. Si on on journalise chaque action d'un réducteur, le journal devrait permettre de reconstituer les interactions et réponses dans le bon ordre.

---

## Écrire des réducteurs concis avec Immer

Tout comme la mise à jour des objects dans l'état régulier, on peut utiliser la librairie Immer pour que les reducteurs soient plus concis.

`useImmerReducer` permet de muter l'état avec `push` ou `arr[i] =`

<Sandpack>

```js src/App.js
import { useImmerReducer } from 'use-immer';
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';

function tasksReducer(draft, action) {
  switch (action.type) {
    case 'added': {
      draft.push({
        id: action.id,
        text: action.text,
        done: false,
      });
      break;
    }
    case 'changed': {
      const index = draft.findIndex((t) => t.id === action.task.id);
      draft[index] = action.task;
      break;
    }
    case 'deleted': {
      return draft.filter((t) => t.id !== action.id);
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}

export default function TaskApp() {
  const [tasks, dispatch] = useImmerReducer(tasksReducer, initialTasks);

  function handleAddTask(text) {
    dispatch({
      type: 'added',
      id: nextId++,
      text: text,
    });
  }

  function handleChangeTask(task) {
    dispatch({
      type: 'changed',
      task: task,
    });
  }

  function handleDeleteTask(taskId) {
    dispatch({
      type: 'deleted',
      id: taskId,
    });
  }

  return (
    <>
      <h1>Prague itinerary</h1>
      <AddTask onAddTask={handleAddTask} />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}

let nextId = 3;
const initialTasks = [
  { id: 0, text: 'Visit Kafka Museum', done: true },
  { id: 1, text: 'Watch a puppet show', done: false },
  { id: 2, text: 'Lennon Wall pic', done: false },
];
```

```js src/AddTask.js hidden
import { useState } from 'react';

export default function AddTask({ onAddTask }) {
  const [text, setText] = useState('');
  return (
    <>
      <input
        placeholder='Add task'
        value={text}
        onChange={(e) => setText(e.target.value)}
      />
      <button
        onClick={() => {
          setText('');
          onAddTask(text);
        }}
      >
        Add
      </button>
    </>
  );
}
```

```js src/TaskList.js hidden
import { useState } from 'react';

export default function TaskList({ tasks, onChangeTask, onDeleteTask }) {
  return (
    <ul>
      {tasks.map((task) => (
        <li key={task.id}>
          <Task task={task} onChange={onChangeTask} onDelete={onDeleteTask} />
        </li>
      ))}
    </ul>
  );
}

function Task({ task, onChange, onDelete }) {
  const [isEditing, setIsEditing] = useState(false);
  let taskContent;
  if (isEditing) {
    taskContent = (
      <>
        <input
          value={task.text}
          onChange={(e) => {
            onChange({
              ...task,
              text: e.target.value,
            });
          }}
        />
        <button onClick={() => setIsEditing(false)}>Save</button>
      </>
    );
  } else {
    taskContent = (
      <>
        {task.text}
        <button onClick={() => setIsEditing(true)}>Edit</button>
      </>
    );
  }
  return (
    <label>
      <input
        type='checkbox'
        checked={task.done}
        onChange={(e) => {
          onChange({
            ...task,
            done: e.target.checked,
          });
        }}
      />
      {taskContent}
      <button onClick={() => onDelete(task.id)}>Delete</button>
    </label>
  );
}
```

```css
button {
  margin: 5px;
}
li {
  list-style-type: none;
}
ul,
li {
  margin: 0;
  padding: 0;
}
```

```json package.json
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

</Sandpack>

Les réducteurs doivent être purs, et ne devraient pas muter l'état. Immer peut fournir un objet brouillon nommé `draft` qui permet des mutations sécuritaires.

Immer va créer un copie de l'état avec les changements effectués sur l'objet `draft`. Les réducteurs gérés par `useImmerReducer` peuvent muter leur premier argument et n'ont pas besoin de retourner d'état.

---

## Résumé

- Pour convertir de `useState` vers `useReducer`:
  1. Appelez dispatch avec une actions dans les gestionnaires d'événements.
  2. Écrvez une fonction réducteur qui retourne le prochain état pour un état et une action donnée
  3. Remplacez `useState` par `useReducer`.
- Il ya plus de code à écrire dans un réducteur. Ça aide au moment des déboguer et de tester.
- Reducteurs doivent être purs
- Chaque action décrit une seule interaction utilisateur.
- Immer permet d'écrire des réducteurs dans un style mutatif.

---

## Défi: Dispatcher les actions à partir des gestionnaires d'événements

Présentment, les gestionnaires d'événements de `ContactList.js` et `Chat.js` ont des commentaires `// TODO`. Taper dans le champ de saisie ne fonctionne pas, et cliquer sur les boutons ne change pas la selection.

Remplacez les 2 `// TODO`s avec des `dispatch` et les actions correspondantes. Pour comprendre le format des actions, il faut consulter le code du réducteur dans `messengerReducer.js`. Le réducteur est bien écrit, nul besoin de le modifier. Il suffit d'appeler le dispatch avec la bonne action dans `ContactList.js` et `Chat.js`.

---

## Défi Suite

<Hint>

La fonction `dispatch` est disponible dans les composants, car ça été passé dans les props. Il suffit d'appeler `dispatch` avec la bonne action.

C'est dans le réducteur qu'on voit la structure l'objet `action`. Dans le cas de `changed_selection`, voici le réducteur:

```js
case 'changed_selection': {
  return {
    ...state,
    selectedId: action.contactId
  };
}
```

L'action devrait avoir une propriété `type: 'changed_selection'`, ainsi qu'une propriété`contactId`

</Hint>

<Sandpack>

```js src/App.js
import { useReducer } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';
import { initialState, messengerReducer } from './messengerReducer';

export default function Messenger() {
  const [state, dispatch] = useReducer(messengerReducer, initialState);
  const message = state.message;
  const contact = contacts.find((c) => c.id === state.selectedId);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedId={state.selectedId}
        dispatch={dispatch}
      />
      <Chat
        key={contact.id}
        message={message}
        contact={contact}
        dispatch={dispatch}
      />
    </div>
  );
}

const contacts = [
  { id: 0, name: 'Taylor', email: 'taylor@mail.com' },
  { id: 1, name: 'Alice', email: 'alice@mail.com' },
  { id: 2, name: 'Bob', email: 'bob@mail.com' },
];
```

```js src/messengerReducer.js
export const initialState = {
  selectedId: 0,
  message: 'Hello',
};

export function messengerReducer(state, action) {
  switch (action.type) {
    case 'changed_selection': {
      return {
        ...state,
        selectedId: action.contactId,
        message: '',
      };
    }
    case 'edited_message': {
      return {
        ...state,
        message: action.message,
      };
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```

```js src/ContactList.js
export default function ContactList({ contacts, selectedId, dispatch }) {
  return (
    <section className='contact-list'>
      <ul>
        {contacts.map((contact) => (
          <li key={contact.id}>
            <button
              onClick={() => {
                // TODO: dispatch changed_selection
              }}
            >
              {selectedId === contact.id ? <b>{contact.name}</b> : contact.name}
            </button>
          </li>
        ))}
      </ul>
    </section>
  );
}
```

```js src/Chat.js
import { useState } from 'react';

export default function Chat({ contact, message, dispatch }) {
  return (
    <section className='chat'>
      <textarea
        value={message}
        placeholder={'Chat to ' + contact.name}
        onChange={(e) => {
          // TODO: dispatch edited_message
          // (Read the input value from e.target.value)
        }}
      />
      <br />
      <button>Send to {contact.email}</button>
    </section>
  );
}
```

```css
.chat,
.contact-list {
  float: left;
  margin-bottom: 20px;
}
ul,
li {
  list-style: none;
  margin: 0;
  padding: 0;
}
li button {
  width: 100px;
  padding: 10px;
  margin-right: 10px;
}
textarea {
  height: 150px;
}
```

</Sandpack>

---

## Défi : Effacer le champ quand un message est envoyé

Currently, pressing "Send" doesn't do anything. Add an event handler to the "Send" button that will:

1. Show an `alert` with the recipient's email and the message.
2. Clear the message input.

<Sandpack>

```js src/App.js
import { useReducer } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';
import { initialState, messengerReducer } from './messengerReducer';

export default function Messenger() {
  const [state, dispatch] = useReducer(messengerReducer, initialState);
  const message = state.message;
  const contact = contacts.find((c) => c.id === state.selectedId);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedId={state.selectedId}
        dispatch={dispatch}
      />
      <Chat
        key={contact.id}
        message={message}
        contact={contact}
        dispatch={dispatch}
      />
    </div>
  );
}

const contacts = [
  { id: 0, name: 'Taylor', email: 'taylor@mail.com' },
  { id: 1, name: 'Alice', email: 'alice@mail.com' },
  { id: 2, name: 'Bob', email: 'bob@mail.com' },
];
```

```js src/messengerReducer.js
export const initialState = {
  selectedId: 0,
  message: 'Hello',
};

export function messengerReducer(state, action) {
  switch (action.type) {
    case 'changed_selection': {
      return {
        ...state,
        selectedId: action.contactId,
        message: '',
      };
    }
    case 'edited_message': {
      return {
        ...state,
        message: action.message,
      };
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```

```js src/ContactList.js
export default function ContactList({ contacts, selectedId, dispatch }) {
  return (
    <section className='contact-list'>
      <ul>
        {contacts.map((contact) => (
          <li key={contact.id}>
            <button
              onClick={() => {
                dispatch({
                  type: 'changed_selection',
                  contactId: contact.id,
                });
              }}
            >
              {selectedId === contact.id ? <b>{contact.name}</b> : contact.name}
            </button>
          </li>
        ))}
      </ul>
    </section>
  );
}
```

```js src/Chat.js active
import { useState } from 'react';

export default function Chat({ contact, message, dispatch }) {
  return (
    <section className='chat'>
      <textarea
        value={message}
        placeholder={'Chat to ' + contact.name}
        onChange={(e) => {
          dispatch({
            type: 'edited_message',
            message: e.target.value,
          });
        }}
      />
      <br />
      <button>Send to {contact.email}</button>
    </section>
  );
}
```

```css
.chat,
.contact-list {
  float: left;
  margin-bottom: 20px;
}
ul,
li {
  list-style: none;
  margin: 0;
  padding: 0;
}
li button {
  width: 100px;
  padding: 10px;
  margin-right: 10px;
}
textarea {
  height: 150px;
}
```

</Sandpack>

---

## Défi: Restaurer les champs quand on navigue entre les tabulations

In this example, switching between different recipients always clears the text input:

```js
case 'changed_selection': {
  return {
    ...state,
    selectedId: action.contactId,
    message: '' // Clears the input
  };
}
```

This is because you don't want to share a single message draft between several recipients. But it would be better if your app "remembered" a draft for each contact separately, restoring them when you switch contacts.

Your task is to change the way the state is structured so that you remember a separate message draft _per contact_. You would need to make a few changes to the reducer, the initial state, and the components.

---

## Défi suite

<Hint>

You can structure your state like this:

```js
export const initialState = {
  selectedId: 0,
  messages: {
    0: 'Hello, Taylor', // Draft for contactId = 0
    1: 'Hello, Alice', // Draft for contactId = 1
  },
};
```

The `[key]: value` [computed property](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#computed_property_names) syntax can help you update the `messages` object:

```js
{
  ...state.messages,
  [id]: message
}
```

</Hint>

<Sandpack>

```js src/App.js
import { useReducer } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';
import { initialState, messengerReducer } from './messengerReducer';

export default function Messenger() {
  const [state, dispatch] = useReducer(messengerReducer, initialState);
  const message = state.message;
  const contact = contacts.find((c) => c.id === state.selectedId);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedId={state.selectedId}
        dispatch={dispatch}
      />
      <Chat
        key={contact.id}
        message={message}
        contact={contact}
        dispatch={dispatch}
      />
    </div>
  );
}

const contacts = [
  { id: 0, name: 'Taylor', email: 'taylor@mail.com' },
  { id: 1, name: 'Alice', email: 'alice@mail.com' },
  { id: 2, name: 'Bob', email: 'bob@mail.com' },
];
```

```js src/messengerReducer.js
export const initialState = {
  selectedId: 0,
  message: 'Hello',
};

export function messengerReducer(state, action) {
  switch (action.type) {
    case 'changed_selection': {
      return {
        ...state,
        selectedId: action.contactId,
        message: '',
      };
    }
    case 'edited_message': {
      return {
        ...state,
        message: action.message,
      };
    }
    case 'sent_message': {
      return {
        ...state,
        message: '',
      };
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```

```js src/ContactList.js
export default function ContactList({ contacts, selectedId, dispatch }) {
  return (
    <section className='contact-list'>
      <ul>
        {contacts.map((contact) => (
          <li key={contact.id}>
            <button
              onClick={() => {
                dispatch({
                  type: 'changed_selection',
                  contactId: contact.id,
                });
              }}
            >
              {selectedId === contact.id ? <b>{contact.name}</b> : contact.name}
            </button>
          </li>
        ))}
      </ul>
    </section>
  );
}
```

```js src/Chat.js
import { useState } from 'react';

export default function Chat({ contact, message, dispatch }) {
  return (
    <section className='chat'>
      <textarea
        value={message}
        placeholder={'Chat to ' + contact.name}
        onChange={(e) => {
          dispatch({
            type: 'edited_message',
            message: e.target.value,
          });
        }}
      />
      <br />
      <button
        onClick={() => {
          alert(`Sending "${message}" to ${contact.email}`);
          dispatch({
            type: 'sent_message',
          });
        }}
      >
        Send to {contact.email}
      </button>
    </section>
  );
}
```

```css
.chat,
.contact-list {
  float: left;
  margin-bottom: 20px;
}
ul,
li {
  list-style: none;
  margin: 0;
  padding: 0;
}
li button {
  width: 100px;
  padding: 10px;
  margin-right: 10px;
}
textarea {
  height: 150px;
}
```

</Sandpack>

---

## Défi: Implementer `useReducer` du debut

In the earlier examples, you imported the `useReducer` Hook from React. This time, you will implement _the `useReducer` Hook itself!_ Here is a stub to get you started. It shouldn't take more than 10 lines of code.

To test your changes, try typing into the input or select a contact.

---

## Défi

<Hint>

Here is a more detailed sketch of the implementation:

```js
export function useReducer(reducer, initialState) {
  const [state, setState] = useState(initialState);

  function dispatch(action) {
    // ???
  }

  return [state, dispatch];
}
```

Recall that a reducer function takes two arguments--the current state and the action object--and it returns the next state. What should your `dispatch` implementation do with it?

</Hint>

<Sandpack>

```js src/App.js
import { useReducer } from './MyReact.js';
import Chat from './Chat.js';
import ContactList from './ContactList.js';
import { initialState, messengerReducer } from './messengerReducer';

export default function Messenger() {
  const [state, dispatch] = useReducer(messengerReducer, initialState);
  const message = state.messages[state.selectedId];
  const contact = contacts.find((c) => c.id === state.selectedId);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedId={state.selectedId}
        dispatch={dispatch}
      />
      <Chat
        key={contact.id}
        message={message}
        contact={contact}
        dispatch={dispatch}
      />
    </div>
  );
}

const contacts = [
  { id: 0, name: 'Taylor', email: 'taylor@mail.com' },
  { id: 1, name: 'Alice', email: 'alice@mail.com' },
  { id: 2, name: 'Bob', email: 'bob@mail.com' },
];
```

```js src/messengerReducer.js
export const initialState = {
  selectedId: 0,
  messages: {
    0: 'Hello, Taylor',
    1: 'Hello, Alice',
    2: 'Hello, Bob',
  },
};

export function messengerReducer(state, action) {
  switch (action.type) {
    case 'changed_selection': {
      return {
        ...state,
        selectedId: action.contactId,
      };
    }
    case 'edited_message': {
      return {
        ...state,
        messages: {
          ...state.messages,
          [state.selectedId]: action.message,
        },
      };
    }
    case 'sent_message': {
      return {
        ...state,
        messages: {
          ...state.messages,
          [state.selectedId]: '',
        },
      };
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```

```js src/MyReact.js active
import { useState } from 'react';

export function useReducer(reducer, initialState) {
  const [state, setState] = useState(initialState);

  // ???

  return [state, dispatch];
}
```

```js src/ContactList.js hidden
export default function ContactList({ contacts, selectedId, dispatch }) {
  return (
    <section className='contact-list'>
      <ul>
        {contacts.map((contact) => (
          <li key={contact.id}>
            <button
              onClick={() => {
                dispatch({
                  type: 'changed_selection',
                  contactId: contact.id,
                });
              }}
            >
              {selectedId === contact.id ? <b>{contact.name}</b> : contact.name}
            </button>
          </li>
        ))}
      </ul>
    </section>
  );
}
```

```js src/Chat.js hidden
import { useState } from 'react';

export default function Chat({ contact, message, dispatch }) {
  return (
    <section className='chat'>
      <textarea
        value={message}
        placeholder={'Chat to ' + contact.name}
        onChange={(e) => {
          dispatch({
            type: 'edited_message',
            message: e.target.value,
          });
        }}
      />
      <br />
      <button
        onClick={() => {
          alert(`Sending "${message}" to ${contact.email}`);
          dispatch({
            type: 'sent_message',
          });
        }}
      >
        Send to {contact.email}
      </button>
    </section>
  );
}
```

```css
.chat,
.contact-list {
  float: left;
  margin-bottom: 20px;
}
ul,
li {
  list-style: none;
  margin: 0;
  padding: 0;
}
li button {
  width: 100px;
  padding: 10px;
  margin-right: 10px;
}
textarea {
  height: 150px;
}
```

</Sandpack>

---

import Context from './15-manage-state/6-context.fr.mdx';

<Context components={props.components} />

---

import Reducercontext from './15-manage-state/7-reducer-context.fr.mdx';

<Reducercontext components={props.components} />
