---
title: 'Hooks Personnalis√©s'
---

# Hooks Personnalis√©s

---

## Intro

- React est fourni avec ses Hooks
  - `useState`
  - `useContext`
  - `useEffect`
- Parfois, on d√©sire des hooks sp√©cifiques:
  - Aller chercher des donn√©es sur un service
  - G√©rer quand on est en Ligne
  - Se connecter √† du clavardage
- On peut cr√©er nos propres hooks pour nos besoins

---

## Contenu

- Comment √©crire des hooks personnalis√©s
- R√©utiliser la logique entre les composants
- Comment nommer et structurer les Hooks personnalis√©s
- Quand extraire les hooks personnalis√©s

---

## Partage de code entre les composants

- Imaginons une application qui doit d√©tecter si le r√©seau et disponible
- Il faut 2 choses:
  1. Un √©tat (state) qui d√©termine si le r√©seau est en ligne
  1. Un Effect qui s'abonne aux √©v√©nements `online` et `offline` et qui met √† jour l'√©tat
- On garde le composant synchronis√© avec l'√©tat du r√©seau

---

## Code

<Sandpack>

```js
import { useState, useEffect } from 'react';

export default function StatusBar() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>;
}
```

</Sandpack>

Testez en modifiant l'√©tat du r√©seau, et le `StatusBar` se met √† jour

---

## Copier le code dans un autre composant

- Code similaire pour le bouton `Save`, d√©pendant si on est en ligne ou hors ligne.

<Sandpack>

```js
import { useState, useEffect } from 'react';

export default function SaveButton() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  function handleSaveClick() {
    console.log('‚úÖ Progress saved');
  }

  return (
    <button disabled={!isOnline} onClick={handleSaveClick}>
      {isOnline ? 'Save progress' : 'Reconnecting...'}
    </button>
  );
}
```

</Sandpack>

---

### Extraire un Hook d'un composant

- Pour r√©utiliser ce code, cr√©ons un hook nomm√© `useOnlineStatus`
- Cela simplifie le code des composants

```js {2,7}
function StatusBar() {
  const isOnline = useOnlineStatus();
  return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>;
}

function SaveButton() {
  const isOnline = useOnlineStatus();

  function handleSaveClick() {
    console.log('‚úÖ Progress saved');
  }

  return (
    <button disabled={!isOnline} onClick={handleSaveClick}>
      {isOnline ? 'Save progress' : 'Reconnecting...'}
    </button>
  );
}
```

---

## Cr√©ation du Hook

- La fonction retourne la valeur de `isOnline`.

```js {2-16}
function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  return isOnline;
}
```

---

## Hook useOnlineStatus

<Sandpack>

```js
import { useOnlineStatus } from './useOnlineStatus.js';

function StatusBar() {
  const isOnline = useOnlineStatus();
  return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>;
}

function SaveButton() {
  const isOnline = useOnlineStatus();

  function handleSaveClick() {
    console.log('‚úÖ Progress saved');
  }

  return (
    <button disabled={!isOnline} onClick={handleSaveClick}>
      {isOnline ? 'Save progress' : 'Reconnecting...'}
    </button>
  );
}

export default function App() {
  return (
    <>
      <SaveButton />
      <StatusBar />
    </>
  );
}
```

```js src/useOnlineStatus.js
import { useState, useEffect } from 'react';

export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  return isOnline;
}
```

</Sandpack>

---

## R√©sultat

- Avec un hook personnalis√©, les composants ont moins de code r√©p√©titif
- Le code est plus descriptif
  - On d√©crit ce l'on veut comme info (l'√©tat du r√©seau)
  - Plut√¥t que de d√©crire comment obtenir l'info (un abonnement √† l'√©v√©nement navigateur)
  - Le hook cache les d√©tails, comme la connexion √† un syst√®me externe

---

## Le nom d'un hook d√©bute toujours par `use`

- **Les composants React d√©butent toujours par une lettre majuscule**
  - ex: `StatusBar`, `SaveButton`.
  - retourne du JSX
- **Les hook d√©butent toujours par `use`, suivi d'une majuscule**
  - ex: `useState`, `useOnlineStatus`
  - retourne une valeur simple ou complexe.
    <hr />
- Cette convention aide √† d√©terminer o√π se trouve l'√âtat et les Effects d'un composant
  - `getColor()` ne peut contenir un √©tat
  - `useOnlineStatus()` contient d'autres hooks

---

## Linter et les hooks

- Avec un linter bien configur√©, il faut respecter la nomenclature des hooks.
- Le linter retourne une erreur quand on renomme `useOnlineStatus` √† `getOnlineStatus`.
- Un hook doit √™tre appel√© par:
  - un composant
  - un autre hook

---

## Attention: Ne pas ajouter `use` √† toutes les fonctions

- Une fonction qui n'utilise pas de hooks n'a pas besoin d'√™tre un hook
- Dans ce cas, on √©vite d'utiliser le pr√©fixe `use`
- Dans l'exemple suivant, `useSorted` n'utilise pas de Hooks
- faudrait renommer la fonction pour `getSorted`:

```js
// üî¥ Avoid: A Hook that doesn't use Hooks
function useSorted(items) {
  return items.slice().sort();
}

// ‚úÖ Good: A regular function that doesn't use Hooks
function getSorted(items) {
  return items.slice().sort();
}
```

---

## Plus flexible quand ce n'est pas un hook

- Une fonction est plus flexible qu'un hook
- On peut appeler la fonction dans une condition ou boucle

```js
function List({ items, shouldSort }) {
  let displayedItems = items;
  if (shouldSort) {
    // ‚úÖ It's ok to call getSorted() conditionally because it's not a Hook
    displayedItems = getSorted(items);
  }
  // ...
}
```

- Quand fonction appelle un hook, il faut la convertir en hook
- On renomme cette fonction avec le pr√©fixe `use`

```js
// ‚úÖ Good: A Hook that uses other Hooks
function useAuth() {
  return useContext(Auth);
}
```

---

## Un Hook pour le futur

- On pourrait cr√©er un hook qui n'appelle pas d'autres hooks
- √áa peut √™tre utile pour le futur
  - quand on planifie modifier le code pour ajouter des hooks

```js {3-4}
// ‚úÖ Good: A Hook that will likely use some other Hooks later
function useAuth() {
  // TODO: Replace with this line when authentication is implemented:
  // return useContext(Auth);
  return TEST_USER;
}
```

---

## Partager du code √©tatique, sans partager l'√©tat

- On pourrait penser que la m√™me variable d'√©tat `isOnline` est partag√©e
- Mais ce n'est PAS le cas:

<TwoColumns top>

```js {2,7}
function StatusBar() {
  const isOnline = useOnlineStatus();
  // ...
}

function SaveButton() {
  const isOnline = useOnlineStatus();
  // ...
}
```

```js {2-5,10-13}
function StatusBar() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    // ...
  }, []);
  // ...
}

function SaveButton() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    // ...
  }, []);
  // ...
}
```

</TwoColumns>

- Ce sont deux variables d'√©tats et des Effects, qui sont **ind√©pendants**
- Ils sont **synchronis√©s** sur la m√™me valeur externe

---

## Autre exemple qui utilise de l'√©tat

- Voici un formulaire `Form` avec deux √©tats s√©par√©s

<Sandpack>

```js
import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('Mary');
  const [lastName, setLastName] = useState('Poppins');

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
  }

  return (
    <>
      <label>
        First name:
        <input value={firstName} onChange={handleFirstNameChange} />
      </label>
      <label>
        Last name:
        <input value={lastName} onChange={handleLastNameChange} />
      </label>
      <p>
        <b>
          Good morning, {firstName} {lastName}.
        </b>
      </p>
    </>
  );
}
```

```css
label {
  display: block;
}
input {
  margin-left: 10px;
}
```

</Sandpack>

---

# R√©p√©tition du code

1. Il y a deux √©tats (`firstName` et `lastName`).
1. Il y a deux gestionnaires d'√©v√©nements (`handleFirstNameChange` et `handleLastNameChange`).
1. Il y a deux blocs JSX qui utilise des attributs `value` et `onChange`.

---

## Remplacer l'√©tat par un hook

- On peut extraire cette logique r√©p√©titive dans un hook `useFormInput`:

<Sandpack>

```js
import { useFormInput } from './useFormInput.js';

export default function Form() {
  const firstNameProps = useFormInput('Mary');
  const lastNameProps = useFormInput('Poppins');

  return (
    <>
      <label>
        First name:
        <input {...firstNameProps} />
      </label>
      <label>
        Last name:
        <input {...lastNameProps} />
      </label>
      <p>
        <b>
          Good morning, {firstNameProps.value} {lastNameProps.value}.
        </b>
      </p>
    </>
  );
}
```

```js src/useFormInput.js active
import { useState } from 'react';

export function useFormInput(initialValue) {
  const [value, setValue] = useState(initialValue);

  function handleChange(e) {
    setValue(e.target.value);
  }

  const inputProps = {
    value: value,
    onChange: handleChange,
  };

  return inputProps;
}
```

```css
label {
  display: block;
}
input {
  margin-left: 10px;
}
```

</Sandpack>

---

## Le code est appel√© deux fois, cr√©ant deux √©tats

- On d√©clare une variable d'√©tat nomm√©e `value`
- Le composant Form appelle `useFormInput` deux fois

```js
function Form() {
  const firstNameProps = useFormInput('Mary');
  const lastNameProps = useFormInput('Poppins');
  // ...
```

- C'est comme d√©clarer 2 variables d'√©tats s√©par√©es
- Un hook personnalis√© partage la _logique d'√©tat_, mais pas _l'√©tat_
- Chaque appel au hook personalis√© est ind√©pendant
- Si on d√©sire partager l'√©tat, il faut remonter l'√©tat dans l'arborescence
  - Passer l'info vers le bas avec des props (ou un contexte)

---

## Passer des valeurs r√©actives √† travers les hooks

- Les hooks r√©-ex√©cutent √† chaque re-rendu du composant
- Ils utilisent les props et l'√©tat courant
- Les hooks doivent √™tre **purs**
  - Comme le code dans le corps d'un composant
- Le code suivant n'utilise pas de hooks (pour le moment)

<Sandpack>

```js src/App.js
import { useState } from 'react';
import ChatRoom from './ChatRoom.js';

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select value={roomId} onChange={(e) => setRoomId(e.target.value)}>
          <option value='general'>general</option>
          <option value='travel'>travel</option>
          <option value='music'>music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

```js src/ChatRoom.js active
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';
import { showNotification } from './notifications.js';

export default function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId,
    };
    const connection = createConnection(options);
    connection.on('message', (msg) => {
      showNotification('New message: ' + msg);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]);

  return (
    <>
      <label>
        Server URL:
        <input
          value={serverUrl}
          onChange={(e) => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}
```

```js src/chat.js
export function createConnection({ serverUrl, roomId }) {
  // A real implementation would actually connect to the server
  if (typeof serverUrl !== 'string') {
    throw Error('Expected serverUrl to be a string. Received: ' + serverUrl);
  }
  if (typeof roomId !== 'string') {
    throw Error('Expected roomId to be a string. Received: ' + roomId);
  }
  let intervalId;
  let messageCallback;
  return {
    connect() {
      console.log(
        '‚úÖ Connecting to "' + roomId + '" room at ' + serverUrl + '...'
      );
      clearInterval(intervalId);
      intervalId = setInterval(() => {
        if (messageCallback) {
          if (Math.random() > 0.5) {
            messageCallback('hey');
          } else {
            messageCallback('lol');
          }
        }
      }, 3000);
    },
    disconnect() {
      clearInterval(intervalId);
      messageCallback = null;
      console.log(
        '‚ùå Disconnected from "' + roomId + '" room at ' + serverUrl + ''
      );
    },
    on(event, callback) {
      if (messageCallback) {
        throw Error('Cannot add the handler twice.');
      }
      if (event !== 'message') {
        throw Error('Only "message" event is supported.');
      }
      messageCallback = callback;
    },
  };
}
```

```js src/notifications.js
import Toastify from 'toastify-js';
import 'toastify-js/src/toastify.css';

export function showNotification(message, theme = 'dark') {
  Toastify({
    text: message,
    duration: 2000,
    gravity: 'top',
    position: 'right',
    style: {
      background: theme === 'dark' ? 'black' : 'white',
      color: theme === 'dark' ? 'white' : 'black',
    },
  }).showToast();
}
```

```json package.json hidden
{
  "dependencies": {
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "toastify-js": "1.12.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

```css
input {
  display: block;
  margin-bottom: 20px;
}
button {
  margin-left: 10px;
}
```

</Sandpack>

---

## D√©placer l'Effect dans un hook personnalis√©

```js {2-13}
export function useChatRoom({ serverUrl, roomId }) {
  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId,
    };
    const connection = createConnection(options);
    connection.connect();
    connection.on('message', (msg) => {
      showNotification('New message: ' + msg);
    });
    return () => connection.disconnect();
  }, [roomId, serverUrl]);
}
```

---

## Appeler le hook

- `ChatRoom` appelle le hook personalis√©
  - sans se soucier du fonctionnement
- Le code semble simplifi√© (la complexit√© est d√©plac√©e dans le hook)

```js {4-7}
export default function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useChatRoom({
    roomId: roomId,
    serverUrl: serverUrl,
  });

  return (
    <>
      <label>
        Server URL:
        <input
          value={serverUrl}
          onChange={(e) => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}
```

---

## M√™me code, avec hook personnalis√©

- La logique r√©agit aux changements de props et d'√©tats

<Sandpack>

```js src/App.js
import { useState } from 'react';
import ChatRoom from './ChatRoom.js';

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select value={roomId} onChange={(e) => setRoomId(e.target.value)}>
          <option value='general'>general</option>
          <option value='travel'>travel</option>
          <option value='music'>music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

```js src/ChatRoom.js active
import { useState } from 'react';
import { useChatRoom } from './useChatRoom.js';

export default function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useChatRoom({
    roomId: roomId,
    serverUrl: serverUrl,
  });

  return (
    <>
      <label>
        Server URL:
        <input
          value={serverUrl}
          onChange={(e) => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}
```

```js src/useChatRoom.js
import { useEffect } from 'react';
import { createConnection } from './chat.js';
import { showNotification } from './notifications.js';

export function useChatRoom({ serverUrl, roomId }) {
  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId,
    };
    const connection = createConnection(options);
    connection.connect();
    connection.on('message', (msg) => {
      showNotification('New message: ' + msg);
    });
    return () => connection.disconnect();
  }, [roomId, serverUrl]);
}
```

```js src/chat.js
export function createConnection({ serverUrl, roomId }) {
  // A real implementation would actually connect to the server
  if (typeof serverUrl !== 'string') {
    throw Error('Expected serverUrl to be a string. Received: ' + serverUrl);
  }
  if (typeof roomId !== 'string') {
    throw Error('Expected roomId to be a string. Received: ' + roomId);
  }
  let intervalId;
  let messageCallback;
  return {
    connect() {
      console.log(
        '‚úÖ Connecting to "' + roomId + '" room at ' + serverUrl + '...'
      );
      clearInterval(intervalId);
      intervalId = setInterval(() => {
        if (messageCallback) {
          if (Math.random() > 0.5) {
            messageCallback('hey');
          } else {
            messageCallback('lol');
          }
        }
      }, 3000);
    },
    disconnect() {
      clearInterval(intervalId);
      messageCallback = null;
      console.log(
        '‚ùå Disconnected from "' + roomId + '" room at ' + serverUrl + ''
      );
    },
    on(event, callback) {
      if (messageCallback) {
        throw Error('Cannot add the handler twice.');
      }
      if (event !== 'message') {
        throw Error('Only "message" event is supported.');
      }
      messageCallback = callback;
    },
  };
}
```

```js src/notifications.js
import Toastify from 'toastify-js';
import 'toastify-js/src/toastify.css';

export function showNotification(message, theme = 'dark') {
  Toastify({
    text: message,
    duration: 2000,
    gravity: 'top',
    position: 'right',
    style: {
      background: theme === 'dark' ? 'black' : 'white',
      color: theme === 'dark' ? 'white' : 'black',
    },
  }).showToast();
}
```

```json package.json hidden
{
  "dependencies": {
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "toastify-js": "1.12.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

```css
input {
  display: block;
  margin-bottom: 20px;
}
button {
  margin-left: 10px;
}
```

</Sandpack>

---

## Cha√Ænage de hooks

- On prend la valeur de retour d'un hook

```js {2}
export default function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useChatRoom({
    roomId: roomId,
    serverUrl: serverUrl
  });
  // ...
```

- On passe cette valeur √† l'autre hook

```js {6}
export default function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useChatRoom({
    roomId: roomId,
    serverUrl: serverUrl
  });
  // ...
```

---

## Passer des gestionnaires d'√©v√©nements aux hooks personnalis√©s

- **Utilise `useEffectEvent` exp√©rimental, sauter √† diapo 31**

- Pr√©sentement, le gestionnaire d'√©v√©nement est d√©clar√© directement dans le hook

```js {9-11}
export function useChatRoom({ serverUrl, roomId }) {
  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId,
    };
    const connection = createConnection(options);
    connection.connect();
    connection.on('message', (msg) => {
      showNotification('New message: ' + msg);
    });
    return () => connection.disconnect();
  }, [roomId, serverUrl]);
}
```

---

## Ramener le gestionnaire d'√©v√©nement dans le composant

- On pourrait vouloir ramener cette logique dans le composant

```js {7-9}
export default function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useChatRoom({
    roomId: roomId,
    serverUrl: serverUrl,
    onReceiveMessage(msg) {
      showNotification('New message: ' + msg);
    }
  });
  // ...
```

---

## Modifier le hook pour recevoir l'√©v√©nement

```js {1,10,13}
export function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {
  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId,
    };
    const connection = createConnection(options);
    connection.connect();
    connection.on('message', (msg) => {
      onReceiveMessage(msg);
    });
    return () => connection.disconnect();
  }, [roomId, serverUrl, onReceiveMessage]); // ‚úÖ All dependencies declared
}
```

- Pas id√©al: le clavardage se re-synchronise (d√©connecte et reconnecte) √† chaque re-rendu

---

## Encapsuler l'√©v√©nement dans un √âv√©nement d'Effect

- On peut encapsuler le gestionnaire d'√©v√©nement dans un √âv√©nement d'Effect
- On peut alors l'enlever de la liste des d√©pendances
- Cela ne reconnecte plus √† chaque re-rendu

```js {1,4,5,15,18}
import { useEffect, useEffectEvent } from 'react';
// ...

export function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {
  const onMessage = useEffectEvent(onReceiveMessage);

  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId,
    };
    const connection = createConnection(options);
    connection.connect();
    connection.on('message', (msg) => {
      onMessage(msg);
    });
    return () => connection.disconnect();
  }, [roomId, serverUrl]); // ‚úÖ All dependencies declared
}
```

---

## Code avec √âv√©nement d'Effect

<Sandpack>

```js src/App.js
import { useState } from 'react';
import ChatRoom from './ChatRoom.js';

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select value={roomId} onChange={(e) => setRoomId(e.target.value)}>
          <option value='general'>general</option>
          <option value='travel'>travel</option>
          <option value='music'>music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

```js src/ChatRoom.js active
import { useState } from 'react';
import { useChatRoom } from './useChatRoom.js';
import { showNotification } from './notifications.js';

export default function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useChatRoom({
    roomId: roomId,
    serverUrl: serverUrl,
    onReceiveMessage(msg) {
      showNotification('New message: ' + msg);
    },
  });

  return (
    <>
      <label>
        Server URL:
        <input
          value={serverUrl}
          onChange={(e) => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}
```

```js src/useChatRoom.js
import { useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';
import { createConnection } from './chat.js';

export function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {
  const onMessage = useEffectEvent(onReceiveMessage);

  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId,
    };
    const connection = createConnection(options);
    connection.connect();
    connection.on('message', (msg) => {
      onMessage(msg);
    });
    return () => connection.disconnect();
  }, [roomId, serverUrl]);
}
```

```js src/chat.js
export function createConnection({ serverUrl, roomId }) {
  // A real implementation would actually connect to the server
  if (typeof serverUrl !== 'string') {
    throw Error('Expected serverUrl to be a string. Received: ' + serverUrl);
  }
  if (typeof roomId !== 'string') {
    throw Error('Expected roomId to be a string. Received: ' + roomId);
  }
  let intervalId;
  let messageCallback;
  return {
    connect() {
      console.log(
        '‚úÖ Connecting to "' + roomId + '" room at ' + serverUrl + '...'
      );
      clearInterval(intervalId);
      intervalId = setInterval(() => {
        if (messageCallback) {
          if (Math.random() > 0.5) {
            messageCallback('hey');
          } else {
            messageCallback('lol');
          }
        }
      }, 3000);
    },
    disconnect() {
      clearInterval(intervalId);
      messageCallback = null;
      console.log(
        '‚ùå Disconnected from "' + roomId + '" room at ' + serverUrl + ''
      );
    },
    on(event, callback) {
      if (messageCallback) {
        throw Error('Cannot add the handler twice.');
      }
      if (event !== 'message') {
        throw Error('Only "message" event is supported.');
      }
      messageCallback = callback;
    },
  };
}
```

```js src/notifications.js
import Toastify from 'toastify-js';
import 'toastify-js/src/toastify.css';

export function showNotification(message, theme = 'dark') {
  Toastify({
    text: message,
    duration: 2000,
    gravity: 'top',
    position: 'right',
    style: {
      background: theme === 'dark' ? 'black' : 'white',
      color: theme === 'dark' ? 'white' : 'black',
    },
  }).showToast();
}
```

```json package.json hidden
{
  "dependencies": {
    "react": "experimental",
    "react-dom": "experimental",
    "react-scripts": "latest",
    "toastify-js": "1.12.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

```css
input {
  display: block;
  margin-bottom: 20px;
}
button {
  margin-left: 10px;
}
```

</Sandpack>

---

## Quand utiliser des Hooks personnalis√©s

- Inutile d'isoler un hook personnalis√© pour chaque ligne de code dupliqu√©e
- On peut tol√©rer un peu de duplication
- Ex: inutile d'isoler un hook `useFormInput` quand on n'a qu'un seul champ dans le formulaire (un seul `useState` est n√©cessaire)
- Isoler un Effect peut rendre notre code plus clair

---

## Exemple: G√©rer formulaire sans hook personnalis√©

- Imaginons un composant `ShippingForm` avec deux listes d√©loulantes:
  - Une liste de villes
  - Une liste de quartiers qui change d'apr√®s la ville s√©lectionn√©e

<TwoColumns style={{fontSize:"0.9em",alignItems: "top"}}>

```js {3-16}
function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  // This Effect fetches cities for a country
  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });
    return () => {
      ignore = true;
    };
  }, [country]);
```

```js {3-18}
const [city, setCity] = useState(null);
const [areas, setAreas] = useState(null);
// This Effect fetches areas for the selected city
useEffect(() => {
  if (city) {
    let ignore = false;
    fetch(`/api/areas?city=${city}`)
      .then((response) => response.json())
      .then((json) => {
        if (!ignore) {
          setAreas(json);
        }
      });
    return () => {
      ignore = true;
    };
  }
}, [city]);

// ...
```

</TwoColumns>

- Le code est r√©p√©titif, mais c'est correct de garder ces Effects s√©par√©s
- Quand on synchronise des choses diff√©rentes, on les s√©pare dans des Effects distincts

---

## Ajouter un hook

- On pourrait extraire la logique commune dans un hook `useData`:

```js {2-18}
function useData(url) {
  const [data, setData] = useState(null);
  useEffect(() => {
    if (url) {
      let ignore = false;
      fetch(url)
        .then((response) => response.json())
        .then((json) => {
          if (!ignore) {
            setData(json);
          }
        });
      return () => {
        ignore = true;
      };
    }
  }, [url]);
  return data;
}
```

---

## Remplacer les Effects par des appels au hook `useData`

```js {2,4}
function ShippingForm({ country }) {
  const cities = useData(`/api/cities?country=${country}`);
  const [city, setCity] = useState(null);
  const areas = useData(city ? `/api/areas?city=${city}` : null);
  // ...
```

- Le flot de donn√©es est plus clair avec des hooks personnalis√©s
- Les Effects sont encapsul√©s, difficile de faire l'erreur d'ajouter des d√©pendances superflues au tableau de d√©pendances
- Les effects auront tendance √† √™tre encapsul√©es dans des hooks personnalis√©s

---

## Deep Dive: cr√©er les Hooks sur des cas concrets de haut niveau

- On d√©bute en choisissant un nom du hook
- Si le nom √† choisir n'est pas clair, l'Effect est trop fortement coupl√© au reste du composant
- Il faut simplifier avant d'isoler
- Un bon nom de hook indique ce qu'il fait, ce qu'il prend comme param√®tre, ce qu'il retourne
  - ‚úÖ `useData(url)`
  - ‚úÖ `useImpressionLog(eventName, extraData)`
  - ‚úÖ `useChatRoom(options)`

<hr />

- Quand on synchronise avec un syst√®me externe, le nom sera plus technique, en utilisant du jargon sp√©cifique √† ce syst√®me
  - ‚úÖ `useMediaQuery(query)`
  - ‚úÖ `useSocket(url)`
  - ‚úÖ `useIntersectionObserver(ref, options)`

---

## √âvitez des hooks de type "lifecycle"

Ces noms encapsulent `useEffect`, sans ajouter de valeur:

- üî¥ `useMount(fn)`
- üî¥ `useEffectOnce(fn)`
- üî¥ `useUpdateEffect(fn)`

---

## Mauvaise pratique: hook useMount

- Un hook `useMount` pourrait garantir que le code ne roule que sur "on mount" (le montage):

<div style={{fontSize:'0.8em'}}>

```js {4-5,12-13}
function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  // üî¥ Avoid: using custom "lifecycle" Hooks
  useMount(() => {
    const connection = createConnection({ roomId, serverUrl });
    connection.connect();
  });
  // ...
}

// üî¥ Avoid: creating custom "lifecycle" Hooks
function useMount(fn) {
  useEffect(() => {
    fn();
  }, []); // üî¥ React Hook useEffect has a missing dependency: 'fn'
}
```

</div>

- **`useMount` n'utilise pas le paradigme React**
- Dans cet exemple, on ne r√©agit pas aux changements de `roomId` ou `serverUrl`
- Le linter ne peut avertir, car on ne valide les d√©pendances que pour les appels √† `useEffect`

---

## On pr√©f√®re utiliser useEffect plut√¥t que useMount

<div style={{fontSize:'0.8em'}}>

```js
function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  // ‚úÖ Good: two raw Effects separated by purpose

  useEffect(() => {
    const connection = createConnection({ serverUrl, roomId });
    connection.connect();
    return () => connection.disconnect();
  }, [serverUrl, roomId]);

  useEffect(() => {
    post('/analytics/event', { eventName: 'visit_chat', roomId });
  }, [roomId]);

  // ...
}
```

</div>

- Alternative: On pourrait extraire des hooks personnalis√©s

<div style={{fontSize:'0.8em'}}>

```js
function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  // ‚úÖ Great: custom Hooks named after their purpose
  useChatRoom({ serverUrl, roomId });
  useImpressionLog('visit_chat', { roomId });
  // ...
}
```

</div>

---

## Bon patron pour les hooks personnalis√©s

- Un bon hook personnalis√© rend le code plus d√©claratif
- Il contraint son usage √† des sc√©narios sp√©cifiques
- `useChatRoom(options)` se connecte √† un clavardage
- `useImpressionLog(eventName, extraData)` est utilis√© pour envoyer de la t√©l√©m√©trie analytique
- Si le hook est tr√®s abstrait, sans contraintes, cela g√©n√®re des probl√®mes d'architecture √† la longue

---

## Bonne pratique: Encapsuler les Effects dans des hooks personnalis√©s

- Les Effects sont des "√©chappatoires" (escape hatch)
- On les utilise pour "sortir de React", quand il n'y a pas d'autres moyens
- L'√©quipe de React va r√©duire le nombre d'Effect dans le code
  - Les futures versions de React fourniront des fonctionnalit√©s additionnelles
- Encapsuler les effects dans des hooks personnalis√©s rend la mise √† jour future plus facile

---

## Code avec Effect encapsul√© dans hook

Revenons √† cet exemple

<Sandpack>

```js
import { useOnlineStatus } from './useOnlineStatus.js';

function StatusBar() {
  const isOnline = useOnlineStatus();
  return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>;
}

function SaveButton() {
  const isOnline = useOnlineStatus();

  function handleSaveClick() {
    console.log('‚úÖ Progress saved');
  }

  return (
    <button disabled={!isOnline} onClick={handleSaveClick}>
      {isOnline ? 'Save progress' : 'Reconnecting...'}
    </button>
  );
}

export default function App() {
  return (
    <>
      <SaveButton />
      <StatusBar />
    </>
  );
}
```

```js src/useOnlineStatus.js active
import { useState, useEffect } from 'react';

export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  return isOnline;
}
```

</Sandpack>

---

## Probl√®mes du Code

- Dans le code pr√©c√©dent, `useOnlineStatus` est cod√© avec `useState` et `useEffect`
- Le code n'est pas parfait
  - On assume qu'au moment du montage, `isOnline` est √† `true`
  - Mais le r√©seau pourrait √™tre d√©j√† d√©connect√©
  - On pourrait alors utiliser `navigator.onLine` pour retourner l'√©tat du r√©seau
  - Mais cet appel ne fonctionnerait pas sur la g√©n√©ration serveur de HTML

---

## Solution possible

- React 18 inclut un API d√©di√© nomm√© `useSyncExternalStore` qui g√®re ces probl√®mes

<Sandpack>

```js
import { useOnlineStatus } from './useOnlineStatus.js';

function StatusBar() {
  const isOnline = useOnlineStatus();
  return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>;
}

function SaveButton() {
  const isOnline = useOnlineStatus();

  function handleSaveClick() {
    console.log('‚úÖ Progress saved');
  }

  return (
    <button disabled={!isOnline} onClick={handleSaveClick}>
      {isOnline ? 'Save progress' : 'Reconnecting...'}
    </button>
  );
}

export default function App() {
  return (
    <>
      <SaveButton />
      <StatusBar />
    </>
  );
}
```

```js src/useOnlineStatus.js active
import { useSyncExternalStore } from 'react';

function subscribe(callback) {
  window.addEventListener('online', callback);
  window.addEventListener('offline', callback);
  return () => {
    window.removeEventListener('online', callback);
    window.removeEventListener('offline', callback);
  };
}

export function useOnlineStatus() {
  return useSyncExternalStore(
    subscribe,
    () => navigator.onLine, // How to get the value on the client
    () => true // How to get the value on the server
  );
}
```

</Sandpack>

---

## D√©tails

- Aucunement besoin de changer nos composants
- Seul le hook change (on passe de `useEffect` √† `useSyncExternalStore`)

```js {2,7}
function StatusBar() {
  const isOnline = useOnlineStatus();
  // ...
}

function SaveButton() {
  const isOnline = useOnlineStatus();
  // ...
}
```

- Encapsuler les Effects dans des hooks personnalis√©s est b√©n√©fique:

1. Le flot de donn√©es des Effects est plus explicite
1. Le focus du composant sera sur l'intention, plut√¥t que les d√©tails des Effects
1. Quand React ajoute de nouvelles fonctionnalit√©s, on pourra enlever les Effects sans affecter les composants

- Il existe aussi plusieurs hooks fournis par la communaut√©

---

## Deep Dive: React 19 fournit une solution pour le chargement les donn√©es

Le code de React 19 ressemble √† ceci:

```js {1,4,6}
import { use } from 'react'; // Not available yet!

function ShippingForm({ country }) {
  const cities = use(fetch(`/api/cities?country=${country}`));
  const [city, setCity] = useState(null);
  const areas = city ? use(fetch(`/api/areas?city=${city}`)) : null;
  // ...
```

- L'approche avec useEffect existe encore
- Le code existant est compatible

---

## Plus d'une approche possible

- Imaginons un composant qui veut utiliser une animation fade-in, utilisant l'API `requestAnimationFrame`
- On d√©bute avec un Effect qui d√©marre une boucle pour l'animation
- √Ä chaque frame, on change l'opacit√© du noeud DOM, provenant du ref, jusqu'√† `1`

<Sandpack>

```js
import { useState, useEffect, useRef } from 'react';

function Welcome() {
  const ref = useRef(null);

  useEffect(() => {
    const duration = 1000;
    const node = ref.current;

    let startTime = performance.now();
    let frameId = null;

    function onFrame(now) {
      const timePassed = now - startTime;
      const progress = Math.min(timePassed / duration, 1);
      onProgress(progress);
      if (progress < 1) {
        // We still have more frames to paint
        frameId = requestAnimationFrame(onFrame);
      }
    }

    function onProgress(progress) {
      node.style.opacity = progress;
    }

    function start() {
      onProgress(0);
      startTime = performance.now();
      frameId = requestAnimationFrame(onFrame);
    }

    function stop() {
      cancelAnimationFrame(frameId);
      startTime = null;
      frameId = null;
    }

    start();
    return () => stop();
  }, []);

  return (
    <h1 className='welcome' ref={ref}>
      Welcome
    </h1>
  );
}

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(!show)}>{show ? 'Remove' : 'Show'}</button>
      <hr />
      {show && <Welcome />}
    </>
  );
}
```

```css
label,
button {
  display: block;
  margin-bottom: 20px;
}
html,
body {
  min-height: 300px;
}
.welcome {
  opacity: 0;
  color: white;
  padding: 50px;
  text-align: center;
  font-size: 50px;
  background-image: radial-gradient(
    circle,
    rgba(63, 94, 251, 1) 0%,
    rgba(252, 70, 107, 1) 100%
  );
}
```

</Sandpack>

---

## Isoler vers un hook personnalis√©

Pour rendre le composant plus lisible, on isole la logique dans un hook personnalis√© `useFadeIn`

<Sandpack>

```js
import { useState, useEffect, useRef } from 'react';
import { useFadeIn } from './useFadeIn.js';

function Welcome() {
  const ref = useRef(null);

  useFadeIn(ref, 1000);

  return (
    <h1 className='welcome' ref={ref}>
      Welcome
    </h1>
  );
}

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(!show)}>{show ? 'Remove' : 'Show'}</button>
      <hr />
      {show && <Welcome />}
    </>
  );
}
```

```js src/useFadeIn.js
import { useEffect } from 'react';

export function useFadeIn(ref, duration) {
  useEffect(() => {
    const node = ref.current;

    let startTime = performance.now();
    let frameId = null;

    function onFrame(now) {
      const timePassed = now - startTime;
      const progress = Math.min(timePassed / duration, 1);
      onProgress(progress);
      if (progress < 1) {
        // We still have more frames to paint
        frameId = requestAnimationFrame(onFrame);
      }
    }

    function onProgress(progress) {
      node.style.opacity = progress;
    }

    function start() {
      onProgress(0);
      startTime = performance.now();
      frameId = requestAnimationFrame(onFrame);
    }

    function stop() {
      cancelAnimationFrame(frameId);
      startTime = null;
      frameId = null;
    }

    start();
    return () => stop();
  }, [ref, duration]);
}
```

```css
label,
button {
  display: block;
  margin-bottom: 20px;
}
html,
body {
  min-height: 300px;
}
.welcome {
  opacity: 0;
  color: white;
  padding: 50px;
  text-align: center;
  font-size: 50px;
  background-image: radial-gradient(
    circle,
    rgba(63, 94, 251, 1) 0%,
    rgba(252, 70, 107, 1) 100%
  );
}
```

</Sandpack>

---

## Isoler vers un second hook

- On sous-divise `useFadeIn` avec `useAnimationLoop`

<Sandpack>

```js
import { useState, useEffect, useRef } from 'react';
import { useFadeIn } from './useFadeIn.js';

function Welcome() {
  const ref = useRef(null);

  useFadeIn(ref, 1000);

  return (
    <h1 className='welcome' ref={ref}>
      Welcome
    </h1>
  );
}

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(!show)}>{show ? 'Remove' : 'Show'}</button>
      <hr />
      {show && <Welcome />}
    </>
  );
}
```

```js src/useFadeIn.js active
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';

export function useFadeIn(ref, duration) {
  const [isRunning, setIsRunning] = useState(true);

  useAnimationLoop(isRunning, (timePassed) => {
    const progress = Math.min(timePassed / duration, 1);
    ref.current.style.opacity = progress;
    if (progress === 1) {
      setIsRunning(false);
    }
  });
}

function useAnimationLoop(isRunning, drawFrame) {
  const onFrame = useEffectEvent(drawFrame);

  useEffect(() => {
    if (!isRunning) {
      return;
    }

    const startTime = performance.now();
    let frameId = null;

    function tick(now) {
      const timePassed = now - startTime;
      onFrame(timePassed);
      frameId = requestAnimationFrame(tick);
    }

    tick();
    return () => cancelAnimationFrame(frameId);
  }, [isRunning]);
}
```

```css
label,
button {
  display: block;
  margin-bottom: 20px;
}
html,
body {
  min-height: 300px;
}
.welcome {
  opacity: 0;
  color: white;
  padding: 50px;
  text-align: center;
  font-size: 50px;
  background-image: radial-gradient(
    circle,
    rgba(63, 94, 251, 1) 0%,
    rgba(252, 70, 107, 1) 100%
  );
}
```

```json package.json hidden
{
  "dependencies": {
    "react": "experimental",
    "react-dom": "experimental",
    "react-scripts": "latest"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

</Sandpack>

---

## Isoler vers une classe

- Plut√¥t que d'isoler le code dans des hooks, on pourrait isoler le code dans des classes

<Sandpack>

```js
import { useState, useEffect, useRef } from 'react';
import { useFadeIn } from './useFadeIn.js';

function Welcome() {
  const ref = useRef(null);

  useFadeIn(ref, 1000);

  return (
    <h1 className='welcome' ref={ref}>
      Welcome
    </h1>
  );
}

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(!show)}>{show ? 'Remove' : 'Show'}</button>
      <hr />
      {show && <Welcome />}
    </>
  );
}
```

```js src/useFadeIn.js active
import { useState, useEffect } from 'react';
import { FadeInAnimation } from './animation.js';

export function useFadeIn(ref, duration) {
  useEffect(() => {
    const animation = new FadeInAnimation(ref.current);
    animation.start(duration);
    return () => {
      animation.stop();
    };
  }, [ref, duration]);
}
```

```js src/animation.js
export class FadeInAnimation {
  constructor(node) {
    this.node = node;
  }
  start(duration) {
    this.duration = duration;
    this.onProgress(0);
    this.startTime = performance.now();
    this.frameId = requestAnimationFrame(() => this.onFrame());
  }
  onFrame() {
    const timePassed = performance.now() - this.startTime;
    const progress = Math.min(timePassed / this.duration, 1);
    this.onProgress(progress);
    if (progress === 1) {
      this.stop();
    } else {
      // We still have more frames to paint
      this.frameId = requestAnimationFrame(() => this.onFrame());
    }
  }
  onProgress(progress) {
    this.node.style.opacity = progress;
  }
  stop() {
    cancelAnimationFrame(this.frameId);
    this.startTime = null;
    this.frameId = null;
    this.duration = 0;
  }
}
```

```css
label,
button {
  display: block;
  margin-bottom: 20px;
}
html,
body {
  min-height: 300px;
}
.welcome {
  opacity: 0;
  color: white;
  padding: 50px;
  text-align: center;
  font-size: 50px;
  background-image: radial-gradient(
    circle,
    rgba(63, 94, 251, 1) 0%,
    rgba(252, 70, 107, 1) 100%
  );
}
```

</Sandpack>

- Les Effects permettent de connecter React vers des syst√®mes externes.
- On n√©cessite parfois plus de coordinations entre les Effects
  - (pour chainer diff√©rentes animations)
  - Il serait alors logique d'extraire le code hors des Effects et Hook.
- Ce code isol√© devient alors un "syst√®me externe"
- Les Effets peuvent alors demeurer simple
- Ils envoient des messages pour interagir avec le syst√®me externe

---

## Simplifier avec des animations CSS

On pourrait √©viter toute la complexit√© du JavaScript en utilisant une animation CSS

<Sandpack>

```js
import { useState, useEffect, useRef } from 'react';
import './welcome.css';

function Welcome() {
  return <h1 className='welcome'>Welcome</h1>;
}

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(!show)}>{show ? 'Remove' : 'Show'}</button>
      <hr />
      {show && <Welcome />}
    </>
  );
}
```

```css src/styles.css
label,
button {
  display: block;
  margin-bottom: 20px;
}
html,
body {
  min-height: 300px;
}
```

```css src/welcome.css active
.welcome {
  color: white;
  padding: 50px;
  text-align: center;
  font-size: 50px;
  background-image: radial-gradient(
    circle,
    rgba(63, 94, 251, 1) 0%,
    rgba(252, 70, 107, 1) 100%
  );

  animation: fadeIn 1000ms;
}

@keyframes fadeIn {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
```

</Sandpack>

- Les hooks ne sont pas n√©cessaires ici!

---

## R√©sum√©

- Hooks personnalis√©s permettent de partager la logique entre les composants
- Hooks personnalis√©s d√©butent par use, suivi d'une lettre majuscule
- Hooks personnalis√©s partage la logique d'√©tat, mais pas les valeurs d'√©tat
- On peut passer des valeurs r√©actives d'un hook √† l'autre, elles restent √† jour
- Les hooks r√©-ex√©cutent √† chaque re-rendu
- Hooks personnalis√©s doivent √™tre purs (comme le code des composants)
- Encapsulez les gestionnaires d'√©v√©nements re√ßu par le Hook dans un √âv√©nement d'Effect
- Ne pas cr√©er de custom Hook tel que useMount. Gardez leur comportement sp√©cifique
- D√©cidez comment diviser le code

---

## D√©fi 1: Extraire un hook useCounter

- Ce code utilise un √©tat et effect pour afficher un nombre qui incr√©mente
- Isolez cette logique dans un hook nomm√© `useCounter`
- Simpifiez le `Counter`:

```js
export default function Counter() {
  const count = useCounter();
  return <h1>Seconds passed: {count}</h1>;
}
```

<Sandpack>

```js
import { useState, useEffect } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);
  useEffect(() => {
    const id = setInterval(() => {
      setCount((c) => c + 1);
    }, 1000);
    return () => clearInterval(id);
  }, []);
  return <h1>Seconds passed: {count}</h1>;
}
```

```js src/useCounter.js
// Write your custom Hook in this file!
```

</Sandpack>

---

## D√©fi 2: Rendre le d√©lai configurable

Dans cet exemple, il faudrait que le slider `delay` passe sa valeur √† useCounter, plut√¥t que d'utiliser `1000` ms.

<Sandpack>

```js
import { useState } from 'react';
import { useCounter } from './useCounter.js';

export default function Counter() {
  const [delay, setDelay] = useState(1000);
  const count = useCounter();
  return (
    <>
      <label>
        Tick duration: {delay} ms
        <br />
        <input
          type='range'
          value={delay}
          min='10'
          max='2000'
          onChange={(e) => setDelay(Number(e.target.value))}
        />
      </label>
      <hr />
      <h1>Ticks: {count}</h1>
    </>
  );
}
```

```js src/useCounter.js
import { useState, useEffect } from 'react';

export function useCounter() {
  const [count, setCount] = useState(0);
  useEffect(() => {
    const id = setInterval(() => {
      setCount((c) => c + 1);
    }, 1000);
    return () => clearInterval(id);
  }, []);
  return count;
}
```

</Sandpack>

---

## D√©fi 3: Extraire `useInterval` hors de `useCounter`

`useCounter` fait deux choses: g√®rer un interval, et incr√©menter l'√âtat. S√©parons la logique en 2 Hooks, nomm√©s `useInterval` et `useCounter`. Voici le code de `useCounter` d√©sir√©:

```js
export function useCounter(delay) {
  const [count, setCount] = useState(0);
  useInterval(() => {
    setCount((c) => c + 1);
  }, delay);
  return count;
}
```

<Sandpack>

```js
import { useState } from 'react';
import { useCounter } from './useCounter.js';

export default function Counter() {
  const count = useCounter(1000);
  return <h1>Seconds passed: {count}</h1>;
}
```

```js src/useCounter.js
import { useState, useEffect } from 'react';

export function useCounter(delay) {
  const [count, setCount] = useState(0);
  useEffect(() => {
    const id = setInterval(() => {
      setCount((c) => c + 1);
    }, delay);
    return () => clearInterval(id);
  }, [delay]);
  return count;
}
```

```js src/useInterval.js
// Write your Hook here!
```

</Sandpack>

---

## D√©fi 4: R√©parer l'intervalle qui r√©initialise

On utilise deux `interval`, un pour le counter, un autre pour changer la couleur du fond. Bogue: la couleur du fond ne change pas.

Ajoutons des logs dans `useInterval`:

```js {2,5}
useEffect(() => {
  console.log('‚úÖ Setting up an interval with delay ', delay);
  const id = setInterval(onTick, delay);
  return () => {
    console.log('‚ùå Clearing an interval with delay ', delay);
    clearInterval(id);
  };
}, [onTick, delay]);
```

Y a-t-il un probl√®me de d√©pendance? R√©parez le code.

<Hint>

Il y a un gestionnaire d'√©v√©nement dans `useInterval`, qui s'ajoute dans la liste de d√©pendance. Il faudrait utiliser `useEventEffect`.

</Hint>

<Sandpack>

```json package.json hidden
{
  "dependencies": {
    "react": "experimental",
    "react-dom": "experimental",
    "react-scripts": "latest"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

```js
import { useCounter } from './useCounter.js';
import { useInterval } from './useInterval.js';

export default function Counter() {
  const count = useCounter(1000);

  useInterval(() => {
    const randomColor = `hsla(${Math.random() * 360}, 100%, 50%, 0.2)`;
    document.body.style.backgroundColor = randomColor;
  }, 2000);

  return <h1>Seconds passed: {count}</h1>;
}
```

```js src/useCounter.js
import { useState } from 'react';
import { useInterval } from './useInterval.js';

export function useCounter(delay) {
  const [count, setCount] = useState(0);
  useInterval(() => {
    setCount((c) => c + 1);
  }, delay);
  return count;
}
```

```js src/useInterval.js
import { useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';

export function useInterval(onTick, delay) {
  useEffect(() => {
    const id = setInterval(onTick, delay);
    return () => {
      clearInterval(id);
    };
  }, [onTick, delay]);
}
```

</Sandpack>

---

## D√©fi 5: Ajouter un mouvement en d√©lai

- `usePointerPosition()` suit la position de la souris.
- Il y a 5 points rouges.
- Ils apparaissent pr√©sentement √† la m√™me position.
- On d√©sire un mouvement en d√©lai, chaque point suit la position du point pr√©c√©dent
- On doit modifier le hook personnalis√© `useDelayedValue`.
  - Retourne pr√©sement la valeur fournie
  - Devrait retourner la valeur d'il y a `delay` millisecondes
  - N√©cessite √âtat et Effect

<Hint>

Il faut stocker `delayedValue` dans l'√©tat. Quand la valeur change, un timeout de `delay` ex√©cute le setter. Ce timeout est cr√©√© dans un Effect.

<div style={{fontSize:'0.6em'}}>

```jsx
const [delayedValue, setDelayedValue] = useState(value);

useEffect(() => {
  setTimeout(() => {
    setDelayedValue(value);
  }, delay);
}, [value, delay]);

return delayedValue;
```

</div>
</Hint>

<Sandpack>

```js
import { usePointerPosition } from './usePointerPosition.js';

function useDelayedValue(value, delay) {
  // TODO: Implement this Hook
  return value;
}

export default function Canvas() {
  const pos1 = usePointerPosition();
  const pos2 = useDelayedValue(pos1, 50);
  const pos3 = useDelayedValue(pos2, 100);
  const pos4 = useDelayedValue(pos3, 150);
  const pos5 = useDelayedValue(pos3, 200);
  return (
    <>
      <Dot position={pos1} opacity={1} />
      <Dot position={pos2} opacity={0.8} />
      <Dot position={pos3} opacity={0.6} />
      <Dot position={pos4} opacity={0.4} />
      <Dot position={pos5} opacity={0.2} />
    </>
  );
}

function Dot({ position, opacity }) {
  return (
    <div
      style={{
        position: 'absolute',
        backgroundColor: 'pink',
        borderRadius: '50%',
        opacity,
        transform: `translate(${position.x}px, ${position.y}px)`,
        pointerEvents: 'none',
        left: -20,
        top: -20,
        width: 40,
        height: 40,
      }}
    />
  );
}
```

```js src/usePointerPosition.js
import { useState, useEffect } from 'react';

export function usePointerPosition() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  useEffect(() => {
    function handleMove(e) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
    window.addEventListener('pointermove', handleMove);
    return () => window.removeEventListener('pointermove', handleMove);
  }, []);
  return position;
}
```

```css
body {
  min-height: 300px;
}
```

</Sandpack>
