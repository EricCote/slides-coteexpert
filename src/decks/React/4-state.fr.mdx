---
title: 'État (State)'
date: '2023-02-22'
---

# État (State)

---

## État

- Un composant doit parfois modifier son affichage suite à une interaction.
  - Taper sur le clavier met à jour un champ de saisie
  - Cliquer "Suivant" sur un carousel photo affiche la prochaine image
  - Cliquer "Acheter" ajoute un produit dans un panier d'achat
- Un composant doit gérer sa "mémoire": la valeur du champ, l'image courante, le panier d'achat
- Ce sont des exemples **d'États** (State)

---

import myFile from './4-state/datafile.js';

## Une variable ne suffit pas

<Sandpack  files={{
    "src/data.js": myFile
  }} s="60" >

```js
import { sculptureList } from './data.js';

export default function Gallery() {
  let index = 0;

  function handleClick() {
    index = index + 1;
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <img src={sculpture.url} alt={sculpture.alt} />
      <p>{sculpture.description}</p>
    </>
  );
}
```

```js src/useForceRefresh.js hidden
import { useState } from 'react';

export default function useForceRefresh() {
  const [_, forceRefresh] = useState({});
  return function () {
    forceRefresh({});
  };
}
```

```css
h2 {
  margin-top: 10px;
  margin-bottom: 0;
}
h3 {
  margin-top: 5px;
  font-weight: normal;
  font-size: 100%;
}
img {
  width: 120px;
  height: 120px;
}
button {
  display: block;
  margin-top: 10px;
  margin-bottom: 10px;
}
```

</Sandpack>

`handleClick` modifie une variable locale, `index`. Mais il y a deux problèmes:

1. **Une variable locale ne persiste pas entre les rendus.** Chaque fois qu'on fait un nouveau rendu, toutes les variables locales sont recréées.
2. **Modifier une variable locale ne génère pas de rendu .** React ne réalise pas qu'il faut générer un nouveau rendu.

---

## Solution fournie par React

Il faut:

1. **Conserver** les données entre les rendus
2. **Déclencher** la génération d'un nouveau rendu (_re-rendering_)

Le Hook [`useState`](https://reactjs.org/reference/react/useState) fournit ces deux choses.

1. **Variable state (État)** Garde les données entre les rendus.
2. **Fonction setter ou setState (Fonction modification d'état)** pour modifier la donnée et générer un rendu.

---

## Ajouter une variable State

```js
import { useState } from 'react';
...

const [data, setData] = useState(0);
```

- `data` est une variable d'état (pour lire)
- `setData` est la fonction setter (pour modifier).
  <hr />
- La syntaxe `[` et `]` se nomme _décomposition de tableau_ ([array destructuring](https://javascript.info/destructuring-assignment))
- Cela permet de lire les valeurs provenant d'un tableau
- Le tableau retourné par `useState` a toujours 2 items

---

## Modifier le state

On modifie le state dans `handleClick`.

<Sandpack    files={{
    "src/data.js": myFile
  }} s="60" >

```js
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);

  function handleClick() {
    setIndex(index + 1);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <img src={sculpture.url} alt={sculpture.alt} />
      <p>{sculpture.description}</p>
    </>
  );
}
```

```css
h2 {
  margin-top: 10px;
  margin-bottom: 0;
}
h3 {
  margin-top: 5px;
  font-weight: normal;
  font-size: 100%;
}
img {
  width: 120px;
  height: 120px;
}
button {
  display: block;
  margin-top: 10px;
  margin-bottom: 10px;
}
```

</Sandpack>

---

## useState, le premier Hook

- `useState` n'est pas le seul _hook_
- Toute fonction démarrant par "`use`" est un _hook_
- Les _hooks_ sont des fonctions spéciales, disponibles seulement pendant que React fait un [rendu](https://reactjs.org/learn/render-and-commit#step-1-trigger-a-render)
- Les _hooks_ permettent de se connecter (_"hook into"_) dans les fonctionnalités de React
- L'état (_State_) est une fonctionnalité, mais on en verra d'autres (effect, context, memo)

---

## Caractéristiques des Hooks

<Alert type='warning'>
  **Attention:** les hooks (débutant par `use`) ne peuvent être appelés qu'à
  partir du "top niveau" de votre composant, ou de vos propres hooks.
</Alert>

On ne peut **PAS** appeler un hook dans:

- une condition
- une boucle
- une fonction imbriquée (gestionnaire d'événements).

<hr />

- Même si les hooks sont des fonctions, considérez les comme des déclarations des besoins du composant
- On utilise les fonctionnalités React au "top niveau" du composant
- Similaire aux modules importés au début des fichiers

---

## Anatomie du `useState`

Quand on appelle [`useState`](https://beta.reactjs.org/reference/react/useState), React stocke la valeur.

```js
const [index, setIndex] = useState(0);
```

**Convention:**

- On nomme cette paire: `const [chose, setChose]`.
- On pourrait nommer différemment, mais cette convention aide la compréhension.

L'argument de `useState` est la **valeur initiale** de l'état. (Ici, la valeur 0).

À chaque rendu, `useState` donne un tableau de 2 valeurs:

1. La **variable d'état** (`index`) qui stocke la valeur.
2. La **fonction state setter** (`setIndex`) pour modifier la valeur de l'état et déclencher un rendu.

---

## Détail du Hook:

```js
const [index, setIndex] = useState(0);

function handleNextClick() {
  setIndex(index + 1);
}
```

1. **Au premier rendu**, on passe `0` à `useState`, React stocke `0` dans l'état, le hook retourne `[0, setIndex]`.
2. **On clique et met à jour l'état** l'événement appelle `setIndex(index + 1)`. Avec `index` de `0`, cela appelle `setIndex(1)`. React stocke `1` et génère un nouveau rendu.
3. **Au second rendu** React appelle `useState(0)`, mais React a déjà stocké `1` dans `index`. Donc React retourne `[1, setIndex]`.
4. Ainsi de suite...

---

## Composants avec des états multiples

- Un composant peut avoir de multiples variables d'états
- L'exemple suivant possède deux variables d'état:
  - un nombre `index` (no de page)
  - un booléen `showMore` (bascule quand on clique "Afficher Détails")

<Sandpack    files={{
    "src/data.js": myFile
  }} s="60" >

```js
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleNextClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Hide' : 'Show'} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img src={sculpture.url} alt={sculpture.alt} />
    </>
  );
}
```

```css
h2 {
  margin-top: 10px;
  margin-bottom: 0;
}
h3 {
  margin-top: 5px;
  font-weight: normal;
  font-size: 100%;
}
img {
  width: 120px;
  height: 120px;
}
button {
  display: block;
  margin-top: 10px;
  margin-bottom: 10px;
}
```

</Sandpack>

On sépare le state quand les valeurs ne sont pas liées. (C'est le cas ci-haut).

Si les valeurs sont liées ou modifiées ensemble, on préfère les combiner dans un objet unique. (Ex: un formulaire)

---

## Avancé: comment ça marche

- Il n'y a pas d'identifiant passé en arguments à `useState`
- Comment React sait quelle valeur retourner?
- Les hooks se fient sur **un ordre d'appel, qui reste stable** dans un composant donné.
- C'est grâce à la règle des hooks: il faut les placer au "top niveau" d'un composant. (Il y a même un [linter](https://www.npmjs.com/package/eslint-plugin-react-hooks) qui permet de détecter les erreurs.)
- React utilise un tableau de paires pour chaque composant.
- Il maintient un index sur l'usage des hooks et l'incrémente à chaque appel de useState. Voir: [React Hooks: Not Magic, Just Arrays.](https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e)
  <hr />
  L'exemple suivant n'utilise **PAS** React. Mais il démontre comment fonctionne
  les hooks:

<Sandpack    files={{
    "src/data.js": myFile
  }}  s="60" >

```js src/index.js active
import { sculptureList } from './data.js';

let componentHooks = [];
let currentHookIndex = 0;

// Démontre le concept de useState (simplifié).
function useState(initialState) {
  let pair = componentHooks[currentHookIndex];
  if (pair) {
    // Après le premier rendu,
    // La paire d'état existe déjà
    // Il faut incrémenter l'index et retourner la paire
    currentHookIndex++;
    return pair;
  }

  // Quand c'est un premier rendu,
  // On créé la paire d'état et on la stocke.
  pair = [initialState, setState];

  function setState(nextState) {
    // Quand on modifie l'état,
    // On met la nouvelle valeur dans la paire
    pair[0] = nextState;
    updateDOM();
  }

  // Stockons la paire pour les prochains rendus
  // Et on se prépare pour le prochain appel Hook
  componentHooks[currentHookIndex] = pair;
  currentHookIndex++;
  return pair;
}

function Gallery() {
  // Chaque appel à useState() obtient la paire suivante.
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  // On n'utilise pas React
  // On retourne un objet plutôt que du JSX.
  return {
    onNextClick: handleNextClick,
    onMoreClick: handleMoreClick,
    header: `${sculpture.name} by ${sculpture.artist}`,
    counter: `${index + 1} of ${sculptureList.length}`,
    more: `${showMore ? 'Hide' : 'Show'} details`,
    description: showMore ? sculpture.description : null,
    imageSrc: sculpture.url,
    imageAlt: sculpture.alt,
  };
}

function updateDOM() {
  // Reset the current Hook index
  // before rendering the component.
  currentHookIndex = 0;
  let output = Gallery();

  // Update the DOM to match the output.
  // This is the part React does for you.
  nextButton.onclick = output.onNextClick;
  header.textContent = output.header;
  moreButton.onclick = output.onMoreClick;
  moreButton.textContent = output.more;
  image.src = output.imageSrc;
  image.alt = output.imageAlt;
  if (output.description !== null) {
    description.textContent = output.description;
    description.style.display = '';
  } else {
    description.style.display = 'none';
  }
}

let nextButton = document.getElementById('nextButton');
let header = document.getElementById('header');
let moreButton = document.getElementById('moreButton');
let description = document.getElementById('description');
let image = document.getElementById('image');

// Make UI match the initial state.
updateDOM();
```

```html public/index.html
<button id="nextButton">Next</button>
<h3 id="header"></h3>
<button id="moreButton"></button>
<p id="description"></p>
<img id="image" />

<style>
  * {
    box-sizing: border-box;
  }
  body {
    font-family: sans-serif;
    margin: 20px;
    padding: 0;
  }
  button {
    display: block;
    margin-bottom: 10px;
  }
</style>
```

```css
button {
  display: block;
  margin-bottom: 10px;
}
```

</Sandpack>

---

## L'état est isolé et privé

- L'état est local à l'instance du composant.
- **Si on affiche deux fois le même composant, chacun d'eux a son propre état isolé.**
- Changer l'un n'affecte pas l'autre.

<Sandpack    files={{
    "src/data.js": myFile
  }} s="60" >

```js
import Gallery from './Gallery.js';

export default function Page() {
  return (
    <div className='Page'>
      <Gallery />
      <Gallery />
    </div>
  );
}
```

```js src/Gallery.js
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <section>
      <button onClick={handleNextClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Hide' : 'Show'} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img src={sculpture.url} alt={sculpture.alt} />
    </section>
  );
}
```

```css
button {
  display: block;
  margin-bottom: 10px;
}
.Page > * {
  float: left;
  width: 50%;
  padding: 10px;
}
h2 {
  margin-top: 10px;
  margin-bottom: 0;
}
h3 {
  margin-top: 5px;
  font-weight: normal;
  font-size: 100%;
}
img {
  width: 120px;
  height: 120px;
}
button {
  display: block;
  margin-top: 10px;
  margin-bottom: 10px;
}
```

</Sandpack>

---

## L'état est isolé

- L'état n'est lié ni à une fonction, ni à un module
- Il est lié à l'instance d'un composant qui affiche sur la page
- Quand on affiche deux composants `Gallery`, React gère donc deux states
  <hr />
- Le composant `Page` ne connait rien de l'état de `Gallery`
- L'état est complètement privé au composant qui le déclare
- Le parent ne peut le changer
- On peut ajouter ou enlever de l'état sans affecter le reste des composants
  <hr />
- Si on veut que les deux galleries partagent leurs états?
- La bonne pratique en React:
  - Enlever l'état aux composants enfants pour le rajouter à leur parent partagé
  - On couvre cela plus tard

---

## Défi 1

- Quand on clique "Next" à la dernière image, le code plante
- 2 approches pour réparer (faites les 2):
  1. On ajoute de la logique au gestionnaire d'événments
  1. On désactive le bouton quand l'action n'est pas possible.

**Boni:** ajoutez un bouton "previous" pour revenir en arrière. Empêchez que ça plante à la première image.

<Sandpack    files={{
    "src/data.js": myFile
  }} s="60" >

```js
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleNextClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Hide' : 'Show'} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img src={sculpture.url} alt={sculpture.alt} />
    </>
  );
}
```

```css
button {
  display: block;
  margin-bottom: 10px;
}
.Page > * {
  float: left;
  width: 50%;
  padding: 10px;
}
h2 {
  margin-top: 10px;
  margin-bottom: 0;
}
h3 {
  margin-top: 5px;
  font-weight: normal;
  font-size: 100%;
}
img {
  width: 120px;
  height: 120px;
}
```

</Sandpack>

---

## Défi 2

Ça ne fonctionne pas. Il faudrait reprogrammer en utilisant de l'état.

<Sandpack s="60">

```js
export default function Form() {
  let firstName = '';
  let lastName = '';

  function handleFirstNameChange(e) {
    firstName = e.target.value;
  }

  function handleLastNameChange(e) {
    lastName = e.target.value;
  }

  function handleReset() {
    firstName = '';
    lastName = '';
  }

  return (
    <form onSubmit={(e) => e.preventDefault()}>
      <input
        placeholder='First name'
        value={firstName}
        onChange={handleFirstNameChange}
      />
      <input
        placeholder='Last name'
        value={lastName}
        onChange={handleLastNameChange}
      />
      <h1>
        Hi, {firstName} {lastName}
      </h1>
      <button onClick={handleReset}>Reset</button>
    </form>
  );
}
```

```css
h1 {
  margin-top: 10px;
}
```

</Sandpack>

---

## Défi 3

Ce formulaire permet aux usagers de laisser du feedback. Quand on soumet du feedback, on devrait afficher "Merci". Mais cela plante avec le message d'erreur: "Rendered fewer hooks than expected". Il faut réparer l'erreur

<Hint>D'où peut-on appeler un hook? Ce composant brise-t-il une règle?</Hint>

<Sandpack s="60">

```js
import { useState } from 'react';

export default function FeedbackForm() {
  const [isSent, setIsSent] = useState(false);
  if (isSent) {
    return <h1>Thank you!</h1>;
  } else {
    // eslint-disable-next-line
    const [message, setMessage] = useState('');
    return (
      <form
        onSubmit={(e) => {
          e.preventDefault();
          alert(`Sending: "${message}"`);
          setIsSent(true);
        }}
      >
        <textarea
          placeholder='Message'
          value={message}
          onChange={(e) => setMessage(e.target.value)}
        />
        <br />
        <button type='submit'>Send</button>
      </form>
    );
  }
}
```

</Sandpack>

---

## Rendu et commit

React gère un cycle pour afficher des données. Voici ce cycle:

1. **Lancer un déclencheur** qui provoque un rendu
2. **Génèrer le rendu** du composant
3. **Écrire le commit** vers le DOM

---

## Étape 1: Lancer un déclencheur

Il y a deux raisons pour qu'un composant soit rendu.

1. C'est le **rendu initial** du composant
2. **L'état est modifié** sur le composant (ou l'un des parents).

---

## Rendu initial

- On appelle `createRoot` sur l'élément du DOM, et on appelle la méthode `render`.

<Sandpack s="60">

```js src/index.js active
import Image from './Image.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(<Image />);
```

```js src/Image.js
export default function Image() {
  return (
    <img
      src='https://i.imgur.com/ZF6s192.jpg'
      alt="'Floralis Genérica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"
    />
  );
}
```

</Sandpack>

**NOTE:** Commentez `root.render()` et le composant disparait.

- Certaines boîtes à outils cachent ce code.

---

## Re-rendus déclenchés par une modification de l'état

- Après le rendu initial, on déclenche des rendus additionnels en modifiant l'état avec `setState`.
- Modifier l'état ajoute un re-rendu dans la file.
- On peut ajouter plusieurs rendus additionnels dans la file.
- React regroupe les éléments de la file dans **un seul rendu** (Automatic batching of renders)

---

## Étape 2: On génère un Rendu du composant

- Après le déclenchement du rendu, React appelle les composants pour générer l'affichage.

**"Faire un rendu", c'est React qui appelle les composants.**

- **Au rendu initial** React appelle le composant racine.
- **Pour les rendus suivants** React appelle le composant ayant l'état modifié.

<hr />

- C'est un processus **récursif**.
- Si le composant utilise d'autres composants, ils seront aussi appelés
  - Ainsi que leurs enfants
    - Ainsi que les petits-enfants
      - Ainsi de suite
- Le processus continue jusqu'à ce que tous les sous-composants soient rendus
- React sait alors quoi afficher

---

## Générer un rendu

<Sandpack  s="70">

```js src/Gallery.js active
export default function Gallery() {
  return (
    <section>
      <h1>Inspiring Sculptures</h1>
      <Image />
      <Image />
      <Image />
    </section>
  );
}

function Image() {
  return (
    <img
      src='https://i.imgur.com/ZF6s192.jpg'
      alt="'Floralis Genérica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"
    />
  );
}
```

```js src/index.js
import Gallery from './Gallery.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(<Gallery />);
```

```css
img {
  margin: 0 10px 10px 0;
}
```

</Sandpack>

- **Après le rendu initial** React [génère des noeuds (node) du DOM](https://developer.mozilla.org/docs/Web/API/Document/createElement) pour `<section>`, `<h1>`, et trois balises `<img>`.
- **Après le re-rendu,**, React détermine quelles propriétés ont changé, si c'est le cas, On compare avec le rendu précédent. (Cette information sera utile à la prochaine étape.)

---

## Le Rendu est pur

<Alert type="warning">

Le rendu doit toujours être une [fonction pure](https://react.dev/learn/keeping-components-pure):

</Alert>

- **'Mêmes entrées, mêmes sorties'** Avec les même entrées et paramètres, le composant retourne le même JSX
- **On ne touche à rien à l'extérieur du composant** On ne doit modifier ni objets, ni variables existantes.

  - Si on oublie ces principes, on pourrait rencontrer des bogues difficiles à détecter
  - Quand on développe en **Strict Mode**, React appelle chaque fonction 2 fois au rendu
  - Ceci aide à détecter les fonctions impures

---

## Optimiser la performance

- Par défaut, un changement de state provoque un re-rendu du composant
- Ainsi que **tous ses sous-composants** (et ainsi de suite)
- C'est lourd
- Il existe des stratégies pour optimiser la performance. Ex: `createMemo()` et **React Compiler**
  - On voit cela dans le chapitre sur la performance

---

## Étape 3: React écrit le commit vers le DOM

Après le rendu (l'appel) des composants, React fait un commit en modifiant le DOM.

- **Pour le rendu initial** React appelle [`appendChild()`](https://developer.mozilla.org/docs/Web/API/Node/appendChild) pour ajouter les noeuds DOM.
- **Pour les rendus suivants** React applique les modifications minimales (comparées pendant le rendu) pour que le DOM corresponde au dernier rendu généré.

---

## React ne modifie le DOM que pour les éléments modifiés

- Ce composant génère un re-rendu avec de nouvelles props à chaque seconde.
- On peut ajouter du texte au `<input>`, et le texte ne disparait pas au moment du re-rendu:

<Sandpack  s="70">

```js src/Clock.js active
export default function Clock({ time }) {
  return (
    <>
      <h1>{time}</h1>
      <input />
    </>
  );
}
```

```js src/App.js hidden
import { useState, useEffect } from 'react';
import Clock from './Clock.js';

function useTime() {
  const [time, setTime] = useState(() => new Date());
  useEffect(() => {
    const id = setInterval(() => {
      setTime(new Date());
    }, 1000);
    return () => clearInterval(id);
  }, []);
  return time;
}

export default function App() {
  const time = useTime();
  return <Clock time={time.toLocaleTimeString()} />;
}
```

</Sandpack>

- Au commit, React modifie le contenu `<h1>`
- `<input>` est aussi généré, mais sans modifications
- React ne touche donc pas au `value` du `<input>`

---

## L'après-exécution: Browser paint

Rappel des différentes étapes:

1. **Lancer un déclencheur** qui provoque un rendu
2. **Générer le rendu** du composant
3. **Écrire le commit** en modifiant le DOM

- Après le commit, les modifications sont affichées.
  - La documentation du navigateur appelle cela "_browser rendering_"
  - La documentation React se distingue en appelant cela "**browser painting**"

---

## En résumé

- Voici les trois étapes d'affichage sur React
  1. Déclencheur (Trigger)
  2. Rendu (Render)
  3. Écriture du DOM (Commit)
- `<StrictMode>` permet de trouver les composants impurs
- React ne touche pas au DOM quand le rendu est le même que la fois précédente

---

## Modifier l'état déclenche un rendu

Dans plusieurs environnements, on considère que la modification d'une interface usager est le résultat d'un événement, tel que le clic d'un bouton.

Dans React, c'est l'inverse.

Il faut **modifier l'état** pour que l'interface usager soit affectée.

---

## Exemple

Quand on presse "send", `setIsSent(true)` modifie l'état, et génère un re-rendu.

<Sandpack  s="70">

```js
import { useState } from 'react';

export default function Form() {
  const [isSent, setIsSent] = useState(false);
  const [message, setMessage] = useState('Bonjour!');
  if (isSent) {
    return <h1>Votre message est envoyé</h1>;
  }
  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        setIsSent(true);
        sendMessage(message);
      }}
    >
      <textarea
        placeholder='Message'
        value={message}
        onChange={(e) => setMessage(e.target.value)}
      />
      <button type='submit'>Envoyer</button>
    </form>
  );
}

function sendMessage(message) {
  // ...
}
```

```css
label,
textarea {
  margin-bottom: 10px;
  display: block;
}
```

</Sandpack>

<Hint>
Quand on clique le bouton

1. Le gestionnaire d'événements `onSubmit` exécute.
2. `setIsSent(true)` modifie `isSent` à `true` place le rendu dans la file.
3. React génère le re-rendu en utilisant la nouvelle valeur de `isSent`.

</Hint>

---

## Rendu génère un Snapshot dans le temps

- Générer un "rendu" signifie que React appelle le composant (i.e. une fonction).
- Le JSX retourné est une photo instantanée (un snapshot) de l'IU, à ce moment précis dans le temps
- Les props, gestionnnaires d'événements et variables locales sont générées **à partir de l'état, au moment du rendu.**
- Ce snapshot de l'IU inclut des gesionnaires d'événements
  - Spécifiant le comportement quand un usager interagit
  - React modifie l'écran pour synchroniser ce qui est affiché (DOM) avec ce qui a été généré (incluant la connection à des event handlers.)

<Alert >
Quand React fait un re-rendu d'un composant:

1. React appelle votre fonction
2. Cette fonction retourne un snapshot JSX
3. React modifie l'écran pour synchroniser avec le snapshot

</Alert>

---

## L'état est géré par React

- L'état est conservé entre les appels
- Différent des variables locales
  - Disparaissent quand la fonction est complétée (quand le JSX est retourné)
- L'état est conservé par React, à l'extérieur de la fonction.
- Quand React appelle un composant, il offre un snapshot de l'état pour ce rendu particulier
- Le composant retourne alors un snapshot du IU avec ces nouveaux props et gestionnaires d'événements, générés à partir des valeurs d'états de ce rendu

---

## L'état n'est pas modifié immédiatement

On pourrait s'attendre à ce que cliquer le bouton "+3" incrémente de le compteur de 3. Mais ce n'est pas le cas.

<Sandpack  s="70">

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

On n'incrémente qu'une seule fois.

---

## Modifier le state n'affecte que le prochain rendu

Pendant le premier rendu, `number` était `0`. C'est pourquoi, le gestionnaire d'événement `onClick` considère que la valeur de `number` demeure `0` même après l'appel à `setNumber(number + 1)`:

Voici ce qui est exécuté:

<TwoColumns style={{gridTemplateColumns:'15em auto'}} top>

```js
<button
  onClick={() => {
    setNumber(number + 1);
    setNumber(number + 1);
    setNumber(number + 1);
  }}
>
  +3
</button>
```

<div>

1. `number` est `0` donc `setNumber(0 + 1)`.
   - React modifiera `number` à `1` au prochain rendu.
2. `number` est `0` donc `setNumber(0 + 1)`.
   - React modifiera `number` à `1` au prochain rendu.
3. `number` est `0` donc `setNumber(0 + 1)`.
   - React modifiera `number` à `1` au prochain rendu.

</div>
</TwoColumns>

- `number` demeure `0`
- On modifie l'état vers `1` trois fois
- Le résultat final affiche `1` (plutôt que `3`)

---

## Autre explication

<TwoColumns>
<div>
Une autre façon de visualiser, c'est de substituer les états avec leur valeur. Au premier rendu:

```js
<button
  onClick={() => {
    setNumber(0 + 1);
    setNumber(0 + 1);
    setNumber(0 + 1);
  }}
>
  +3
</button>
```

</div>
<div>
Au rendu suivant, `number` est `1`. Donc pour _ce rendu_, le gestionnaire d'événements est alors:

```js
<button
  onClick={() => {
    setNumber(1 + 1);
    setNumber(1 + 1);
    setNumber(1 + 1);
  }}
>
  +3
</button>
```

</div>
</TwoColumns >

C'est pourquoi la progression est `1`, `2`, `3`, `4` et ainsi de suite.

---

## L'état à travers le temps

Quel sera le résultat de cette alerte?

<Sandpack  s="70">

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          alert(number);
        }}
      >
        +5
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

<Hint>
Si vous substituez, vous pouvez deviner que c'est zéro:

```js
setNumber(0 + 5);
alert(0);
```

</Hint>

---

## Question

Si on met un minuteur sur cette alerte, pour qu'elle soit lancée seulement après que le re-rendu soit complété? Ce serait "0" ou "5"? (Devinez!)

<Sandpack  s="70">

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          setTimeout(() => {
            alert(number);
          }, 3000);
        }}
      >
        +5
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

<Hint>

Si vous utilisez la méthode de substitution, on voit clairement l'état passé à l'alerte.

<TwoColumns>

```js
setNumber(0 + 5);
setTimeout(() => {
  alert(0);
}, 3000);
```

L'état stocké dans React est changé au moment où l'alerte éxécute, mais c'est planifié au moment où la valeur n'a pas encore changé. C'est le moment du snapshot.

</TwoColumns>

</Hint>

---

## L'état n'est jamais modifié pendant le rendu

- L'état n'est pas modifié pendant le rendu, même quand le code est asynchrone (ex: minuteur ou _timer_)
- Dans le `onClick`, la valeur `number` continue d'être `0` même après que `setNumber(number + 5)` ne soit appelé
- Sa valeur s'est fixée quand React a "pris son snapshot" de l'IU
- Le code est moins fragile aux erreurs de synchonisation et de timing

<hr />

---

## L'état est une machine à voyager dans le temps

Imaginons un fomulaire qui envoie un message avec un délai de 3 secondes:

1. On clique sur "Envoyer" pour dire "Bonjour" à Alice
2. Avant la fin du délai de 3 secondes, on change la valeur du "destinataire" pour "Bob"

Que devrait afficher `alert`? "Bonjour à Alice" ou "Bonjour à Bob"?

<Sandpack s="70">

```js
import { useState } from 'react';

export default function Form() {
  const [to, setTo] = useState('Alice');
  const [message, setMessage] = useState('Bonjour');

  function handleSubmit(e) {
    e.preventDefault();
    setTimeout(() => {
      alert(`Vous dites ${message} à ${to}`);
    }, 3000);
  }

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Destinataire:{' '}
        <select value={to} onChange={(e) => setTo(e.target.value)}>
          <option value='Alice'>Alice</option>
          <option value='Bob'>Bob</option>
        </select>
      </label>
      <textarea
        placeholder='Message'
        value={message}
        onChange={(e) => setMessage(e.target.value)}
      />
      <button type='submit'>Envoyer</button>
    </form>
  );
}
```

```css
label,
textarea {
  margin-bottom: 10px;
  display: block;
}
```

</Sandpack>

- **React conserve les valeurs d'états "fixées" dans les gestionnaires d'événements de _ce rendu_.**
- Ne pas s'inquiéter d'un changement d'état pendant l'exécution du code
- Que faire si on doit lire le dernier état avant un re-render?
  - On pourrait utiliser une fonction de modification d'état. On verra cela bientôt.

---

## Défi 4

Voici un feu de circulation pour piétons. Ajoutez une `alert` au gestionnaire du clic:

- Quand la lumière est verte et dit ¨Walk¨, cliquer le bouton devrait afficher "Stop is next"
- Quand la lumière est rouge et dit "Stop", cliquer le bouton devrait afficher "Walk is next"

Est-ce que ça fait une différence lorsqu'on met l'alerte avant ou après l'appel `setWalk`?

<Sandpack  s="70">

```js
import { useState } from 'react';

export default function TrafficLight() {
  const [walk, setWalk] = useState(true);

  function handleClick() {
    setWalk(!walk);
  }

  return (
    <>
      <button onClick={handleClick}>Change to {walk ? 'Stop' : 'Walk'}</button>
      <h1
        style={{
          color: walk ? 'darkgreen' : 'darkred',
        }}
      >
        {walk ? 'Walk' : 'Stop'}
      </h1>
    </>
  );
}
```

```css
h1 {
  margin-top: 20px;
}
```

</Sandpack>

---

## React regroupe les modification d'états en lots (batch)

<Sandpack  s="70">

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

<TwoColumns>

```js
setNumber(0 + 1);
setNumber(0 + 1);
setNumber(0 + 1);
```

Chaque rendu est fixé au moment qu'il est généré, donc la valeur `number` demeure `0`, même lorsqu'on appelle `setNumber(1)` plusieurs fois.

</TwoColumns>

Il y a aussi une autre raison: **React attend que tous les gestionnaires d'événements aient fini de rouler avant de modifier l'état.**
C'est pourquoi le re-rendu ne s'exécute _qu'après_ tous les `setNumber()`;

---

## Optimisation: Regrouper les setState en lot (batch)

- Similaire à l'expérience au resto:
- Un serveur prend tous les détails de la commande avant de partir à la cuisine
- S'il n'était pas très futé, il pourrait partir à la cuisine à mesure dès que vous commandez de la soupe, et revenir... Et repartir dès que vous commandez une boisson, et revenir... ainsi de suite... ça ne serait pas très efficace.
- Cette approche permet de modifier plusieurs variables d'états, provenant de plusieurs composants, dans un seul re-rendu.
- L'Interface Usager ne sera pas mise à jour tant qu'on n'aura pas complété les gestionnaires d'événements. (mousedown, mouseup, click)
- C'est ce qu'on appelle le regroupement par lot (batching)
- Cette optimisation améliore les performances
- Cela évite les "rendus à moitié", où seulement certaines variables ont été mises-à-jour.

<Alert type="warning">

- **React ne regroupe pas à travers de _multiples_ événements intentionnels
  (ex: multiples clics)**
- Chaque clic est géré séparément
- React ne regroupe que là où ça fait du sens (mouseup et click)
- Cela assure que si le premier clic
  désactive le fomulaire, le second clic ne soumettra pas le formulaire une
  seconde fois.

</Alert>

---

## Modifier l'état de multiples fois dans un lot

C'est un cas rare, mais si on désire modifier l'état plusieurs fois:

- On remplace la valeur `setNumber(number + 1)`, par une fonction `setNumber((n) => n + 1)`
- Indique à React: "exécute le code plus tard"
- La fonction updater prend un paramètre (l'état courant) et retourne l'état suivant.

<Sandpack  s="70">

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber((n) => n + 1);
          setNumber((n) => n + 1);
          setNumber((n) => n + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

---

## Explications

Ici, `(n) => n + 1` est une **fonction updater.** Quand on passe cette fonction à un `setState()`:

1. React ajoute cette fonction à la file pour être traité après que le gestionnaire d'événements ait terminé.
2. Durant le prochain rendu, React passe à travers la file pour exécuter et retourner l'état modifié.

Voici comment React gère ces lignes de code dans le gestionnaire d'événements :

<TwoColumns style={{gridTemplateColumns:'15em auto'}} top>

```js
setNumber((n) => n + 1);
setNumber((n) => n + 1);
setNumber((n) => n + 1);
```

<div>

1. `n => n + 1` est une fonction. React l'ajoute à la file.
2. `n => n + 1` est une fonction. React l'ajoute à la file.
3. `n => n + 1` est une fonction. React l'ajoute à la file.

</div>
</TwoColumns >

---

## Explications

- Quand React est prêt à modifier l'état, React passe à travers la file.
- L'état précédent `number` est `0`, React passe cette valeur à la première fonction updater (par le paramètre `n`).

import './table-rows.css';

<div className="my-tbl" >

| file de fonctions | `n` | calcul   | retourne |
| ----------------- | --- | -------- | -------- |
| `n => n + 1`      | `0` | `0 + 1 ` | 1        |
| `n => n + 1`      | `1` | `1 + 1`  | 2        |
| `n => n + 1`      | `2` | `2 + 1 ` | 3        |

</div>

React stocke `3` comme résultat final et le retourne via le `useState`.

C'est pour cela que l'exemple précédent fonctionne lorsqu'on clique "+3"

---

## Si on modifie le state après l'avoir remplacé

Que penser de ce gestionnaire d'événements.

```js
<button onClick={() => {
  setNumber(number + 5);
  setNumber(n => n + 1);
}}>
```

<Sandpack  s="70">

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          setNumber((n) => n + 1);
        }}
      >
        Increase the number
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

---

## Explications

1. `setNumber(number + 5)`: `number` est `0`, donc `setNumber(0 + 5)`. React ajoute _"replacer avec `5`"_ dans la file.
2. `setNumber((n) => n + 1)`: `(n) => n + 1` est une fonction updater. React ajoute _cette fonction_ dans la file.

Pendant le prochain rendu, React passe par la file d'état:

<div className="my-tbl" >

| file               | `n`           | retourne    |
| ------------------ | ------------- | ----------- |
| "remplace par `5`" | `0` (inutile) | `5`         |
| `(n) => n + 1`     | `5`           | `5 + 1 = 6` |

</div>
<hr/>

React stocke `6` comme résultat final pour le prochain rendu.

Remarquez que `setState(x)` fonctionne comme `setState((n) => x)`, où `n` n'est pas utilisé!

---

## Si on remplace l'état après l'avoir modifié

Quelle sera la valeur ici?

```js
<button onClick={() => {
  setNumber(number + 5);
  setNumber(n => n + 1);
  setNumber(42);
}}>
```

<Sandpack  s="70">

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          setNumber((n) => n + 1);
          setNumber(42);
        }}
      >
        Increase the number
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

---

## Explications

1. `setNumber(number + 5)`: `number` est `0`, donc `setNumber(0 + 5)`. React ajoute _"remplacer avec `5`"_ à la file.
2. `setNumber(n => n + 1)`: `n => n + 1` est une fonction updater. React ajoute _cette fonction_ à la file.
3. `setNumber(42)`: React ajoute _"remplacer avec `42`"_ à la file.

Pendant le prochain rendu, React passe à travers la file

<div className="my-tbl" >

| file                  | `n`           | retourne    |
| --------------------- | ------------- | ----------- |
| "remplacer avec `5`"  | `0` (inutile) | `5`         |
| `n => n + 1`          | `5`           | `5 + 1 = 6` |
| "remplacer avec `42`" | `6` (inutile) | `42`        |

</div>
<hr/>

React stocke `42` comme résultat final et le retourne via le `useState`

---

## Convention de noms

C'est commun de nommer l'argument de la fonction par les premières lettres du state.

```js
setEnabled((e) => !e);
setLastName((ln) => ln.reverse());
setFriendCount((fc) => fc * 2);
```

Si on préfère utiliser plus de lettres, une autre convention serait d'utiliser le nom de l'état, avec ou sans préfixe.

```js
setEnabled((enabled) => !enabled);
setEnabled((prevEnabled) => !prevEnabled);
```

---

## Résumé

Deux façons d'appeler `setNumber`:

1. **Avec une fonction updater n** (i.e. `(n) => n + 1`) qui se fait ajouter dans la file.
2. **Avec une valeur** (i.e. nombre `5`) ajoute "remplacer avec `5`" à la file, en ignorant ce qui est déjà présent.

- C'est après la série d'événements, avant le re-rendu, que React appelle la file des **updaters**.
- Les **updaters** doivent être des fonctions pures
- Ne pas mettre d'effets de bord, ni de setState.
- En mode Strict, React exécute chaque fonction **updater** deux fois (mais exclut le second résultat)
  - Ça aide à trouver les effets de bords indésirables.

---

## Défi 5

On travaille sur une application d'achat. Chaque fois qu'un usager clique le boutton "Acheter", le compteur "achats en attente" doit augmenter de un. Après 3 secondes, le compteur "en attente" doit diminuer et le compteur "achats complétés" doit augmenter.

Mais ce code est brisé. Quand on clique "Acheter", il diminue à "-1" (ça ne devrait pas être possible). Et si on clique rapidement, le résultat est bizarre.

Réparez les compteurs.

<Sandpack s="70">

```js
import { useState } from 'react';

export default function RequestTracker() {
  const [pending, setPending] = useState(0);
  const [completed, setCompleted] = useState(0);

  async function handleClick() {
    setPending(pending + 1);
    await delay(3000);
    setPending(pending - 1);
    setCompleted(completed + 1);
  }

  return (
    <>
      <h3>Achats en attente: {pending}</h3>
      <h3>Achats complétés: {completed}</h3>
      <button onClick={handleClick}>Acheter</button>
    </>
  );
}

function delay(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
```

</Sandpack>

---

## React et les mutations d'objets

- En React, on ne devrait jamais modifier un objet stocké dans l'état
- Plutôt que de muter un objet, on devrait créer de nouvelles copies qu'on modifie

---

## Types immuables

N'importe quel type de valeur peut être stocké par l'état.

```js
const [x, setX] = useState(0);
```

Types immuables (qu'on ne peut modifier):

- nombres
- chaines de caractères
- booléens

On ne peut _modifier_ ces types. Mais on peut _remplacer_ la valeur.

```js
setX(5);
```

L'état `x` de `0` est remplacé par `5`, (`0` n'a pas muté.)

---

## Types mutables

Considérons un objet dans l'état:

```js
const [position, setPosition] = useState({ x: 0, y: 0 });
```

Quand on modifie le contenu de l'objet, **c'est nommé une mutation:**

```js
position.x = 5;
```

- Les objets dans un état React sont, techniquement, mutables
- **MAIS**, on devrait toujours les traiter **comme si** ils étaient immuables
  - Tel un nombre, booléen ou chaîne de caractères
- Plutôt que de les muter, on préférera les **remplacer**.
- On devrait toujours traiter les objets JS dans l'état comme en **lecture seulement.**

---

## React ignore les mutations

- L'objet suivant représente la position d'un pointeur
- Quand on touche ou déplace le curseur, on modifie la position
- Mais le point rouge reste immobile

<Sandpack s="70">

```js
import { useState } from 'react';
export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0,
  });
  return (
    <div
      onPointerMove={(e) => {
        position.x = e.clientX;
        position.y = e.clientY;
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}
    >
      <div
        style={{
          position: 'absolute',
          backgroundColor: 'red',
          borderRadius: '50%',
          transform: `translate(${position.x}px, ${position.y}px)`,
          left: -10,
          top: -10,
          width: 20,
          height: 20,
        }}
      />
    </div>
  );
}
```

```css
body {
  margin: 0;
  padding: 0;
  height: 250px;
}
```

</Sandpack>

Où est le problème?

---

## Réponse

Le problème se situe ici:

<TwoColumns top>

```js
onPointerMove={e => {
  position.x = e.clientX;  // 🚫
  position.y = e.clientY;  // 🚫
}}
```

- Ce code mute l'objet assigné à `position` du rendu précédent
- Mais on n'utilise pas la fonction `setState`
- React n'a pas moyen de savoir que l'objet est modifié

</TwoColumns>

<hr />

<TwoColumns top>

<div style={{textAlign:"right"}}>

Pour déclencher un re-rendu, il faut créer un nouvel objet, dans lequel on initialise les propriétés:

</div>

```js
onPointerMove={e => {
  setPosition({
    x: e.clientX,
    y: e.clientY
  });
}}
```

</TwoColumns >

---

## Explications

Avec `setPosition`, on dit à React de:

- Remplacer `position` avec ce nouvel objet
- Faire un re-rendu du composant

<Sandpack s="70">

```js
import { useState } from 'react';
export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0,
  });
  return (
    <div
      onPointerMove={(e) => {
        setPosition({
          x: e.clientX,
          y: e.clientY,
        });
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}
    >
      <div
        style={{
          position: 'absolute',
          backgroundColor: 'red',
          borderRadius: '50%',
          transform: `translate(${position.x}px, ${position.y}px)`,
          left: -10,
          top: -10,
          width: 20,
          height: 20,
        }}
      />
    </div>
  );
}
```

```css
body {
  margin: 0;
  padding: 0;
  height: 250px;
}
```

</Sandpack>

---

## La mutation locale est permise

<TwoColumns top style={{gap:'2em'}}>

<div>
Ce code est **parfaitement correct** car on mute un nouvel object qui vient tout juste d'être créé.

```js
const nextPosition = {};
nextPosition.x = e.clientX;
nextPosition.y = e.clientY;
setPosition(nextPosition);
```

Aussi équivalent à ceci:

```js
setPosition({
  x: e.clientX,
  y: e.clientY,
});
```

Mais le code suivant est problématique car il modifie un objet d'état _existant_:

```js
position.x = e.clientX; //🚫
position.y = e.clientY; //🚫
```

</div>

<Alert type="info">

- La mutation est un problème seulement quand on modifie des objets _existants_ dans l'état.
- Muter un objet qui vient tout juste d'être créé est correct, car _aucun autre code n'y fait encore référence._
- Muter un nouvel objet n'a pas d'impact. C'est ce qu'on appelle une "mutation locale". (On peut même faire des mutations locales durant un rendu.)

</Alert>

</TwoColumns>

---

## Modifier partiellement un objet

- Que faire si on désire inclure les données existantes dans le nouvel objet?
- Exemple: modifier un seul champ d'un formulaire, tout en gardant les autres données existantes?
- Les champs de saisie ci-bas ne fonctionnent pas (les `onChange` ne modifient pas l'état)

<Sandpack s="70">

```js
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'John',
    lastName: 'Smith',
    email: 'jsmith@test.com',
  });

  function handleFirstNameChange(e) {
    person.firstName = e.target.value;
  }

  function handleLastNameChange(e) {
    person.lastName = e.target.value;
  }

  function handleEmailChange(e) {
    person.email = e.target.value;
  }

  return (
    <>
      <label>
        First name:
        <input value={person.firstName} onChange={handleFirstNameChange} />
      </label>
      <label>
        Last name:
        <input value={person.lastName} onChange={handleLastNameChange} />
      </label>
      <label>
        Email:
        <input value={person.email} onChange={handleEmailChange} />
      </label>
      <p>
        {person.firstName} {person.lastName} ({person.email})
      </p>
    </>
  );
}
```

```css
label {
  display: block;
}
input {
  margin-left: 5px;
  margin-bottom: 5px;
}
```

</Sandpack>

---

## Conserver les valeurs existantes

**Mauvais code:** muter l'objet `person` en modifiant le "firstName" du rendu précédent.

```js
person.firstName = e.target.value; // 🚫
```

**Mieux:** Créer un nouvel objet, **copier les données existantes**, et appeler `setPerson()`.

```js
setPerson({
  firstName: e.target.value, // Nouveau prénom
  lastName: person.lastName, // Nom existant
  email: person.email, // courriel existant
});
```

---

## Décomposition (spread syntax)

On peut utiliser la syntaxe "`...object`" de la [décomposition d'objet](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals) (Spread syntax) pour ne pas avoir besoin de recopier chaque propriété séparément.

```js
setPerson({
  ...person, // copie les anciennes propriétés
  firstName: e.target.value, // Modifie firstName
});
```

<hr />

<Alert type='warning'>

- Notez que "`...`" est
  superficiel
- Ne copie qu'à un seul niveau de profondeur
- Bonne performance
- Mais, avec des objets imbriqués, il faudra utiliser cette
  syntaxe à de multiples niveaux.

</Alert>

---

## Valider l'usage de la décomposition (spread syntax)

- Maintenant, le formulaire fonctionne.
- Pas besoin de déclarer une variable d'état pour chaque champ de saisie.
- Pour les gros formulaires, garder toutes les données groupées dans un seul objet est très pratique. (En autant qu'il soit modifié correctement.)

<Sandpack s="70">

```js
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'John',
    lastName: 'Smith',
    email: 'jsmith@test.com',
  });

  function handleFirstNameChange(e) {
    setPerson({
      ...person,
      firstName: e.target.value,
    });
  }

  function handleLastNameChange(e) {
    setPerson({
      ...person,
      lastName: e.target.value,
    });
  }

  function handleEmailChange(e) {
    setPerson({
      ...person,
      email: e.target.value,
    });
  }

  return (
    <>
      <label>
        First name:
        <input value={person.firstName} onChange={handleFirstNameChange} />
      </label>
      <label>
        Last name:
        <input value={person.lastName} onChange={handleLastNameChange} />
      </label>
      <label>
        Email:
        <input value={person.email} onChange={handleEmailChange} />
      </label>
      <p>
        {person.firstName} {person.lastName} ({person.email})
      </p>
    </>
  );
}
```

```css
label {
  display: block;
}
input {
  margin-left: 5px;
  margin-bottom: 5px;
}
```

</Sandpack>

---

## Un seul gestionnaire d'événements pour plusieurs champs

- Voici le même exemple, avec un seul gestionnaire d'événement plutôt que trois
- Les propriétés avec un **nom dynamique** utilisent les accolades carrées "`[` et `]`" plutôt que point "`.`"
- `e.target.name` réfère à la propriété `name` dans l'élément `<input>` du DOM

<Sandpack s="70">

```js
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'John',
    lastName: 'Smith',
    email: 'jsmith@test.com',
  });

  function handleChange(e) {
    setPerson({
      ...person,
      [e.target.name]: e.target.value,
    });
  }

  return (
    <>
      <label>
        First name:
        <input
          name='firstName'
          value={person.firstName}
          onChange={handleChange}
        />
      </label>
      <label>
        Last name:
        <input
          name='lastName'
          value={person.lastName}
          onChange={handleChange}
        />
      </label>
      <label>
        Email:
        <input //
          name='email'
          value={person.email}
          onChange={handleChange}
        />
      </label>
      <p>
        {person.firstName} {person.lastName} ({person.email})
      </p>
    </>
  );
}
```

```css
label {
  display: block;
}
input {
  margin-left: 5px;
  margin-bottom: 5px;
}
```

</Sandpack>

---

## Mettre à jour un objet imbriqué

Considérez l'objet imbriqué suivant:

```js
const [person, setPerson] = useState({
  name: 'Niki de Saint Phalle',
  artwork: {
    title: 'Blue Nana',
    city: 'Hamburg',
    image: 'https://i.imgur.com/Sd1AgUOm.jpg',
  },
});
```

<hr />

Pour modifier `person.artwork.city`, ça serait simple avec une mutation, mais incorrect:

```js
person.artwork.city = 'New Delhi'; // 🚫
```

---

## Remplacer un objet imbriqué avec la décomposition

On préfère approcher l'état de façon immuable:

<TwoColumns top style={{ gridTemplateColumns:"30fr 70fr"}}>

<div style={{ marginTop: 20 }}>

On créé un nouvel objet `artwork` (copiant les données de l'état précédent),
ainsi qu'un nouvel objet `person` qui réfère au nouvel `artwork`.

</div>

```js
const nextArtwork = { ...person.artwork, city: 'New Delhi' };
const nextPerson = { ...person, artwork: nextArtwork };
setPerson(nextPerson);
```

<div style={{ marginTop: 30 }}>Alternativement, en une seule commande:</div>

```js
setPerson({
  ...person, // Copier les propriétés
  artwork: {
    // remplacer artwork
    ...person.artwork, // Copier les propriétés
    city: 'New Delhi', // mais à New Delhi!
  },
});
```

</TwoColumns>

---

## Exemple de modification avec imbrication

La syntaxe de décomposition d'objets imbriqués n'est pas toujours facile à écrire, mais ça fonctionne très bien.

<Sandpack s="70">

```js
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: 'https://i.imgur.com/Sd1AgUOm.jpg',
    },
  });

  function handleNameChange(e) {
    setPerson({
      ...person,
      name: e.target.value,
    });
  }

  function handleTitleChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        title: e.target.value,
      },
    });
  }

  function handleCityChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        city: e.target.value,
      },
    });
  }

  function handleImageChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        image: e.target.value,
      },
    });
  }

  return (
    <>
      <label>
        Name:
        <input value={person.name} onChange={handleNameChange} />
      </label>
      <label>
        Title:
        <input value={person.artwork.title} onChange={handleTitleChange} />
      </label>
      <label>
        City:
        <input value={person.artwork.city} onChange={handleCityChange} />
      </label>
      <label>
        Image:
        <input value={person.artwork.image} onChange={handleImageChange} />
      </label>
      <p>
        <i>{person.artwork.title}</i>
        {' by '}
        {person.name}
        <br />
        (located in {person.artwork.city})
      </p>
      <img src={person.artwork.image} alt={person.artwork.title} />
    </>
  );
}
```

```css
label {
  display: block;
}
input {
  margin-left: 5px;
  margin-bottom: 5px;
}
img {
  width: 200px;
  height: 200px;
}
```

</Sandpack>

---

## Les objets sont-il imbriqués?

<TwoColumns top style={{ gridTemplateColumns:"40fr 60fr"}}>

<div style={{marginTop:'1em'}}>

Les objets suivants semblent "imbriqués" dans le code:

</div>

```js
let obj = {
  name: 'Niki de Saint Phalle',
  artwork: {
    title: 'Blue Nana',
    city: 'Hamburg',
    image: 'https://i.imgur.com/Sd1AgUOm.jpg',
  },
};
```

<div style={{ marginTop: '1em' }}>

- Mais c'est trompeur
- À l'exécution, la notion d'imbrication
  n'existe pas
- En fait, ce sont deux objets distincts

</div>

```js
let obj1 = {
  title: 'Blue Nana',
  city: 'Hamburg',
  image: 'https://i.imgur.com/Sd1AgUOm.jpg',
};

let obj2 = {
  name: 'Niki de Saint Phalle',
  artwork: obj1,
};
```

</TwoColumns>

---

## Les objet ne sont pas vraiment imbriqués

L'objet `obj1` n'est pas vraiment stocké dans `obj2`. La preuve, `obj3` pourrait référer à `obj1` aussi:

<TwoColumns top>

```js
let obj1 = {
  title: 'Blue Nana',
  city: 'Hamburg',
  image: 'https://i.imgur.com/Sd1AgUOm.jpg',
};

let obj2 = {
  name: 'Niki de Saint Phalle',
  artwork: obj1,
};

let obj3 = {
  name: 'Copycat',
  artwork: obj1,
};
```

<div style={{marginTop:20}}>

- `obj3.artwork`, `obj2.artwork`, ainsi qu'`obj1` réfèrent tous au même objet

- Modifier `obj3.artwork.city` affecte `obj2.artwork.city` ainsi que `obj1.city`

- Ces sont des objets séparés, qui réfèrent ou pointent les uns les autres

</div>
</TwoColumns>

---

## Réaliser des modifications complexes avec immer

- Quand l'état est complexe, avec plusieurs objets "imbriqués", on pourrait simplifier
- On pourrait rendre l'état plat (sans imbrication)
  <hr />
- Si on préfère conserver la structure complexe, il existe des outils pour aider
- Le plus populaire se nomme [Immer](https://github.com/immerjs/use-immer)
- Permet d'utiliser des changements mutatifs, mais produit un résultat en copie d'objet.
- Ex: dans le code mutatif suivant, il n'y a pas de mutation, et Immer génère un nouvel objet

```js
updatePerson((draft) => {
  draft.artwork.city = 'Lagos';
});
```

Contrairement aux mutations régulières, **immer** n'écrase pas les états précédents.

---

## Comment fonctionne Immer?

Pour utiliser Immer

1. `npm install use-immer` pour ajouter Immer en tant que dépendance.
2. Remplacez :

`import { useState } from 'react'`

avec

`import { useImmer } from 'use-immer'`

<Alert type="warning">
- Le `draft` (brouillon) fourni par Immer est un objet spécial, nommé [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 
- Ce proxy enregistre toutes les mutations qui affectent l'objet
- C'est pour cela qu'il est possible de muter l'objet autant qu'on le désire
- Dans les coulisses, Immer détermine les modifications à `draft`
- Immer produit ensuite un nouvel objet avec toutes les modifications

</Alert>

---

## Exemple qui utilise Immer

<Sandpack  s="70">

```js
import { useImmer } from 'use-immer';

export default function Form() {
  const [person, updatePerson] = useImmer({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: 'https://i.imgur.com/Sd1AgUOm.jpg',
    },
  });

  function handleNameChange(e) {
    updatePerson((draft) => {
      draft.name = e.target.value;
    });
  }

  function handleTitleChange(e) {
    updatePerson((draft) => {
      draft.artwork.title = e.target.value;
    });
  }

  function handleCityChange(e) {
    updatePerson((draft) => {
      draft.artwork.city = e.target.value;
    });
  }

  function handleImageChange(e) {
    updatePerson((draft) => {
      draft.artwork.image = e.target.value;
    });
  }

  return (
    <>
      <label>
        Name:
        <input value={person.name} onChange={handleNameChange} />
      </label>
      <label>
        Title:
        <input value={person.artwork.title} onChange={handleTitleChange} />
      </label>
      <label>
        City:
        <input value={person.artwork.city} onChange={handleCityChange} />
      </label>
      <label>
        Image:
        <input value={person.artwork.image} onChange={handleImageChange} />
      </label>
      <p>
        <i>{person.artwork.title}</i>
        {' by '}
        {person.name}
        <br />
        (located in {person.artwork.city})
      </p>
      <img src={person.artwork.image} alt={person.artwork.title} />
    </>
  );
}
```

```json package.json
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

```css
label {
  display: block;
}
input {
  margin-left: 5px;
  margin-bottom: 5px;
}
img {
  width: 200px;
  height: 200px;
}
```

</Sandpack>

- Il est possible d'utiliser `useState` et `useImmer` dans le même composant
- Immer garde le code simple et concis, surtout avec des objets imbriqués
- Sans Immer, la copie d'objets imbriqués génère du code complexe

---

## Pourquoi éviter la mutation d'état en React (1/2)

Voici les raisons:

- **Débogage:** Si vous utilisez `console.log` et ne mutez pas le state, les objets affichés ne seront pas écrasés par des mutations récentes. C'est alors plus simple et clair de suivre l'historique des changements.
- **Optimisations:** Plusieurs stratégies d'optimisation de React (ex: memo) sautent le rendu quand les props ou le state n'ont pas été modifiés. Quand on ne mute jamais l'état, React valide les changements avec une simple comparaison `prevObj ===  obj`
- **Nouvelles fonctionnalités:** L'équipe React prépare de nouvelles fonctionnalités qui se fient que l'état n'est jamais muté. Le code qui utilise la mutation pourrait échouer dans une future version de React.

---

## Pourquoi éviter la mutation d'état en React (2/2)

- **Ajout de besoins:** Certaines fonctionnalités (annuler/rétablir, undo/redo, afficher un historique de changements, réinitialiser un formulaire aux valeurs précédentes) sont des actions simples à réaliser quand rien n'est muté. Il suffit de garder des copies des états précédents. C'est plus compliqué à implanter quand il y a des mutations.
- **Simplicité:** Quand React utilise un état immuable, il n'y a alors rien de spécial à coder. Pas besoin de proxy, ni de propriétés capturées, ni d'objets réactifs à initialiser. React permet d'ajouter n'importe quel objet dans l'état, sans aucun impact sur la performance.

<Alert type="warning">

Il est parfois possible de muter l'état en React sans ressentir d'impact négatif. Mais à mesure que des nouvelles fonctionnalités sont ajoutées à React, celles-ci s'attendent à ce que les objets soient immuables. Donc, pour que votre code soit compatible avec les futures versions de React, assurez-vous d'écrire du code avec un état immuable.

</Alert>

---

## Défi 6

Si on clique le bouton pour ajouter du pointage, rien ne change... Modifiez ensuite le prénom, et le pointage est corrigé. Modifiez ensuite le nom, et tout disparait.

Réparez le code.

<Sandpack s="70">

```js
import { useState } from 'react';

export default function Scoreboard() {
  const [player, setPlayer] = useState({
    firstName: 'John',
    lastName: 'Smith',
    score: 5,
  });

  function handlePlusClick() {
    player.score++;
  }

  function handleFirstNameChange(e) {
    setPlayer({
      ...player,
      firstName: e.target.value,
    });
  }

  function handleLastNameChange(e) {
    setPlayer({
      lastName: e.target.value,
    });
  }

  return (
    <>
      <label>
        Score: <b>{player.score}</b>{' '}
        <button onClick={handlePlusClick}>+1</button>
      </label>
      <label>
        First Name:
        <input value={player.firstName} onChange={handleFirstNameChange} />
      </label>
      <label>
        Last Name:
        <input value={player.lastName} onChange={handleLastNameChange} />
      </label>
    </>
  );
}
```

```css
label {
  display: block;
  margin-bottom: 10px;
}
input {
  margin-left: 5px;
  margin-bottom: 5px;
}
```

</Sandpack>

---

## Défi 7

Voci un boîte que l'on peut déplacer. On peut changer sa couleur avec le champ de saisie.

Mais il y a un bogue: Si vous déplacez la boîte d'abord, et ensuite changez sa couleur, le fond va sauter à une nouvelle position. Ce n'est pas le comportement désiré.

Il y a des mutations indésirables. Réparez le bogue.

<Sandpack s="70">

```js src/App.js
import { useState } from 'react';
import Background from './Background.js';
import Box from './Box.js';

const initialPosition = {
  x: 0,
  y: 0,
};

export default function Canvas() {
  const [shape, setShape] = useState({
    color: 'orange',
    position: initialPosition,
  });

  function handleMove(dx, dy) {
    shape.position.x += dx;
    shape.position.y += dy;
  }

  function handleColorChange(e) {
    setShape({
      ...shape,
      color: e.target.value,
    });
  }

  return (
    <>
      <select value={shape.color} onChange={handleColorChange}>
        <option value='orange'>orange</option>
        <option value='lightpink'>lightpink</option>
        <option value='aliceblue'>aliceblue</option>
      </select>
      <Background position={initialPosition} />
      <Box color={shape.color} position={shape.position} onMove={handleMove}>
        Bougez moi!
      </Box>
    </>
  );
}
```

```js src/Box.js
import { useState } from 'react';

export default function Box({ children, color, position, onMove }) {
  const [lastCoordinates, setLastCoordinates] = useState(null);

  function handlePointerDown(e) {
    e.target.setPointerCapture(e.pointerId);
    setLastCoordinates({
      x: e.clientX,
      y: e.clientY,
    });
  }

  function handlePointerMove(e) {
    if (lastCoordinates) {
      setLastCoordinates({
        x: e.clientX,
        y: e.clientY,
      });
      const dx = e.clientX - lastCoordinates.x;
      const dy = e.clientY - lastCoordinates.y;
      onMove(dx, dy);
    }
  }

  function handlePointerUp(e) {
    setLastCoordinates(null);
  }

  return (
    <div
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      style={{
        width: 100,
        height: 100,
        cursor: 'grab',
        backgroundColor: color,
        position: 'absolute',
        border: '1px solid black',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        transform: `translate(
          ${position.x}px,
          ${position.y}px
        )`,
      }}
    >
      {children}
    </div>
  );
}
```

```js src/Background.js
export default function Background({ position }) {
  return (
    <div
      style={{
        position: 'absolute',
        transform: `translate(
        ${position.x}px,
        ${position.y}px
      )`,
        width: 250,
        height: 250,
        backgroundColor: 'rgba(200, 200, 0, 0.2)',
      }}
    />
  );
}
```

```css
body {
  height: 280px;
}
select {
  margin-bottom: 10px;
}
```

</Sandpack>

---

## Défi 8

Voici le même exemple que dans le défi précédent. Cette fois-ci, il faut réparer la mutation via Immer. Pour vous aider, `useImmer` est déjà importé. Il ne reste qu'à changer la variable shape.

<Sandpack s="70">

```js src/App.js
import { useState } from 'react';
import { useImmer } from 'use-immer';
import Background from './Background.js';
import Box from './Box.js';

const initialPosition = {
  x: 0,
  y: 0,
};

export default function Canvas() {
  const [shape, setShape] = useState({
    color: 'orange',
    position: initialPosition,
  });

  function handleMove(dx, dy) {
    shape.position.x += dx;
    shape.position.y += dy;
  }

  function handleColorChange(e) {
    setShape({
      ...shape,
      color: e.target.value,
    });
  }

  return (
    <>
      <select value={shape.color} onChange={handleColorChange}>
        <option value='orange'>orange</option>
        <option value='lightpink'>lightpink</option>
        <option value='aliceblue'>aliceblue</option>
      </select>
      <Background position={initialPosition} />
      <Box color={shape.color} position={shape.position} onMove={handleMove}>
        Bougez moi!
      </Box>
    </>
  );
}
```

```js src/Box.js
import { useState } from 'react';

export default function Box({ children, color, position, onMove }) {
  const [lastCoordinates, setLastCoordinates] = useState(null);

  function handlePointerDown(e) {
    e.target.setPointerCapture(e.pointerId);
    setLastCoordinates({
      x: e.clientX,
      y: e.clientY,
    });
  }

  function handlePointerMove(e) {
    if (lastCoordinates) {
      setLastCoordinates({
        x: e.clientX,
        y: e.clientY,
      });
      const dx = e.clientX - lastCoordinates.x;
      const dy = e.clientY - lastCoordinates.y;
      onMove(dx, dy);
    }
  }

  function handlePointerUp(e) {
    setLastCoordinates(null);
  }

  return (
    <div
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      style={{
        width: 100,
        height: 100,
        cursor: 'grab',
        backgroundColor: color,
        position: 'absolute',
        border: '1px solid black',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        transform: `translate(
          ${position.x}px,
          ${position.y}px
        )`,
      }}
    >
      {children}
    </div>
  );
}
```

```js src/Background.js
export default function Background({ position }) {
  return (
    <div
      style={{
        position: 'absolute',
        transform: `translate(
        ${position.x}px,
        ${position.y}px
      )`,
        width: 250,
        height: 250,
        backgroundColor: 'rgba(200, 200, 0, 0.2)',
      }}
    />
  );
}
```

```css
body {
  height: 280px;
}
select {
  margin-bottom: 10px;
}
```

```json package.json
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

</Sandpack>

---

## Modifier les tableaux

- En JavaScript, il est permis de muter les tableaux, (comme les objets)
- En React, l'état doit être traité de façon immuable
- Quand on veut modifier un tableau, il faut en créer un nouveau ou le cloner
- Considérez les tableaux dans l'état comme s'ils sont en lecture seule
- Évitez la réassignation: `arr[0] = 'non'`
- Évitez les méthodes qui mutent le tableau (ex: `push()` et `pop()`).

---

## Modifier les tableaux sans mutation

- Pour modifier le tableau dans l'état, il faut passer un nouveau tableau au `setState`
- Voici une table de référence des opérations de tableau communes
- Évitez les méthodes de la colonne de gauche. Préférez les méthodes de la colonne de droite.

<div className="my-tbl" >

| Action       | Tableau muté 🚫                               | Nouveau tableau ✅                                    |
| ------------ | --------------------------------------------- | ----------------------------------------------------- |
| Ajout        | `push()`, <br /> `unshift()`                  | `concat()`, <br /> `[...arr]` (spread syntax)         |
| Suppression  | `pop()`, <br /> `shift()`, <br /> `splice()`  | `filter()`, <br /> `slice()`, <br /> `toSpliced()` 🆕 |
| Remplacement | `splice()`, <br /> `arr[i] = x` (assignation) | `map()`, <br /> `.with()` 🆕                          |
| Tri          | `sort()`, <br /> `reverse()`,                 | `toSorted()` 🆕, <br /> `toReversed()` 🆕             |

</div>
<hr />
<Alert>
Alternativement, on peut utiliser Immer qui permet l'usage des mutations.
</Alert>

---

## Ajouter à un tableau avec push 🚫

`push()` mute un tableau en ajoutant un item. (À éviter) 🚫

<Sandpack s="70">

```js
import { useState } from 'react';

let nextId = 0;

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState([]);

  return (
    <>
      <h1>Artists:</h1>
      <input value={name} onChange={(e) => setName(e.target.value)} />
      <button
        onClick={() => {
          setName('');
          artists.push({
            id: nextId++,
            name: name,
          });
        }}
      >
        Add
      </button>
      <ul>
        {artists.map((artist) => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}
```

```css
button {
  margin-left: 5px;
}
```

</Sandpack>

---

## Ajouter à un tableau avec décomposition

- On préfère plutôt la création d'un _nouveau_ tableau
- Qui contient les items existants et un nouvel item à la fin
- Plusieurs approches possibles, mais le plus simple est d'utiliser la syntaxe de décomposition: "`...`"

```js
setArtists(
  // Remplacer l'état avec un nouveau tableau
  [
    ...artists, //                   contenant les anciens items
    { id: nextId++, name: name }, // et un item additionnel à la fin.
  ]
);
```

- Si on doit ajouter au début, on inverse l'ordre:

```js
setArtists([
  { id: nextId++, name: name }, // ici, on insère item au début du tableau
  ...artists, //                   on ajoute le contenu existant par la suite
]);
```

- Permet d'ajouter à la fin (comme `push()`) ou au début (comme `unshift()`).

---

## Exemple d'ajout au tableau avec décomposition

<Sandpack s="70">

```js
import { useState } from 'react';

let nextId = 0;

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState([]);

  return (
    <>
      <h1>Artists:</h1>
      <input value={name} onChange={(e) => setName(e.target.value)} />
      <button
        onClick={() => {
          setName('');
          setArtists([...artists, { id: nextId++, name: name }]);
        }}
      >
        Add
      </button>
      <ul>
        {artists.map((artist) => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}
```

```css
button {
  margin-left: 5px;
}
```

</Sandpack>

---

## Enlever à un Tableau

```js
setArtists(artists.filter((a) => a.id !== artist.id));
```

- `filter()` génère un nouveau tableau d'`artists` avec des items en moins.

<Sandpack s="70">

```js
import { useState } from 'react';

let initialArtists = [
  { id: 0, name: 'Marta Colvin Andrade' },
  { id: 1, name: 'Lamidi Olonade Fakeye' },
  { id: 2, name: 'Louise Nevelson' },
];

export default function List() {
  const [artists, setArtists] = useState(initialArtists);

  return (
    <>
      <h1>Artists:</h1>
      <ul>
        {artists.map((artist) => (
          <li key={artist.id}>
            {artist.name}{' '}
            <button
              onClick={() => {
                setArtists(artists.filter((a) => a.id !== artist.id));
              }}
            >
              Remove
            </button>
          </li>
        ))}
      </ul>
    </>
  );
}
```

</Sandpack>

---

## Transformer un tableau avec `map`

- `map()` génère un nouveau tableau
- La fonction passée à `map` détermine comment traiter chaque item, basé sur le contenu
- Dans cet exemple, un tableau détient les coordonnées de deux cercles et un carré
- Quand on clique le bouton, on déplace les cercles de 50 pixels vers le bas

<Sandpack s="70">

```js
import { useState } from 'react';

let initialShapes = [
  { id: 0, type: 'circle', x: 50, y: 100 },
  { id: 1, type: 'square', x: 150, y: 100 },
  { id: 2, type: 'circle', x: 250, y: 100 },
];

export default function ShapeEditor() {
  const [shapes, setShapes] = useState(initialShapes);

  function handleClick() {
    const nextShapes = shapes.map((shape) => {
      if (shape.type === 'square') {
        // Pas de changement
        return shape;
      } else {
        // Retourne un cercle 50 pixels plus bas
        return {
          ...shape,
          y: shape.y + 50,
        };
      }
    });
    // Provoque un re-rendu avec le nouveau tableau
    setShapes(nextShapes);
  }

  return (
    <>
      <button onClick={handleClick}>Déplacez les cercles!</button>
      {shapes.map((shape) => (
        <div
          key={shape.id}
          style={{
            background: 'purple',
            position: 'absolute',
            left: shape.x,
            top: shape.y,
            borderRadius: shape.type === 'circle' ? '50%' : '',
            width: 20,
            height: 20,
          }}
        />
      ))}
    </>
  );
}
```

```css
body {
  height: 300px;
}
```

</Sandpack>

---

## Remplacer les items d'un tableau

- On évite les asignations du genre `arr[0] = x` qui mutent l'objet
- On préfère utiliser `map()` pour générer un nouveau tableau, basé sur le contenu et l'index

<Sandpack  s="70">

```js
import { useState } from 'react';

let initialCounters = [0, 0, 0];

export default function CounterList() {
  const [counters, setCounters] = useState(initialCounters);

  function handleIncrementClick(index) {
    const nextCounters = counters.map((c, i) => {
      if (i === index) {
        // Incrémente le compteur cliqué
        return c + 1;
      } else {
        // Le reste demeure la même chose
        return c;
      }
    });
    setCounters(nextCounters);
  }

  return (
    <ul>
      {counters.map((counter, i) => (
        <li key={i}>
          {counter}
          <button
            onClick={() => {
              handleIncrementClick(i);
            }}
          >
            +1
          </button>
        </li>
      ))}
    </ul>
  );
}
```

```css
button {
  margin: 5px;
}
```

</Sandpack>

---

## Insérer au milieu d'un tableau

- Pour insérer un item, il faut créer un tableau qui décompose la portion avant le point d'insértion, par la suite ajouter le nouvel item, et ensuite décomposer le reste du tableau.
- Pour cela, on peut utiliser la méthode `slice(start, end)` avec la syntaxe de décomposition de tableau "`...`". (Dans cet exemple, "Insérer" insère à la position 1.)

<Sandpack  s="70">

```js
import { useState } from 'react';

let nextId = 3;
const initialArtists = [
  { id: 0, name: 'Marta Colvin Andrade' },
  { id: 1, name: 'Lamidi Olonade Fakeye' },
  { id: 2, name: 'Louise Nevelson' },
];

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState(initialArtists);

  function handleClick() {
    const insertAt = 1; // Pourrait être n'importe quel index
    const nextArtists = [
      // Items avant le point d'insertion:
      ...artists.slice(0, insertAt),
      // Nouvel item
      { id: nextId++, name: name },
      // Items après le point d'insertion:
      ...artists.slice(insertAt),
    ];
    setArtists(nextArtists);
    setName('');
  }

  return (
    <>
      <h1>Artists:</h1>
      <input value={name} onChange={(e) => setName(e.target.value)} />
      <button onClick={handleClick}>Insert</button>
      <ul>
        {artists.map((artist) => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}
```

```css
button {
  margin-left: 5px;
}
```

</Sandpack>

---

## Faire des changements avancés

- Les méthodes `reverse()` et `sort()` mutent le tableau orginal
- Que faire si nous sommes avant 2023?
- Faites une **copie** du tableau d'abord, et faites des changements **mutatifs** ensuite
- La syntaxe de décomposition `[...list]` peut créer un clone du tableau original

<Sandpack s="70">

```js
import { useState } from 'react';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies' },
  { id: 1, title: 'Lunar Landscape' },
  { id: 2, title: 'Terracotta Army' },
];

export default function List() {
  const [list, setList] = useState(initialList);

  function handleClick() {
    const nextList = [...list];
    nextList.reverse();
    setList(nextList);
  }

  return (
    <>
      <button onClick={handleClick}>Inverse</button>
      <ul>
        {list.map((artwork) => (
          <li key={artwork.id}>{artwork.title}</li>
        ))}
      </ul>
    </>
  );
}
```

</Sandpack>

---

## Tableau référant des objets

- Imaginons `nextList` qui clone `list`. Le code suivant est problématique:

```js
const nextList = [...list];
nextList[0].seen = true; // Problème: mutation  🚫
setList(nextList);
```

- `nextList` et `list` sont deux tableaux distincts
- **Mais** `nextList[0]` et `list[0]` pointent vers le même objet
- En modifiant `nextList[0].seen`, on modifie aussi `list[0].seen`
- C'est donc une mutation d'état. 🚫

<hr />

- On résout ce problème de la même façon qu'avec les objets JS imbriqués
- On génère un nouvel objet plutôt que de le muter

<div style={{fontSize:"2rem"}}>
```js
nextList[0] = {...nextList[0], seen: true }; ✅
```
</div>

---

## Modifier des objets dans des tableaux

- Lorsqu'on met à jour des états imbriqués, il faut créer des copies des objets à modifier, **jusqu'au top niveau.**
- Dans cet exemple, deux listes d'oeuvres d'art partagent le même état initial
- À cause d'une valeur mutée, leur état est accidentellement partagé

<Sandpack  s="70">

```js
import { useState } from 'react';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [myList, setMyList] = useState(initialList);
  const [yourList, setYourList] = useState(initialList);

  function handleToggleMyList(artworkId, nextSeen) {
    const myNextList = [...myList];
    const artwork = myNextList.find((a) => a.id === artworkId);
    artwork.seen = nextSeen;
    setMyList(myNextList);
  }

  function handleToggleYourList(artworkId, nextSeen) {
    const yourNextList = [...yourList];
    const artwork = yourNextList.find((a) => a.id === artworkId);
    artwork.seen = nextSeen;
    setYourList(yourNextList);
  }

  return (
    <>
      <h1>Oeuvres d'art (Artwork)</h1>
      <h2>Ma liste d'art:</h2>
      <ItemList artworks={myList} onToggle={handleToggleMyList} />
      <h2>Ta liste d'art:</h2>
      <ItemList artworks={yourList} onToggle={handleToggleYourList} />
    </>
  );
}

function ItemList({ artworks, onToggle }) {
  return (
    <ul>
      {artworks.map((artwork) => (
        <li key={artwork.id}>
          <label>
            <input
              type='checkbox'
              checked={artwork.seen}
              onChange={(e) => {
                onToggle(artwork.id, e.target.checked);
              }}
            />
            {artwork.title}
          </label>
        </li>
      ))}
    </ul>
  );
}
```

</Sandpack>

---

## Décrire le problème

Le problème est ici:

```js
const myNextList = [...myList]; // On clone
const artwork = myNextList.find((a) => a.id === artworkId); // On trouve l'item
artwork.seen = nextSeen; // Problème: on mute l'item  🚫
setMyList(myNextList);
```

- Le tableau `myNextList` est nouveau
- MAIS les _items_ sont les mêmes que dans le tableau original `myList`
- Changer `artwork.seen` modifie donc l'objet _original_
- Cet objet se trouve aussi dans `yourArtworks`, causant le bogue
- Ce bogue est difficile à trouver, mais il disparait dès qu'on arrête de muter.
- **Solution:** utiliser `map` pour substituer un vieil objet avec une nouvelle version, sans mutation:

```js
setMyList(myList.map(artwork => {
  if (artwork.id === artworkId) {
    // Créer un nouvel objet, avec changements
    return { ...artwork, seen: nextSeen };
  } else {
    // Pas de changements, on conserve l'objet
    return artwork;
  }
});
```

---

## Dolution en décomposant les items des tableaux

- Ici, "`...`" est la syntaxe de décomposition pour créer la copie d'un objet
- Il n'y a plus de mutations, le bogue est réglé.

<Sandpack  s="70">

```js
import { useState } from 'react';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [myList, setMyList] = useState(initialList);
  const [yourList, setYourList] = useState(initialList);

  function handleToggleMyList(artworkId, nextSeen) {
    setMyList(
      myList.map((artwork) => {
        if (artwork.id === artworkId) {
          // Créé un nouvel objet, avec changements
          return { ...artwork, seen: nextSeen };
        } else {
          // Pas de changements, on conserve l'objet
          return artwork;
        }
      })
    );
  }

  function handleToggleYourList(artworkId, nextSeen) {
    setYourList(
      yourList.map((artwork) => {
        if (artwork.id === artworkId) {
          // Créé un nouvel objet, avec changements
          return { ...artwork, seen: nextSeen };
        } else {
          // Pas de changements, on conserve l'objet
          return artwork;
        }
      })
    );
  }

  return (
    <>
      <h1>Liste des oeuvres d'art</h1>
      <h2>Ma liste:</h2>
      <ItemList artworks={myList} onToggle={handleToggleMyList} />
      <h2>Ta liste:</h2>
      <ItemList artworks={yourList} onToggle={handleToggleYourList} />
    </>
  );
}

function ItemList({ artworks, onToggle }) {
  return (
    <ul>
      {artworks.map((artwork) => (
        <li key={artwork.id}>
          <label>
            <input
              type='checkbox'
              checked={artwork.seen}
              onChange={(e) => {
                onToggle(artwork.id, e.target.checked);
              }}
            />
            {artwork.title}
          </label>
        </li>
      ))}
    </ul>
  );
}
```

</Sandpack>

- En général, **il est permis de muter un objet qui vient tout juste d'être créé.**
- Si on insère une nouvelle oeuvre d'art, c'est donc correct de la muter
- Si on modifie un objet provenant de l'état, il faut faire un clone avant de muter

---

## Écrire une logique concise avec Immer

- En général, on ne devrait pas modifier les données profondément imbriquées
- Modifier des tableaux imbriqués, sans mutation, est répétitif et complexe
- Alternative 1: réécrire la structure pour la rendre moins profonde (aplatir)
- Alternative 2: utiliser [Immer](https://github.com/immerjs/use-immer)
- On peut alors utiliser la mutation (car Immer génère une copie de ces mutations)

<Sandpack  s="70">

```js src/App.js
import { useState } from 'react';
import { useImmer } from 'use-immer';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [myList, updateMyList] = useImmer(initialList);
  const [yourArtworks, updateYourList] = useImmer(initialList);

  function handleToggleMyList(id, nextSeen) {
    updateMyList((draft) => {
      const artwork = draft.find((a) => a.id === id);
      artwork.seen = nextSeen;
    });
  }

  function handleToggleYourList(artworkId, nextSeen) {
    updateYourList((draft) => {
      const artwork = draft.find((a) => a.id === artworkId);
      artwork.seen = nextSeen;
    });
  }

  return (
    <>
      <h1>Liste d'oeuvres d'art</h1>
      <h2>Ma liste:</h2>
      <ItemList artworks={myList} onToggle={handleToggleMyList} />
      <h2>Ta liste:</h2>
      <ItemList artworks={yourArtworks} onToggle={handleToggleYourList} />
    </>
  );
}

function ItemList({ artworks, onToggle }) {
  return (
    <ul>
      {artworks.map((artwork) => (
        <li key={artwork.id}>
          <label>
            <input
              type='checkbox'
              checked={artwork.seen}
              onChange={(e) => {
                onToggle(artwork.id, e.target.checked);
              }}
            />
            {artwork.title}
          </label>
        </li>
      ))}
    </ul>
  );
}
```

```json package.json
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

</Sandpack>

---

## Utiliser Immer

- Avec Immer, **les mutations comme `artwork.seen = nextSeen` sont permises:**

```js
updateMyTodos((draft) => {
  const artwork = draft.find((a) => a.id === artworkId);
  artwork.seen = nextSeen;
});
```

- C'est correct ici car on ne mute pas l'état original
- On mute un objet spécial `draft`, fourni par Immer
- On peut aussi utiliser `push()` ou `pop()` pour modifier `draft`.
- Dans les coulisses, Immer construit le prochain objet d'état à partir des mutations de `draft`
- Ceci permet d'avoir des gestionnaires d'événemnts plus simples et courts.

---

## Défi 9

- Écrivez la logique de `handleIncreaseClick`.
- Quand on clique "+", on incrémente le nombre

<Sandpack s="70">

```js
import { useState } from 'react';

const initialProducts = [
  {
    id: 0,
    name: 'Baklava',
    count: 1,
  },
  {
    id: 1,
    name: 'Sandwich',
    count: 5,
  },
  {
    id: 2,
    name: 'Spaghetti',
    count: 2,
  },
];

export default function ShoppingCart() {
  const [products, setProducts] = useState(initialProducts);

  function handleIncreaseClick(productId) {}

  return (
    <ul>
      {products.map((product) => (
        <li key={product.id}>
          {product.name} (<b>{product.count}</b>)
          <button
            onClick={() => {
              handleIncreaseClick(product.id);
            }}
          >
            +
          </button>
        </li>
      ))}
    </ul>
  );
}
```

```css
button {
  margin: 5px;
}
```

</Sandpack>

---

## Défi 10

- Le bouton "-" ne fait rien
- Il faut ajouter un gestionnaire d'événements qui décrémente le `count`du produit
- Quand on pèse "-" et que le compte est 1, il faut enlever le produit du panier d'achat
- On ne doit pas afficher 0

<Sandpack  s="70">

```js
import { useState } from 'react';

const initialProducts = [
  {
    id: 0,
    name: 'Baklava',
    count: 1,
  },
  {
    id: 1,
    name: 'Sandwich',
    count: 5,
  },
  {
    id: 2,
    name: 'Spaghetti',
    count: 2,
  },
];

export default function ShoppingCart() {
  const [products, setProducts] = useState(initialProducts);

  function handleIncreaseClick(productId) {
    setProducts(
      products.map((product) => {
        if (product.id === productId) {
          return {
            ...product,
            count: product.count + 1,
          };
        } else {
          return product;
        }
      })
    );
  }

  return (
    <ul>
      {products.map((product) => (
        <li key={product.id}>
          {product.name} (<b>{product.count}</b>)
          <button
            onClick={() => {
              handleIncreaseClick(product.id);
            }}
          >
            +
          </button>
          <button>–</button>
        </li>
      ))}
    </ul>
  );
}
```

```css
button {
  margin: 5px;
}
```

</Sandpack>

---

## Défi 11

- Tous les gestionnaires d'événements de `App.js` utilisent la mutation
- L'édition et la supression des todos ne fonctionnent pas
- Il faut réécrire les 3 handlers pour ne plus muter.

<Sandpack  s="70">

```js src/App.js
import { useState } from 'react';
import AddTodo from './AddTodo.js';
import TaskList from './TaskList.js';

let nextId = 3;
const initialTodos = [
  { id: 0, title: 'Acheter lait', done: true },
  { id: 1, title: 'Manger collation', done: false },
  { id: 2, title: 'Préparer du thé', done: false },
];

export default function TaskApp() {
  const [todos, setTodos] = useState(initialTodos);

  function handleAddTodo(title) {
    todos.push({
      id: nextId++,
      title: title,
      done: false,
    });
  }

  function handleChangeTodo(nextTodo) {
    const todo = todos.find((t) => t.id === nextTodo.id);
    todo.title = nextTodo.title;
    todo.done = nextTodo.done;
  }

  function handleDeleteTodo(todoId) {
    const index = todos.findIndex((t) => t.id === todoId);
    todos.splice(index, 1);
  }

  return (
    <>
      <AddTodo onAddTodo={handleAddTodo} />
      <TaskList
        todos={todos}
        onChangeTodo={handleChangeTodo}
        onDeleteTodo={handleDeleteTodo}
      />
    </>
  );
}
```

```js src/AddTodo.js
import { useState } from 'react';

export default function AddTodo({ onAddTodo }) {
  const [title, setTitle] = useState('');
  return (
    <>
      <input
        placeholder='Ajouter Todo'
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />
      <button
        onClick={() => {
          setTitle('');
          onAddTodo(title);
        }}
      >
        Ajouter
      </button>
    </>
  );
}
```

```js src/TaskList.js
import { useState } from 'react';

export default function TaskList({ todos, onChangeTodo, onDeleteTodo }) {
  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>
          <Task todo={todo} onChange={onChangeTodo} onDelete={onDeleteTodo} />
        </li>
      ))}
    </ul>
  );
}

function Task({ todo, onChange, onDelete }) {
  const [isEditing, setIsEditing] = useState(false);
  let todoContent;
  if (isEditing) {
    todoContent = (
      <>
        <input
          value={todo.title}
          onChange={(e) => {
            onChange({
              ...todo,
              title: e.target.value,
            });
          }}
        />
        <button onClick={() => setIsEditing(false)}>Confirmer</button>
      </>
    );
  } else {
    todoContent = (
      <>
        {todo.title}
        <button onClick={() => setIsEditing(true)}>Modifier</button>
      </>
    );
  }
  return (
    <label>
      <input
        type='checkbox'
        checked={todo.done}
        onChange={(e) => {
          onChange({
            ...todo,
            done: e.target.checked,
          });
        }}
      />
      {todoContent}
      <button onClick={() => onDelete(todo.id)}>Suprimer</button>
    </label>
  );
}
```

```css
button {
  margin: 5px;
}
li {
  list-style-type: none;
}
ul,
li {
  margin: 0;
  padding: 0;
}
```

</Sandpack>

---

## Défi 12

- Même exemple que précédemment, mais on répare les mutations en utilisant Immer.
- `useImmer` est déjà importé.

<Sandpack  s="70">

```js src/App.js
import { useState } from 'react';
import { useImmer } from 'use-immer';
import AddTodo from './AddTodo.js';
import TaskList from './TaskList.js';

let nextId = 3;
const initialTodos = [
  { id: 0, title: 'Acheter lait', done: true },
  { id: 1, title: 'Manger collation', done: false },
  { id: 2, title: 'Préparer du thé', done: false },
];

export default function TaskApp() {
  const [todos, setTodos] = useState(initialTodos);

  function handleAddTodo(title) {
    todos.push({
      id: nextId++,
      title: title,
      done: false,
    });
  }

  function handleChangeTodo(nextTodo) {
    const todo = todos.find((t) => t.id === nextTodo.id);
    todo.title = nextTodo.title;
    todo.done = nextTodo.done;
  }

  function handleDeleteTodo(todoId) {
    const index = todos.findIndex((t) => t.id === todoId);
    todos.splice(index, 1);
  }

  return (
    <>
      <AddTodo onAddTodo={handleAddTodo} />
      <TaskList
        todos={todos}
        onChangeTodo={handleChangeTodo}
        onDeleteTodo={handleDeleteTodo}
      />
    </>
  );
}
```

```js src/AddTodo.js
import { useState } from 'react';

export default function AddTodo({ onAddTodo }) {
  const [title, setTitle] = useState('');
  return (
    <>
      <input
        placeholder='Ajouter Todo'
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />
      <button
        onClick={() => {
          setTitle('');
          onAddTodo(title);
        }}
      >
        Ajouter
      </button>
    </>
  );
}
```

```js src/TaskList.js
import { useState } from 'react';

export default function TaskList({ todos, onChangeTodo, onDeleteTodo }) {
  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>
          <Task todo={todo} onChange={onChangeTodo} onDelete={onDeleteTodo} />
        </li>
      ))}
    </ul>
  );
}

function Task({ todo, onChange, onDelete }) {
  const [isEditing, setIsEditing] = useState(false);
  let todoContent;
  if (isEditing) {
    todoContent = (
      <>
        <input
          value={todo.title}
          onChange={(e) => {
            onChange({
              ...todo,
              title: e.target.value,
            });
          }}
        />
        <button onClick={() => setIsEditing(false)}>Confirmer</button>
      </>
    );
  } else {
    todoContent = (
      <>
        {todo.title}
        <button onClick={() => setIsEditing(true)}>Modifier</button>
      </>
    );
  }
  return (
    <label>
      <input
        type='checkbox'
        checked={todo.done}
        onChange={(e) => {
          onChange({
            ...todo,
            done: e.target.checked,
          });
        }}
      />
      {todoContent}
      <button onClick={() => onDelete(todo.id)}>Supprimer</button>
    </label>
  );
}
```

```css
button {
  margin: 5px;
}
li {
  list-style-type: none;
}
ul,
li {
  margin: 0;
  padding: 0;
}
```

```json package.json
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

</Sandpack>

---

## Devoir 4

Générer des composants React qui devrait avoir ces caractéristiques:

Un composant parent nommé "Compteur" qui gère un état nommé "compte". Ce composant aura aussi quelques gestionnaires d'états.

Ce composant génère des composants enfants.

- Un "Titre" qui affiche le contenu du compteur dans un `<h1>`.
- Des "Bouton" qui permetent d'incrémenter le contenu du compteur. On affiche 3 de ces boutons:
  - Un "Bouton" qui permet d'incrémenter le contenu par 1.
  - Un "Bouton" qui permet d'incrémenter le contenu par 10.
  - Un "Bouton" qui permet d'incrémenter le contenu par 100.

On veut le bouton affiché 3 fois, avec des props correctement configurés.

---

## Devoir (extras)

**Extra 1:** Modifier le code du bouton permettre d'ajouter un bouton qui décrémente le contenu de 10. (C'est-à-dire qui incrémente de -10) Gérer le formattage pour que ce bouton affiche d'une couleur différente quand on décrémente, et qui utilie le vocabulaire "incrémente/décrémente" correctement.

**Extra 2:** Ajouter un composant nommé "Boite", qui affiche un `<input>` avec le nombre. Il faudra gérer correctment le gestionnaire d'événement `onChange` pour lire le contenu du input (e.target.value). Il faudra convertir ce contenu vers un nombre pour modifier correctement l'état. (indice: utiliser parseInt ou (+) unaire.)

Bonne chance!

---
