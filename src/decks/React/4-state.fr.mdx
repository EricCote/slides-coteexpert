---
title: '√âtat (State)'
date: '2023-02-22'
---

# √âtat (State)

---

## √âtat

- Un composant doit parfois modifier son affichage suite √† une interaction.
  - Taper sur le clavier met √† jour un champ de saisie
  - Cliquer "Suivant" sur un carousel photo affiche la prochaine image
  - Cliquer "Acheter" ajoute un produit dans un panier d'achat
- Un composant doit g√©rer sa "m√©moire": la valeur du champ, l'image courante, le panier d'achat
- Ce sont des exemples **d'√âtats** (State)

---

import myFile from './4-state/datafile.js';

## Une variable ne suffit pas

<Sandpack  files={{
    "src/data.js": myFile
  }} s="60" >

```js
import { sculptureList } from './data.js';

export default function Gallery() {
  let index = 0;

  function handleClick() {
    index = index + 1;
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <img src={sculpture.url} alt={sculpture.alt} />
      <p>{sculpture.description}</p>
    </>
  );
}
```

```js src/useForceRefresh.js hidden
import { useState } from 'react';

export default function useForceRefresh() {
  const [_, forceRefresh] = useState({});
  return function () {
    forceRefresh({});
  };
}
```

```css
h2 {
  margin-top: 10px;
  margin-bottom: 0;
}
h3 {
  margin-top: 5px;
  font-weight: normal;
  font-size: 100%;
}
img {
  width: 120px;
  height: 120px;
}
button {
  display: block;
  margin-top: 10px;
  margin-bottom: 10px;
}
```

</Sandpack>

`handleClick` modifie une variable locale, `index`. Mais il y a deux probl√®mes:

1. **Une variable locale ne persiste pas entre les rendus.** Chaque fois qu'on fait un nouveau rendu, toutes les variables locales sont recr√©√©es.
2. **Modifier une variable locale ne g√©n√®re pas de rendu .** React ne r√©alise pas qu'il faut g√©n√©rer un nouveau rendu.

---

## Solution fournie par React

Il faut:

1. **Conserver** les donn√©es entre les rendus
2. **D√©clencher** la g√©n√©ration d'un nouveau rendu (_re-rendering_)

Le Hook [`useState`](https://reactjs.org/reference/react/useState) fournit ces deux choses.

1. **Variable state (√âtat)** Garde les donn√©es entre les rendus.
2. **Fonction setter ou setState (Fonction modification d'√©tat)** pour modifier la donn√©e et g√©n√©rer un rendu.

---

## Ajouter une variable State

```js
import { useState } from 'react';
...

const [data, setData] = useState(0);
```

- `data` est une variable d'√©tat (pour lire)
- `setData` est la fonction setter (pour modifier).
  <hr />
- La syntaxe `[` et `]` se nomme _d√©composition de tableau_ ([array destructuring](https://javascript.info/destructuring-assignment))
- Cela permet de lire les valeurs provenant d'un tableau
- Le tableau retourn√© par `useState` a toujours 2 items

---

## Modifier le state

On modifie le state dans `handleClick`.

<Sandpack    files={{
    "src/data.js": myFile
  }} s="60" >

```js
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);

  function handleClick() {
    setIndex(index + 1);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <img src={sculpture.url} alt={sculpture.alt} />
      <p>{sculpture.description}</p>
    </>
  );
}
```

```css
h2 {
  margin-top: 10px;
  margin-bottom: 0;
}
h3 {
  margin-top: 5px;
  font-weight: normal;
  font-size: 100%;
}
img {
  width: 120px;
  height: 120px;
}
button {
  display: block;
  margin-top: 10px;
  margin-bottom: 10px;
}
```

</Sandpack>

---

## useState, le premier Hook

- `useState` n'est pas le seul _hook_
- Toute fonction d√©marrant par "`use`" est un _hook_
- Les _hooks_ sont des fonctions sp√©ciales, disponibles seulement pendant que React fait un [rendu](https://reactjs.org/learn/render-and-commit#step-1-trigger-a-render)
- Les _hooks_ permettent de se connecter (_"hook into"_) dans les fonctionnalit√©s de React
- L'√©tat (_State_) est une fonctionnalit√©, mais on en verra d'autres (effect, context, memo)

---

## Caract√©ristiques des Hooks

<Alert type='warning'>
  **Attention:** les hooks (d√©butant par `use`) ne peuvent √™tre appel√©s qu'√†
  partir du "top niveau" de votre composant, ou de vos propres hooks.
</Alert>

On ne peut **PAS** appeler un hook dans:

- une condition
- une boucle
- une fonction imbriqu√©e (gestionnaire d'√©v√©nements).

<hr />

- M√™me si les hooks sont des fonctions, consid√©rez les comme des d√©clarations des besoins du composant
- On utilise les fonctionnalit√©s React au "top niveau" du composant
- Similaire aux modules import√©s au d√©but des fichiers

---

## Anatomie du `useState`

Quand on appelle [`useState`](https://beta.reactjs.org/reference/react/useState), React stocke la valeur.

```js
const [index, setIndex] = useState(0);
```

**Convention:**

- On nomme cette paire: `const [chose, setChose]`.
- On pourrait nommer diff√©remment, mais cette convention aide la compr√©hension.

L'argument de `useState` est la **valeur initiale** de l'√©tat. (Ici, la valeur 0).

√Ä chaque rendu, `useState` donne un tableau de 2 valeurs:

1. La **variable d'√©tat** (`index`) qui stocke la valeur.
2. La **fonction state setter** (`setIndex`) pour modifier la valeur de l'√©tat et d√©clencher un rendu.

---

## D√©tail du Hook:

```js
const [index, setIndex] = useState(0);

function handleNextClick() {
  setIndex(index + 1);
}
```

1. **Au premier rendu**, on passe `0` √† `useState`, React stocke `0` dans l'√©tat, le hook retourne `[0, setIndex]`.
2. **On clique et met √† jour l'√©tat** l'√©v√©nement appelle `setIndex(index + 1)`. Avec `index` de `0`, cela appelle `setIndex(1)`. React stocke `1` et g√©n√®re un nouveau rendu.
3. **Au second rendu** React appelle `useState(0)`, mais React a d√©j√† stock√© `1` dans `index`. Donc React retourne `[1, setIndex]`.
4. Ainsi de suite...

---

## Composants avec des √©tats multiples

- Un composant peut avoir de multiples variables d'√©tats
- L'exemple suivant poss√®de deux variables d'√©tat:
  - un nombre `index` (no de page)
  - un bool√©en `showMore` (bascule quand on clique "Afficher D√©tails")

<Sandpack    files={{
    "src/data.js": myFile
  }} s="60" >

```js
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleNextClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Hide' : 'Show'} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img src={sculpture.url} alt={sculpture.alt} />
    </>
  );
}
```

```css
h2 {
  margin-top: 10px;
  margin-bottom: 0;
}
h3 {
  margin-top: 5px;
  font-weight: normal;
  font-size: 100%;
}
img {
  width: 120px;
  height: 120px;
}
button {
  display: block;
  margin-top: 10px;
  margin-bottom: 10px;
}
```

</Sandpack>

On s√©pare le state quand les valeurs ne sont pas li√©es. (C'est le cas ci-haut).

Si les valeurs sont li√©es ou modifi√©es ensemble, on pr√©f√®re les combiner dans un objet unique. (Ex: un formulaire)

---

## Avanc√©: comment √ßa marche

- Il n'y a pas d'identifiant pass√© en arguments √† `useState`
- Comment React sait quelle valeur retourner?
- Les hooks se fient sur **un ordre d'appel, qui reste stable** dans un composant donn√©.
- C'est gr√¢ce √† la r√®gle des hooks: il faut les placer au "top niveau" d'un composant. (Il y a m√™me un [linter](https://www.npmjs.com/package/eslint-plugin-react-hooks) qui permet de d√©tecter les erreurs.)
- React utilise un tableau de paires pour chaque composant.
- Il maintient un index sur l'usage des hooks et l'incr√©mente √† chaque appel de useState. Voir: [React Hooks: Not Magic, Just Arrays.](https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e)
  <hr />
  L'exemple suivant n'utilise **PAS** React. Mais il d√©montre comment fonctionne
  les hooks:

<Sandpack    files={{
    "src/data.js": myFile
  }}  s="60" >

```js src/index.js active
import { sculptureList } from './data.js';

let componentHooks = [];
let currentHookIndex = 0;

// D√©montre le concept de useState (simplifi√©).
function useState(initialState) {
  let pair = componentHooks[currentHookIndex];
  if (pair) {
    // Apr√®s le premier rendu,
    // La paire d'√©tat existe d√©j√†
    // Il faut incr√©menter l'index et retourner la paire
    currentHookIndex++;
    return pair;
  }

  // Quand c'est un premier rendu,
  // On cr√©√© la paire d'√©tat et on la stocke.
  pair = [initialState, setState];

  function setState(nextState) {
    // Quand on modifie l'√©tat,
    // On met la nouvelle valeur dans la paire
    pair[0] = nextState;
    updateDOM();
  }

  // Stockons la paire pour les prochains rendus
  // Et on se pr√©pare pour le prochain appel Hook
  componentHooks[currentHookIndex] = pair;
  currentHookIndex++;
  return pair;
}

function Gallery() {
  // Chaque appel √† useState() obtient la paire suivante.
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  // On n'utilise pas React
  // On retourne un objet plut√¥t que du JSX.
  return {
    onNextClick: handleNextClick,
    onMoreClick: handleMoreClick,
    header: `${sculpture.name} by ${sculpture.artist}`,
    counter: `${index + 1} of ${sculptureList.length}`,
    more: `${showMore ? 'Hide' : 'Show'} details`,
    description: showMore ? sculpture.description : null,
    imageSrc: sculpture.url,
    imageAlt: sculpture.alt,
  };
}

function updateDOM() {
  // Reset the current Hook index
  // before rendering the component.
  currentHookIndex = 0;
  let output = Gallery();

  // Update the DOM to match the output.
  // This is the part React does for you.
  nextButton.onclick = output.onNextClick;
  header.textContent = output.header;
  moreButton.onclick = output.onMoreClick;
  moreButton.textContent = output.more;
  image.src = output.imageSrc;
  image.alt = output.imageAlt;
  if (output.description !== null) {
    description.textContent = output.description;
    description.style.display = '';
  } else {
    description.style.display = 'none';
  }
}

let nextButton = document.getElementById('nextButton');
let header = document.getElementById('header');
let moreButton = document.getElementById('moreButton');
let description = document.getElementById('description');
let image = document.getElementById('image');

// Make UI match the initial state.
updateDOM();
```

```html public/index.html
<button id="nextButton">Next</button>
<h3 id="header"></h3>
<button id="moreButton"></button>
<p id="description"></p>
<img id="image" />

<style>
  * {
    box-sizing: border-box;
  }
  body {
    font-family: sans-serif;
    margin: 20px;
    padding: 0;
  }
  button {
    display: block;
    margin-bottom: 10px;
  }
</style>
```

```css
button {
  display: block;
  margin-bottom: 10px;
}
```

</Sandpack>

---

## L'√©tat est isol√© et priv√©

- L'√©tat est local √† l'instance du composant.
- **Si on affiche deux fois le m√™me composant, chacun d'eux a son propre √©tat isol√©.**
- Changer l'un n'affecte pas l'autre.

<Sandpack    files={{
    "src/data.js": myFile
  }} s="60" >

```js
import Gallery from './Gallery.js';

export default function Page() {
  return (
    <div className='Page'>
      <Gallery />
      <Gallery />
    </div>
  );
}
```

```js src/Gallery.js
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <section>
      <button onClick={handleNextClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Hide' : 'Show'} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img src={sculpture.url} alt={sculpture.alt} />
    </section>
  );
}
```

```css
button {
  display: block;
  margin-bottom: 10px;
}
.Page > * {
  float: left;
  width: 50%;
  padding: 10px;
}
h2 {
  margin-top: 10px;
  margin-bottom: 0;
}
h3 {
  margin-top: 5px;
  font-weight: normal;
  font-size: 100%;
}
img {
  width: 120px;
  height: 120px;
}
button {
  display: block;
  margin-top: 10px;
  margin-bottom: 10px;
}
```

</Sandpack>

---

## L'√©tat est isol√©

- L'√©tat n'est li√© ni √† une fonction, ni √† un module
- Il est li√© √† l'instance d'un composant qui affiche sur la page
- Quand on affiche deux composants `Gallery`, React g√®re donc deux states
  <hr />
- Le composant `Page` ne connait rien de l'√©tat de `Gallery`
- L'√©tat est compl√®tement priv√© au composant qui le d√©clare
- Le parent ne peut le changer
- On peut ajouter ou enlever de l'√©tat sans affecter le reste des composants
  <hr />
- Si on veut que les deux galleries partagent leurs √©tats?
- La bonne pratique en React:
  - Enlever l'√©tat aux composants enfants pour le rajouter √† leur parent partag√©
  - On couvre cela plus tard

---

## D√©fi 1

- Quand on clique "Next" √† la derni√®re image, le code plante
- 2 approches pour r√©parer (faites les 2):
  1. On ajoute de la logique au gestionnaire d'√©v√©nments
  1. On d√©sactive le bouton quand l'action n'est pas possible.

**Boni:** ajoutez un bouton "previous" pour revenir en arri√®re. Emp√™chez que √ßa plante √† la premi√®re image.

<Sandpack    files={{
    "src/data.js": myFile
  }} s="60" >

```js
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleNextClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Hide' : 'Show'} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img src={sculpture.url} alt={sculpture.alt} />
    </>
  );
}
```

```css
button {
  display: block;
  margin-bottom: 10px;
}
.Page > * {
  float: left;
  width: 50%;
  padding: 10px;
}
h2 {
  margin-top: 10px;
  margin-bottom: 0;
}
h3 {
  margin-top: 5px;
  font-weight: normal;
  font-size: 100%;
}
img {
  width: 120px;
  height: 120px;
}
```

</Sandpack>

---

## D√©fi 2

√áa ne fonctionne pas. Il faudrait reprogrammer en utilisant de l'√©tat.

<Sandpack s="60">

```js
export default function Form() {
  let firstName = '';
  let lastName = '';

  function handleFirstNameChange(e) {
    firstName = e.target.value;
  }

  function handleLastNameChange(e) {
    lastName = e.target.value;
  }

  function handleReset() {
    firstName = '';
    lastName = '';
  }

  return (
    <form onSubmit={(e) => e.preventDefault()}>
      <input
        placeholder='First name'
        value={firstName}
        onChange={handleFirstNameChange}
      />
      <input
        placeholder='Last name'
        value={lastName}
        onChange={handleLastNameChange}
      />
      <h1>
        Hi, {firstName} {lastName}
      </h1>
      <button onClick={handleReset}>Reset</button>
    </form>
  );
}
```

```css
h1 {
  margin-top: 10px;
}
```

</Sandpack>

---

## D√©fi 3

Ce formulaire permet aux usagers de laisser du feedback. Quand on soumet du feedback, on devrait afficher "Merci". Mais cela plante avec le message d'erreur: "Rendered fewer hooks than expected". Il faut r√©parer l'erreur

<Hint>D'o√π peut-on appeler un hook? Ce composant brise-t-il une r√®gle?</Hint>

<Sandpack s="60">

```js
import { useState } from 'react';

export default function FeedbackForm() {
  const [isSent, setIsSent] = useState(false);
  if (isSent) {
    return <h1>Thank you!</h1>;
  } else {
    // eslint-disable-next-line
    const [message, setMessage] = useState('');
    return (
      <form
        onSubmit={(e) => {
          e.preventDefault();
          alert(`Sending: "${message}"`);
          setIsSent(true);
        }}
      >
        <textarea
          placeholder='Message'
          value={message}
          onChange={(e) => setMessage(e.target.value)}
        />
        <br />
        <button type='submit'>Send</button>
      </form>
    );
  }
}
```

</Sandpack>

---

## Rendu et commit

React g√®re un cycle pour afficher des donn√©es. Voici ce cycle:

1. **Lancer un d√©clencheur** qui provoque un rendu
2. **G√©n√®rer le rendu** du composant
3. **√âcrire le commit** vers le DOM

---

## √âtape 1: Lancer un d√©clencheur

Il y a deux raisons pour qu'un composant soit rendu.

1. C'est le **rendu initial** du composant
2. **L'√©tat est modifi√©** sur le composant (ou l'un des parents).

---

## Rendu initial

- On appelle `createRoot` sur l'√©l√©ment du DOM, et on appelle la m√©thode `render`.

<Sandpack s="60">

```js src/index.js active
import Image from './Image.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(<Image />);
```

```js src/Image.js
export default function Image() {
  return (
    <img
      src='https://i.imgur.com/ZF6s192.jpg'
      alt="'Floralis Gen√©rica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"
    />
  );
}
```

</Sandpack>

**NOTE:** Commentez `root.render()` et le composant disparait.

- Certaines bo√Ætes √† outils cachent ce code.

---

## Re-rendus d√©clench√©s par une modification de l'√©tat

- Apr√®s le rendu initial, on d√©clenche des rendus additionnels en modifiant l'√©tat avec `setState`.
- Modifier l'√©tat ajoute un re-rendu dans la file.
- On peut ajouter plusieurs rendus additionnels dans la file.
- React regroupe les √©l√©ments de la file dans **un seul rendu** (Automatic batching of renders)

---

## √âtape 2: On g√©n√®re un Rendu du composant

- Apr√®s le d√©clenchement du rendu, React appelle les composants pour g√©n√©rer l'affichage.

**"Faire un rendu", c'est React qui appelle les composants.**

- **Au rendu initial** React appelle le composant racine.
- **Pour les rendus suivants** React appelle le composant ayant l'√©tat modifi√©.

<hr />

- C'est un processus **r√©cursif**.
- Si le composant utilise d'autres composants, ils seront aussi appel√©s
  - Ainsi que leurs enfants
    - Ainsi que les petits-enfants
      - Ainsi de suite
- Le processus continue jusqu'√† ce que tous les sous-composants soient rendus
- React sait alors quoi afficher

---

## G√©n√©rer un rendu

<Sandpack  s="70">

```js src/Gallery.js active
export default function Gallery() {
  return (
    <section>
      <h1>Inspiring Sculptures</h1>
      <Image />
      <Image />
      <Image />
    </section>
  );
}

function Image() {
  return (
    <img
      src='https://i.imgur.com/ZF6s192.jpg'
      alt="'Floralis Gen√©rica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"
    />
  );
}
```

```js src/index.js
import Gallery from './Gallery.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(<Gallery />);
```

```css
img {
  margin: 0 10px 10px 0;
}
```

</Sandpack>

- **Apr√®s le rendu initial** React [g√©n√®re des noeuds (node) du DOM](https://developer.mozilla.org/docs/Web/API/Document/createElement) pour `<section>`, `<h1>`, et trois balises `<img>`.
- **Apr√®s le re-rendu,**, React d√©termine quelles propri√©t√©s ont chang√©, si c'est le cas, On compare avec le rendu pr√©c√©dent. (Cette information sera utile √† la prochaine √©tape.)

---

## Le Rendu est pur

<Alert type="warning">

Le rendu doit toujours √™tre une [fonction pure](https://react.dev/learn/keeping-components-pure):

</Alert>

- **'M√™mes entr√©es, m√™mes sorties'** Avec les m√™me entr√©es et param√®tres, le composant retourne le m√™me JSX
- **On ne touche √† rien √† l'ext√©rieur du composant** On ne doit modifier ni objets, ni variables existantes.

  - Si on oublie ces principes, on pourrait rencontrer des bogues difficiles √† d√©tecter
  - Quand on d√©veloppe en **Strict Mode**, React appelle chaque fonction 2 fois au rendu
  - Ceci aide √† d√©tecter les fonctions impures

---

## Optimiser la performance

- Par d√©faut, un changement de state provoque un re-rendu du composant
- Ainsi que **tous ses sous-composants** (et ainsi de suite)
- C'est lourd
- Il existe des strat√©gies pour optimiser la performance. Ex: `createMemo()` et **React Compiler**
  - On voit cela dans le chapitre sur la performance

---

## √âtape 3: React √©crit le commit vers le DOM

Apr√®s le rendu (l'appel) des composants, React fait un commit en modifiant le DOM.

- **Pour le rendu initial** React appelle [`appendChild()`](https://developer.mozilla.org/docs/Web/API/Node/appendChild) pour ajouter les noeuds DOM.
- **Pour les rendus suivants** React applique les modifications minimales (compar√©es pendant le rendu) pour que le DOM corresponde au dernier rendu g√©n√©r√©.

---

## React ne modifie le DOM que pour les √©l√©ments modifi√©s

- Ce composant g√©n√®re un re-rendu avec de nouvelles props √† chaque seconde.
- On peut ajouter du texte au `<input>`, et le texte ne disparait pas au moment du re-rendu:

<Sandpack  s="70">

```js src/Clock.js active
export default function Clock({ time }) {
  return (
    <>
      <h1>{time}</h1>
      <input />
    </>
  );
}
```

```js src/App.js hidden
import { useState, useEffect } from 'react';
import Clock from './Clock.js';

function useTime() {
  const [time, setTime] = useState(() => new Date());
  useEffect(() => {
    const id = setInterval(() => {
      setTime(new Date());
    }, 1000);
    return () => clearInterval(id);
  }, []);
  return time;
}

export default function App() {
  const time = useTime();
  return <Clock time={time.toLocaleTimeString()} />;
}
```

</Sandpack>

- Au commit, React modifie le contenu `<h1>`
- `<input>` est aussi g√©n√©r√©, mais sans modifications
- React ne touche donc pas au `value` du `<input>`

---

## L'apr√®s-ex√©cution: Browser paint

Rappel des diff√©rentes √©tapes:

1. **Lancer un d√©clencheur** qui provoque un rendu
2. **G√©n√©rer le rendu** du composant
3. **√âcrire le commit** en modifiant le DOM

- Apr√®s le commit, les modifications sont affich√©es.
  - La documentation du navigateur appelle cela "_browser rendering_"
  - La documentation React se distingue en appelant cela "**browser painting**"

---

## En r√©sum√©

- Voici les trois √©tapes d'affichage sur React
  1. D√©clencheur (Trigger)
  2. Rendu (Render)
  3. √âcriture du DOM (Commit)
- `<StrictMode>` permet de trouver les composants impurs
- React ne touche pas au DOM quand le rendu est le m√™me que la fois pr√©c√©dente

---

## Modifier l'√©tat d√©clenche un rendu

Dans plusieurs environnements, on consid√®re que la modification d'une interface usager est le r√©sultat d'un √©v√©nement, tel que le clic d'un bouton.

Dans React, c'est l'inverse.

Il faut **modifier l'√©tat** pour que l'interface usager soit affect√©e.

---

## Exemple

Quand on presse "send", `setIsSent(true)` modifie l'√©tat, et g√©n√®re un re-rendu.

<Sandpack  s="70">

```js
import { useState } from 'react';

export default function Form() {
  const [isSent, setIsSent] = useState(false);
  const [message, setMessage] = useState('Bonjour!');
  if (isSent) {
    return <h1>Votre message est envoy√©</h1>;
  }
  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        setIsSent(true);
        sendMessage(message);
      }}
    >
      <textarea
        placeholder='Message'
        value={message}
        onChange={(e) => setMessage(e.target.value)}
      />
      <button type='submit'>Envoyer</button>
    </form>
  );
}

function sendMessage(message) {
  // ...
}
```

```css
label,
textarea {
  margin-bottom: 10px;
  display: block;
}
```

</Sandpack>

<Hint>
Quand on clique le bouton

1. Le gestionnaire d'√©v√©nements `onSubmit` ex√©cute.
2. `setIsSent(true)` modifie `isSent` √† `true` place le rendu dans la file.
3. React g√©n√®re le re-rendu en utilisant la nouvelle valeur de `isSent`.

</Hint>

---

## Rendu g√©n√®re un Snapshot dans le temps

- G√©n√©rer un "rendu" signifie que React appelle le composant (i.e. une fonction).
- Le JSX retourn√© est une photo instantan√©e (un snapshot) de l'IU, √† ce moment pr√©cis dans le temps
- Les props, gestionnnaires d'√©v√©nements et variables locales sont g√©n√©r√©es **√† partir de l'√©tat, au moment du rendu.**
- Ce snapshot de l'IU inclut des gesionnaires d'√©v√©nements
  - Sp√©cifiant le comportement quand un usager interagit
  - React modifie l'√©cran pour synchroniser ce qui est affich√© (DOM) avec ce qui a √©t√© g√©n√©r√© (incluant la connection √† des event handlers.)

<Alert >
Quand React fait un re-rendu d'un composant:

1. React appelle votre fonction
2. Cette fonction retourne un snapshot JSX
3. React modifie l'√©cran pour synchroniser avec le snapshot

</Alert>

---

## L'√©tat est g√©r√© par React

- L'√©tat est conserv√© entre les appels
- Diff√©rent des variables locales
  - Disparaissent quand la fonction est compl√©t√©e (quand le JSX est retourn√©)
- L'√©tat est conserv√© par React, √† l'ext√©rieur de la fonction.
- Quand React appelle un composant, il offre un snapshot de l'√©tat pour ce rendu particulier
- Le composant retourne alors un snapshot du IU avec ces nouveaux props et gestionnaires d'√©v√©nements, g√©n√©r√©s √† partir des valeurs d'√©tats de ce rendu

---

## L'√©tat n'est pas modifi√© imm√©diatement

On pourrait s'attendre √† ce que cliquer le bouton "+3" incr√©mente de le compteur de 3. Mais ce n'est pas le cas.

<Sandpack  s="70">

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

On n'incr√©mente qu'une seule fois.

---

## Modifier le state n'affecte que le prochain rendu

Pendant le premier rendu, `number` √©tait `0`. C'est pourquoi, le gestionnaire d'√©v√©nement `onClick` consid√®re que la valeur de `number` demeure `0` m√™me apr√®s l'appel √† `setNumber(number + 1)`:

Voici ce qui est ex√©cut√©:

<TwoColumns style={{gridTemplateColumns:'15em auto'}} top>

```js
<button
  onClick={() => {
    setNumber(number + 1);
    setNumber(number + 1);
    setNumber(number + 1);
  }}
>
  +3
</button>
```

<div>

1. `number` est `0` donc `setNumber(0 + 1)`.
   - React modifiera `number` √† `1` au prochain rendu.
2. `number` est `0` donc `setNumber(0 + 1)`.
   - React modifiera `number` √† `1` au prochain rendu.
3. `number` est `0` donc `setNumber(0 + 1)`.
   - React modifiera `number` √† `1` au prochain rendu.

</div>
</TwoColumns>

- `number` demeure `0`
- On modifie l'√©tat vers `1` trois fois
- Le r√©sultat final affiche `1` (plut√¥t que `3`)

---

## Autre explication

<TwoColumns>
<div>
Une autre fa√ßon de visualiser, c'est de substituer les √©tats avec leur valeur. Au premier rendu:

```js
<button
  onClick={() => {
    setNumber(0 + 1);
    setNumber(0 + 1);
    setNumber(0 + 1);
  }}
>
  +3
</button>
```

</div>
<div>
Au rendu suivant, `number` est `1`. Donc pour _ce rendu_, le gestionnaire d'√©v√©nements est alors:

```js
<button
  onClick={() => {
    setNumber(1 + 1);
    setNumber(1 + 1);
    setNumber(1 + 1);
  }}
>
  +3
</button>
```

</div>
</TwoColumns >

C'est pourquoi la progression est `1`, `2`, `3`, `4` et ainsi de suite.

---

## L'√©tat √† travers le temps

Quel sera le r√©sultat de cette alerte?

<Sandpack  s="70">

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          alert(number);
        }}
      >
        +5
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

<Hint>
Si vous substituez, vous pouvez deviner que c'est z√©ro:

```js
setNumber(0 + 5);
alert(0);
```

</Hint>

---

## Question

Si on met un minuteur sur cette alerte, pour qu'elle soit lanc√©e seulement apr√®s que le re-rendu soit compl√©t√©? Ce serait "0" ou "5"? (Devinez!)

<Sandpack  s="70">

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          setTimeout(() => {
            alert(number);
          }, 3000);
        }}
      >
        +5
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

<Hint>

Si vous utilisez la m√©thode de substitution, on voit clairement l'√©tat pass√© √† l'alerte.

<TwoColumns>

```js
setNumber(0 + 5);
setTimeout(() => {
  alert(0);
}, 3000);
```

L'√©tat stock√© dans React est chang√© au moment o√π l'alerte √©x√©cute, mais c'est planifi√© au moment o√π la valeur n'a pas encore chang√©. C'est le moment du snapshot.

</TwoColumns>

</Hint>

---

## L'√©tat n'est jamais modifi√© pendant le rendu

- L'√©tat n'est pas modifi√© pendant le rendu, m√™me quand le code est asynchrone (ex: minuteur ou _timer_)
- Dans le `onClick`, la valeur `number` continue d'√™tre `0` m√™me apr√®s que `setNumber(number + 5)` ne soit appel√©
- Sa valeur s'est fix√©e quand React a "pris son snapshot" de l'IU
- Le code est moins fragile aux erreurs de synchonisation et de timing

<hr />

---

## L'√©tat est une machine √† voyager dans le temps

Imaginons un fomulaire qui envoie un message avec un d√©lai de 3 secondes:

1. On clique sur "Envoyer" pour dire "Bonjour" √† Alice
2. Avant la fin du d√©lai de 3 secondes, on change la valeur du "destinataire" pour "Bob"

Que devrait afficher `alert`? "Bonjour √† Alice" ou "Bonjour √† Bob"?

<Sandpack s="70">

```js
import { useState } from 'react';

export default function Form() {
  const [to, setTo] = useState('Alice');
  const [message, setMessage] = useState('Bonjour');

  function handleSubmit(e) {
    e.preventDefault();
    setTimeout(() => {
      alert(`Vous dites ${message} √† ${to}`);
    }, 3000);
  }

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Destinataire:{' '}
        <select value={to} onChange={(e) => setTo(e.target.value)}>
          <option value='Alice'>Alice</option>
          <option value='Bob'>Bob</option>
        </select>
      </label>
      <textarea
        placeholder='Message'
        value={message}
        onChange={(e) => setMessage(e.target.value)}
      />
      <button type='submit'>Envoyer</button>
    </form>
  );
}
```

```css
label,
textarea {
  margin-bottom: 10px;
  display: block;
}
```

</Sandpack>

- **React conserve les valeurs d'√©tats "fix√©es" dans les gestionnaires d'√©v√©nements de _ce rendu_.**
- Ne pas s'inqui√©ter d'un changement d'√©tat pendant l'ex√©cution du code
- Que faire si on doit lire le dernier √©tat avant un re-render?
  - On pourrait utiliser une fonction de modification d'√©tat. On verra cela bient√¥t.

---

## D√©fi 4

Voici un feu de circulation pour pi√©tons. Ajoutez une `alert` au gestionnaire du clic:

- Quand la lumi√®re est verte et dit ¬®Walk¬®, cliquer le bouton devrait afficher "Stop is next"
- Quand la lumi√®re est rouge et dit "Stop", cliquer le bouton devrait afficher "Walk is next"

Est-ce que √ßa fait une diff√©rence lorsqu'on met l'alerte avant ou apr√®s l'appel `setWalk`?

<Sandpack  s="70">

```js
import { useState } from 'react';

export default function TrafficLight() {
  const [walk, setWalk] = useState(true);

  function handleClick() {
    setWalk(!walk);
  }

  return (
    <>
      <button onClick={handleClick}>Change to {walk ? 'Stop' : 'Walk'}</button>
      <h1
        style={{
          color: walk ? 'darkgreen' : 'darkred',
        }}
      >
        {walk ? 'Walk' : 'Stop'}
      </h1>
    </>
  );
}
```

```css
h1 {
  margin-top: 20px;
}
```

</Sandpack>

---

## React regroupe les modification d'√©tats en lots (batch)

<Sandpack  s="70">

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

<TwoColumns>

```js
setNumber(0 + 1);
setNumber(0 + 1);
setNumber(0 + 1);
```

Chaque rendu est fix√© au moment qu'il est g√©n√©r√©, donc la valeur `number` demeure `0`, m√™me lorsqu'on appelle `setNumber(1)` plusieurs fois.

</TwoColumns>

Il y a aussi une autre raison: **React attend que tous les gestionnaires d'√©v√©nements aient fini de rouler avant de modifier l'√©tat.**
C'est pourquoi le re-rendu ne s'ex√©cute _qu'apr√®s_ tous les `setNumber()`;

---

## Optimisation: Regrouper les setState en lot (batch)

- Similaire √† l'exp√©rience au resto:
- Un serveur prend tous les d√©tails de la commande avant de partir √† la cuisine
- S'il n'√©tait pas tr√®s fut√©, il pourrait partir √† la cuisine √† mesure d√®s que vous commandez de la soupe, et revenir... Et repartir d√®s que vous commandez une boisson, et revenir... ainsi de suite... √ßa ne serait pas tr√®s efficace.
- Cette approche permet de modifier plusieurs variables d'√©tats, provenant de plusieurs composants, dans un seul re-rendu.
- L'Interface Usager ne sera pas mise √† jour tant qu'on n'aura pas compl√©t√© les gestionnaires d'√©v√©nements. (mousedown, mouseup, click)
- C'est ce qu'on appelle le regroupement par lot (batching)
- Cette optimisation am√©liore les performances
- Cela √©vite les "rendus √† moiti√©", o√π seulement certaines variables ont √©t√© mises-√†-jour.

<Alert type="warning">

- **React ne regroupe pas √† travers de _multiples_ √©v√©nements intentionnels
  (ex: multiples clics)**
- Chaque clic est g√©r√© s√©par√©ment
- React ne regroupe que l√† o√π √ßa fait du sens (mouseup et click)
- Cela assure que si le premier clic
  d√©sactive le fomulaire, le second clic ne soumettra pas le formulaire une
  seconde fois.

</Alert>

---

## Modifier l'√©tat de multiples fois dans un lot

C'est un cas rare, mais si on d√©sire modifier l'√©tat plusieurs fois:

- On remplace la valeur `setNumber(number + 1)`, par une fonction `setNumber((n) => n + 1)`
- Indique √† React: "ex√©cute le code plus tard"
- La fonction updater prend un param√®tre (l'√©tat courant) et retourne l'√©tat suivant.

<Sandpack  s="70">

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber((n) => n + 1);
          setNumber((n) => n + 1);
          setNumber((n) => n + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

---

## Explications

Ici, `(n) => n + 1` est une **fonction updater.** Quand on passe cette fonction √† un `setState()`:

1. React ajoute cette fonction √† la file pour √™tre trait√© apr√®s que le gestionnaire d'√©v√©nements ait termin√©.
2. Durant le prochain rendu, React passe √† travers la file pour ex√©cuter et retourner l'√©tat modifi√©.

Voici comment React g√®re ces lignes de code dans le gestionnaire d'√©v√©nements :

<TwoColumns style={{gridTemplateColumns:'15em auto'}} top>

```js
setNumber((n) => n + 1);
setNumber((n) => n + 1);
setNumber((n) => n + 1);
```

<div>

1. `n => n + 1` est une fonction. React l'ajoute √† la file.
2. `n => n + 1` est une fonction. React l'ajoute √† la file.
3. `n => n + 1` est une fonction. React l'ajoute √† la file.

</div>
</TwoColumns >

---

## Explications

- Quand React est pr√™t √† modifier l'√©tat, React passe √† travers la file.
- L'√©tat pr√©c√©dent `number` est `0`, React passe cette valeur √† la premi√®re fonction updater (par le param√®tre `n`).

import './table-rows.css';

<div className="my-tbl" >

| file de fonctions | `n` | calcul   | retourne |
| ----------------- | --- | -------- | -------- |
| `n => n + 1`      | `0` | `0 + 1 ` | 1        |
| `n => n + 1`      | `1` | `1 + 1`  | 2        |
| `n => n + 1`      | `2` | `2 + 1 ` | 3        |

</div>

React stocke `3` comme r√©sultat final et le retourne via le `useState`.

C'est pour cela que l'exemple pr√©c√©dent fonctionne lorsqu'on clique "+3"

---

## Si on modifie le state apr√®s l'avoir remplac√©

Que penser de ce gestionnaire d'√©v√©nements.

```js
<button onClick={() => {
  setNumber(number + 5);
  setNumber(n => n + 1);
}}>
```

<Sandpack  s="70">

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          setNumber((n) => n + 1);
        }}
      >
        Increase the number
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

---

## Explications

1. `setNumber(number + 5)`: `number` est `0`, donc `setNumber(0 + 5)`. React ajoute _"replacer avec `5`"_ dans la file.
2. `setNumber((n) => n + 1)`: `(n) => n + 1` est une fonction updater. React ajoute _cette fonction_ dans la file.

Pendant le prochain rendu, React passe par la file d'√©tat:

<div className="my-tbl" >

| file               | `n`           | retourne    |
| ------------------ | ------------- | ----------- |
| "remplace par `5`" | `0` (inutile) | `5`         |
| `(n) => n + 1`     | `5`           | `5 + 1 = 6` |

</div>
<hr/>

React stocke `6` comme r√©sultat final pour le prochain rendu.

Remarquez que `setState(x)` fonctionne comme `setState((n) => x)`, o√π `n` n'est pas utilis√©!

---

## Si on remplace l'√©tat apr√®s l'avoir modifi√©

Quelle sera la valeur ici?

```js
<button onClick={() => {
  setNumber(number + 5);
  setNumber(n => n + 1);
  setNumber(42);
}}>
```

<Sandpack  s="70">

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          setNumber((n) => n + 1);
          setNumber(42);
        }}
      >
        Increase the number
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

---

## Explications

1. `setNumber(number + 5)`: `number` est `0`, donc `setNumber(0 + 5)`. React ajoute _"remplacer avec `5`"_ √† la file.
2. `setNumber(n => n + 1)`: `n => n + 1` est une fonction updater. React ajoute _cette fonction_ √† la file.
3. `setNumber(42)`: React ajoute _"remplacer avec `42`"_ √† la file.

Pendant le prochain rendu, React passe √† travers la file

<div className="my-tbl" >

| file                  | `n`           | retourne    |
| --------------------- | ------------- | ----------- |
| "remplacer avec `5`"  | `0` (inutile) | `5`         |
| `n => n + 1`          | `5`           | `5 + 1 = 6` |
| "remplacer avec `42`" | `6` (inutile) | `42`        |

</div>
<hr/>

React stocke `42` comme r√©sultat final et le retourne via le `useState`

---

## Convention de noms

C'est commun de nommer l'argument de la fonction par les premi√®res lettres du state.

```js
setEnabled((e) => !e);
setLastName((ln) => ln.reverse());
setFriendCount((fc) => fc * 2);
```

Si on pr√©f√®re utiliser plus de lettres, une autre convention serait d'utiliser le nom de l'√©tat, avec ou sans pr√©fixe.

```js
setEnabled((enabled) => !enabled);
setEnabled((prevEnabled) => !prevEnabled);
```

---

## R√©sum√©

Deux fa√ßons d'appeler `setNumber`:

1. **Avec une fonction updater n** (i.e. `(n) => n + 1`) qui se fait ajouter dans la file.
2. **Avec une valeur** (i.e. nombre `5`) ajoute "remplacer avec `5`" √† la file, en ignorant ce qui est d√©j√† pr√©sent.

- C'est apr√®s la s√©rie d'√©v√©nements, avant le re-rendu, que React appelle la file des **updaters**.
- Les **updaters** doivent √™tre des fonctions pures
- Ne pas mettre d'effets de bord, ni de setState.
- En mode Strict, React ex√©cute chaque fonction **updater** deux fois (mais exclut le second r√©sultat)
  - √áa aide √† trouver les effets de bords ind√©sirables.

---

## D√©fi 5

On travaille sur une application d'achat. Chaque fois qu'un usager clique le boutton "Acheter", le compteur "achats en attente" doit augmenter de un. Apr√®s 3 secondes, le compteur "en attente" doit diminuer et le compteur "achats compl√©t√©s" doit augmenter.

Mais ce code est bris√©. Quand on clique "Acheter", il diminue √† "-1" (√ßa ne devrait pas √™tre possible). Et si on clique rapidement, le r√©sultat est bizarre.

R√©parez les compteurs.

<Sandpack s="70">

```js
import { useState } from 'react';

export default function RequestTracker() {
  const [pending, setPending] = useState(0);
  const [completed, setCompleted] = useState(0);

  async function handleClick() {
    setPending(pending + 1);
    await delay(3000);
    setPending(pending - 1);
    setCompleted(completed + 1);
  }

  return (
    <>
      <h3>Achats en attente: {pending}</h3>
      <h3>Achats compl√©t√©s: {completed}</h3>
      <button onClick={handleClick}>Acheter</button>
    </>
  );
}

function delay(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
```

</Sandpack>

---

## React et les mutations d'objets

- En React, on ne devrait jamais modifier un objet stock√© dans l'√©tat
- Plut√¥t que de muter un objet, on devrait cr√©er de nouvelles copies qu'on modifie

---

## Types immuables

N'importe quel type de valeur peut √™tre stock√© par l'√©tat.

```js
const [x, setX] = useState(0);
```

Types immuables (qu'on ne peut modifier):

- nombres
- chaines de caract√®res
- bool√©ens

On ne peut _modifier_ ces types. Mais on peut _remplacer_ la valeur.

```js
setX(5);
```

L'√©tat `x` de `0` est remplac√© par `5`, (`0` n'a pas mut√©.)

---

## Types mutables

Consid√©rons un objet dans l'√©tat:

```js
const [position, setPosition] = useState({ x: 0, y: 0 });
```

Quand on modifie le contenu de l'objet, **c'est nomm√© une mutation:**

```js
position.x = 5;
```

- Les objets dans un √©tat React sont, techniquement, mutables
- **MAIS**, on devrait toujours les traiter **comme si** ils √©taient immuables
  - Tel un nombre, bool√©en ou cha√Æne de caract√®res
- Plut√¥t que de les muter, on pr√©f√©rera les **remplacer**.
- On devrait toujours traiter les objets JS dans l'√©tat comme en **lecture seulement.**

---

## React ignore les mutations

- L'objet suivant repr√©sente la position d'un pointeur
- Quand on touche ou d√©place le curseur, on modifie la position
- Mais le point rouge reste immobile

<Sandpack s="70">

```js
import { useState } from 'react';
export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0,
  });
  return (
    <div
      onPointerMove={(e) => {
        position.x = e.clientX;
        position.y = e.clientY;
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}
    >
      <div
        style={{
          position: 'absolute',
          backgroundColor: 'red',
          borderRadius: '50%',
          transform: `translate(${position.x}px, ${position.y}px)`,
          left: -10,
          top: -10,
          width: 20,
          height: 20,
        }}
      />
    </div>
  );
}
```

```css
body {
  margin: 0;
  padding: 0;
  height: 250px;
}
```

</Sandpack>

O√π est le probl√®me?

---

## R√©ponse

Le probl√®me se situe ici:

<TwoColumns top>

```js
onPointerMove={e => {
  position.x = e.clientX;  // üö´
  position.y = e.clientY;  // üö´
}}
```

- Ce code mute l'objet assign√© √† `position` du rendu pr√©c√©dent
- Mais on n'utilise pas la fonction `setState`
- React n'a pas moyen de savoir que l'objet est modifi√©

</TwoColumns>

<hr />

<TwoColumns top>

<div style={{textAlign:"right"}}>

Pour d√©clencher un re-rendu, il faut cr√©er un nouvel objet, dans lequel on initialise les propri√©t√©s:

</div>

```js
onPointerMove={e => {
  setPosition({
    x: e.clientX,
    y: e.clientY
  });
}}
```

</TwoColumns >

---

## Explications

Avec `setPosition`, on dit √† React de:

- Remplacer `position` avec ce nouvel objet
- Faire un re-rendu du composant

<Sandpack s="70">

```js
import { useState } from 'react';
export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0,
  });
  return (
    <div
      onPointerMove={(e) => {
        setPosition({
          x: e.clientX,
          y: e.clientY,
        });
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}
    >
      <div
        style={{
          position: 'absolute',
          backgroundColor: 'red',
          borderRadius: '50%',
          transform: `translate(${position.x}px, ${position.y}px)`,
          left: -10,
          top: -10,
          width: 20,
          height: 20,
        }}
      />
    </div>
  );
}
```

```css
body {
  margin: 0;
  padding: 0;
  height: 250px;
}
```

</Sandpack>

---

## La mutation locale est permise

<TwoColumns top style={{gap:'2em'}}>

<div>
Ce code est **parfaitement correct** car on mute un nouvel object qui vient tout juste d'√™tre cr√©√©.

```js
const nextPosition = {};
nextPosition.x = e.clientX;
nextPosition.y = e.clientY;
setPosition(nextPosition);
```

Aussi √©quivalent √† ceci:

```js
setPosition({
  x: e.clientX,
  y: e.clientY,
});
```

Mais le code suivant est probl√©matique car il modifie un objet d'√©tat _existant_:

```js
position.x = e.clientX; //üö´
position.y = e.clientY; //üö´
```

</div>

<Alert type="info">

- La mutation est un probl√®me seulement quand on modifie des objets _existants_ dans l'√©tat.
- Muter un objet qui vient tout juste d'√™tre cr√©√© est correct, car _aucun autre code n'y fait encore r√©f√©rence._
- Muter un nouvel objet n'a pas d'impact. C'est ce qu'on appelle une "mutation locale". (On peut m√™me faire des mutations locales durant un rendu.)

</Alert>

</TwoColumns>

---

## Modifier partiellement un objet

- Que faire si on d√©sire inclure les donn√©es existantes dans le nouvel objet?
- Exemple: modifier un seul champ d'un formulaire, tout en gardant les autres donn√©es existantes?
- Les champs de saisie ci-bas ne fonctionnent pas (les `onChange` ne modifient pas l'√©tat)

<Sandpack s="70">

```js
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'John',
    lastName: 'Smith',
    email: 'jsmith@test.com',
  });

  function handleFirstNameChange(e) {
    person.firstName = e.target.value;
  }

  function handleLastNameChange(e) {
    person.lastName = e.target.value;
  }

  function handleEmailChange(e) {
    person.email = e.target.value;
  }

  return (
    <>
      <label>
        First name:
        <input value={person.firstName} onChange={handleFirstNameChange} />
      </label>
      <label>
        Last name:
        <input value={person.lastName} onChange={handleLastNameChange} />
      </label>
      <label>
        Email:
        <input value={person.email} onChange={handleEmailChange} />
      </label>
      <p>
        {person.firstName} {person.lastName} ({person.email})
      </p>
    </>
  );
}
```

```css
label {
  display: block;
}
input {
  margin-left: 5px;
  margin-bottom: 5px;
}
```

</Sandpack>

---

## Conserver les valeurs existantes

**Mauvais code:** muter l'objet `person` en modifiant le "firstName" du rendu pr√©c√©dent.

```js
person.firstName = e.target.value; // üö´
```

**Mieux:** Cr√©er un nouvel objet, **copier les donn√©es existantes**, et appeler `setPerson()`.

```js
setPerson({
  firstName: e.target.value, // Nouveau pr√©nom
  lastName: person.lastName, // Nom existant
  email: person.email, // courriel existant
});
```

---

## D√©composition (spread syntax)

On peut utiliser la syntaxe "`...object`" de la [d√©composition d'objet](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals) (Spread syntax) pour ne pas avoir besoin de recopier chaque propri√©t√© s√©par√©ment.

```js
setPerson({
  ...person, // copie les anciennes propri√©t√©s
  firstName: e.target.value, // Modifie firstName
});
```

<hr />

<Alert type='warning'>

- Notez que "`...`" est
  superficiel
- Ne copie qu'√† un seul niveau de profondeur
- Bonne performance
- Mais, avec des objets imbriqu√©s, il faudra utiliser cette
  syntaxe √† de multiples niveaux.

</Alert>

---

## Valider l'usage de la d√©composition (spread syntax)

- Maintenant, le formulaire fonctionne.
- Pas besoin de d√©clarer une variable d'√©tat pour chaque champ de saisie.
- Pour les gros formulaires, garder toutes les donn√©es group√©es dans un seul objet est tr√®s pratique. (En autant qu'il soit modifi√© correctement.)

<Sandpack s="70">

```js
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'John',
    lastName: 'Smith',
    email: 'jsmith@test.com',
  });

  function handleFirstNameChange(e) {
    setPerson({
      ...person,
      firstName: e.target.value,
    });
  }

  function handleLastNameChange(e) {
    setPerson({
      ...person,
      lastName: e.target.value,
    });
  }

  function handleEmailChange(e) {
    setPerson({
      ...person,
      email: e.target.value,
    });
  }

  return (
    <>
      <label>
        First name:
        <input value={person.firstName} onChange={handleFirstNameChange} />
      </label>
      <label>
        Last name:
        <input value={person.lastName} onChange={handleLastNameChange} />
      </label>
      <label>
        Email:
        <input value={person.email} onChange={handleEmailChange} />
      </label>
      <p>
        {person.firstName} {person.lastName} ({person.email})
      </p>
    </>
  );
}
```

```css
label {
  display: block;
}
input {
  margin-left: 5px;
  margin-bottom: 5px;
}
```

</Sandpack>

---

## Un seul gestionnaire d'√©v√©nements pour plusieurs champs

- Voici le m√™me exemple, avec un seul gestionnaire d'√©v√©nement plut√¥t que trois
- Les propri√©t√©s avec un **nom dynamique** utilisent les accolades carr√©es "`[` et `]`" plut√¥t que point "`.`"
- `e.target.name` r√©f√®re √† la propri√©t√© `name` dans l'√©l√©ment `<input>` du DOM

<Sandpack s="70">

```js
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'John',
    lastName: 'Smith',
    email: 'jsmith@test.com',
  });

  function handleChange(e) {
    setPerson({
      ...person,
      [e.target.name]: e.target.value,
    });
  }

  return (
    <>
      <label>
        First name:
        <input
          name='firstName'
          value={person.firstName}
          onChange={handleChange}
        />
      </label>
      <label>
        Last name:
        <input
          name='lastName'
          value={person.lastName}
          onChange={handleChange}
        />
      </label>
      <label>
        Email:
        <input //
          name='email'
          value={person.email}
          onChange={handleChange}
        />
      </label>
      <p>
        {person.firstName} {person.lastName} ({person.email})
      </p>
    </>
  );
}
```

```css
label {
  display: block;
}
input {
  margin-left: 5px;
  margin-bottom: 5px;
}
```

</Sandpack>

---

## Mettre √† jour un objet imbriqu√©

Consid√©rez l'objet imbriqu√© suivant:

```js
const [person, setPerson] = useState({
  name: 'Niki de Saint Phalle',
  artwork: {
    title: 'Blue Nana',
    city: 'Hamburg',
    image: 'https://i.imgur.com/Sd1AgUOm.jpg',
  },
});
```

<hr />

Pour modifier `person.artwork.city`, √ßa serait simple avec une mutation, mais incorrect:

```js
person.artwork.city = 'New Delhi'; // üö´
```

---

## Remplacer un objet imbriqu√© avec la d√©composition

On pr√©f√®re approcher l'√©tat de fa√ßon immuable:

<TwoColumns top style={{ gridTemplateColumns:"30fr 70fr"}}>

<div style={{ marginTop: 20 }}>

On cr√©√© un nouvel objet `artwork` (copiant les donn√©es de l'√©tat pr√©c√©dent),
ainsi qu'un nouvel objet `person` qui r√©f√®re au nouvel `artwork`.

</div>

```js
const nextArtwork = { ...person.artwork, city: 'New Delhi' };
const nextPerson = { ...person, artwork: nextArtwork };
setPerson(nextPerson);
```

<div style={{ marginTop: 30 }}>Alternativement, en une seule commande:</div>

```js
setPerson({
  ...person, // Copier les propri√©t√©s
  artwork: {
    // remplacer artwork
    ...person.artwork, // Copier les propri√©t√©s
    city: 'New Delhi', // mais √† New Delhi!
  },
});
```

</TwoColumns>

---

## Exemple de modification avec imbrication

La syntaxe de d√©composition d'objets imbriqu√©s n'est pas toujours facile √† √©crire, mais √ßa fonctionne tr√®s bien.

<Sandpack s="70">

```js
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: 'https://i.imgur.com/Sd1AgUOm.jpg',
    },
  });

  function handleNameChange(e) {
    setPerson({
      ...person,
      name: e.target.value,
    });
  }

  function handleTitleChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        title: e.target.value,
      },
    });
  }

  function handleCityChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        city: e.target.value,
      },
    });
  }

  function handleImageChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        image: e.target.value,
      },
    });
  }

  return (
    <>
      <label>
        Name:
        <input value={person.name} onChange={handleNameChange} />
      </label>
      <label>
        Title:
        <input value={person.artwork.title} onChange={handleTitleChange} />
      </label>
      <label>
        City:
        <input value={person.artwork.city} onChange={handleCityChange} />
      </label>
      <label>
        Image:
        <input value={person.artwork.image} onChange={handleImageChange} />
      </label>
      <p>
        <i>{person.artwork.title}</i>
        {' by '}
        {person.name}
        <br />
        (located in {person.artwork.city})
      </p>
      <img src={person.artwork.image} alt={person.artwork.title} />
    </>
  );
}
```

```css
label {
  display: block;
}
input {
  margin-left: 5px;
  margin-bottom: 5px;
}
img {
  width: 200px;
  height: 200px;
}
```

</Sandpack>

---

## Les objets sont-il imbriqu√©s?

<TwoColumns top style={{ gridTemplateColumns:"40fr 60fr"}}>

<div style={{marginTop:'1em'}}>

Les objets suivants semblent "imbriqu√©s" dans le code:

</div>

```js
let obj = {
  name: 'Niki de Saint Phalle',
  artwork: {
    title: 'Blue Nana',
    city: 'Hamburg',
    image: 'https://i.imgur.com/Sd1AgUOm.jpg',
  },
};
```

<div style={{ marginTop: '1em' }}>

- Mais c'est trompeur
- √Ä l'ex√©cution, la notion d'imbrication
  n'existe pas
- En fait, ce sont deux objets distincts

</div>

```js
let obj1 = {
  title: 'Blue Nana',
  city: 'Hamburg',
  image: 'https://i.imgur.com/Sd1AgUOm.jpg',
};

let obj2 = {
  name: 'Niki de Saint Phalle',
  artwork: obj1,
};
```

</TwoColumns>

---

## Les objet ne sont pas vraiment imbriqu√©s

L'objet `obj1` n'est pas vraiment stock√© dans `obj2`. La preuve, `obj3` pourrait r√©f√©rer √† `obj1` aussi:

<TwoColumns top>

```js
let obj1 = {
  title: 'Blue Nana',
  city: 'Hamburg',
  image: 'https://i.imgur.com/Sd1AgUOm.jpg',
};

let obj2 = {
  name: 'Niki de Saint Phalle',
  artwork: obj1,
};

let obj3 = {
  name: 'Copycat',
  artwork: obj1,
};
```

<div style={{marginTop:20}}>

- `obj3.artwork`, `obj2.artwork`, ainsi qu'`obj1` r√©f√®rent tous au m√™me objet

- Modifier `obj3.artwork.city` affecte `obj2.artwork.city` ainsi que `obj1.city`

- Ces sont des objets s√©par√©s, qui r√©f√®rent ou pointent les uns les autres

</div>
</TwoColumns>

---

## R√©aliser des modifications complexes avec immer

- Quand l'√©tat est complexe, avec plusieurs objets "imbriqu√©s", on pourrait simplifier
- On pourrait rendre l'√©tat plat (sans imbrication)
  <hr />
- Si on pr√©f√®re conserver la structure complexe, il existe des outils pour aider
- Le plus populaire se nomme [Immer](https://github.com/immerjs/use-immer)
- Permet d'utiliser des changements mutatifs, mais produit un r√©sultat en copie d'objet.
- Ex: dans le code mutatif suivant, il n'y a pas de mutation, et Immer g√©n√®re un nouvel objet

```js
updatePerson((draft) => {
  draft.artwork.city = 'Lagos';
});
```

Contrairement aux mutations r√©guli√®res, **immer** n'√©crase pas les √©tats pr√©c√©dents.

---

## Comment fonctionne Immer?

Pour utiliser Immer

1. `npm install use-immer` pour ajouter Immer en tant que d√©pendance.
2. Remplacez :

`import { useState } from 'react'`

avec

`import { useImmer } from 'use-immer'`

<Alert type="warning">
- Le `draft` (brouillon) fourni par Immer est un objet sp√©cial, nomm√© [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 
- Ce proxy enregistre toutes les mutations qui affectent l'objet
- C'est pour cela qu'il est possible de muter l'objet autant qu'on le d√©sire
- Dans les coulisses, Immer d√©termine les modifications √† `draft`
- Immer produit ensuite un nouvel objet avec toutes les modifications

</Alert>

---

## Exemple qui utilise Immer

<Sandpack  s="70">

```js
import { useImmer } from 'use-immer';

export default function Form() {
  const [person, updatePerson] = useImmer({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: 'https://i.imgur.com/Sd1AgUOm.jpg',
    },
  });

  function handleNameChange(e) {
    updatePerson((draft) => {
      draft.name = e.target.value;
    });
  }

  function handleTitleChange(e) {
    updatePerson((draft) => {
      draft.artwork.title = e.target.value;
    });
  }

  function handleCityChange(e) {
    updatePerson((draft) => {
      draft.artwork.city = e.target.value;
    });
  }

  function handleImageChange(e) {
    updatePerson((draft) => {
      draft.artwork.image = e.target.value;
    });
  }

  return (
    <>
      <label>
        Name:
        <input value={person.name} onChange={handleNameChange} />
      </label>
      <label>
        Title:
        <input value={person.artwork.title} onChange={handleTitleChange} />
      </label>
      <label>
        City:
        <input value={person.artwork.city} onChange={handleCityChange} />
      </label>
      <label>
        Image:
        <input value={person.artwork.image} onChange={handleImageChange} />
      </label>
      <p>
        <i>{person.artwork.title}</i>
        {' by '}
        {person.name}
        <br />
        (located in {person.artwork.city})
      </p>
      <img src={person.artwork.image} alt={person.artwork.title} />
    </>
  );
}
```

```json package.json
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

```css
label {
  display: block;
}
input {
  margin-left: 5px;
  margin-bottom: 5px;
}
img {
  width: 200px;
  height: 200px;
}
```

</Sandpack>

- Il est possible d'utiliser `useState` et `useImmer` dans le m√™me composant
- Immer garde le code simple et concis, surtout avec des objets imbriqu√©s
- Sans Immer, la copie d'objets imbriqu√©s g√©n√®re du code complexe

---

## Pourquoi √©viter la mutation d'√©tat en React (1/2)

Voici les raisons:

- **D√©bogage:** Si vous utilisez `console.log` et ne mutez pas le state, les objets affich√©s ne seront pas √©cras√©s par des mutations r√©centes. C'est alors plus simple et clair de suivre l'historique des changements.
- **Optimisations:** Plusieurs strat√©gies d'optimisation de React (ex: memo) sautent le rendu quand les props ou le state n'ont pas √©t√© modifi√©s. Quand on ne mute jamais l'√©tat, React valide les changements avec une simple comparaison `prevObj ===  obj`
- **Nouvelles fonctionnalit√©s:** L'√©quipe React pr√©pare de nouvelles fonctionnalit√©s qui se fient que l'√©tat n'est jamais mut√©. Le code qui utilise la mutation pourrait √©chouer dans une future version de React.

---

## Pourquoi √©viter la mutation d'√©tat en React (2/2)

- **Ajout de besoins:** Certaines fonctionnalit√©s (annuler/r√©tablir, undo/redo, afficher un historique de changements, r√©initialiser un formulaire aux valeurs pr√©c√©dentes) sont des actions simples √† r√©aliser quand rien n'est mut√©. Il suffit de garder des copies des √©tats pr√©c√©dents. C'est plus compliqu√© √† implanter quand il y a des mutations.
- **Simplicit√©:** Quand React utilise un √©tat immuable, il n'y a alors rien de sp√©cial √† coder. Pas besoin de proxy, ni de propri√©t√©s captur√©es, ni d'objets r√©actifs √† initialiser. React permet d'ajouter n'importe quel objet dans l'√©tat, sans aucun impact sur la performance.

<Alert type="warning">

Il est parfois possible de muter l'√©tat en React sans ressentir d'impact n√©gatif. Mais √† mesure que des nouvelles fonctionnalit√©s sont ajout√©es √† React, celles-ci s'attendent √† ce que les objets soient immuables. Donc, pour que votre code soit compatible avec les futures versions de React, assurez-vous d'√©crire du code avec un √©tat immuable.

</Alert>

---

## D√©fi 6

Si on clique le bouton pour ajouter du pointage, rien ne change... Modifiez ensuite le pr√©nom, et le pointage est corrig√©. Modifiez ensuite le nom, et tout disparait.

R√©parez le code.

<Sandpack s="70">

```js
import { useState } from 'react';

export default function Scoreboard() {
  const [player, setPlayer] = useState({
    firstName: 'John',
    lastName: 'Smith',
    score: 5,
  });

  function handlePlusClick() {
    player.score++;
  }

  function handleFirstNameChange(e) {
    setPlayer({
      ...player,
      firstName: e.target.value,
    });
  }

  function handleLastNameChange(e) {
    setPlayer({
      lastName: e.target.value,
    });
  }

  return (
    <>
      <label>
        Score: <b>{player.score}</b>{' '}
        <button onClick={handlePlusClick}>+1</button>
      </label>
      <label>
        First Name:
        <input value={player.firstName} onChange={handleFirstNameChange} />
      </label>
      <label>
        Last Name:
        <input value={player.lastName} onChange={handleLastNameChange} />
      </label>
    </>
  );
}
```

```css
label {
  display: block;
  margin-bottom: 10px;
}
input {
  margin-left: 5px;
  margin-bottom: 5px;
}
```

</Sandpack>

---

## D√©fi 7

Voci un bo√Æte que l'on peut d√©placer. On peut changer sa couleur avec le champ de saisie.

Mais il y a un bogue: Si vous d√©placez la bo√Æte d'abord, et ensuite changez sa couleur, le fond va sauter √† une nouvelle position. Ce n'est pas le comportement d√©sir√©.

Il y a des mutations ind√©sirables. R√©parez le bogue.

<Sandpack s="70">

```js src/App.js
import { useState } from 'react';
import Background from './Background.js';
import Box from './Box.js';

const initialPosition = {
  x: 0,
  y: 0,
};

export default function Canvas() {
  const [shape, setShape] = useState({
    color: 'orange',
    position: initialPosition,
  });

  function handleMove(dx, dy) {
    shape.position.x += dx;
    shape.position.y += dy;
  }

  function handleColorChange(e) {
    setShape({
      ...shape,
      color: e.target.value,
    });
  }

  return (
    <>
      <select value={shape.color} onChange={handleColorChange}>
        <option value='orange'>orange</option>
        <option value='lightpink'>lightpink</option>
        <option value='aliceblue'>aliceblue</option>
      </select>
      <Background position={initialPosition} />
      <Box color={shape.color} position={shape.position} onMove={handleMove}>
        Bougez moi!
      </Box>
    </>
  );
}
```

```js src/Box.js
import { useState } from 'react';

export default function Box({ children, color, position, onMove }) {
  const [lastCoordinates, setLastCoordinates] = useState(null);

  function handlePointerDown(e) {
    e.target.setPointerCapture(e.pointerId);
    setLastCoordinates({
      x: e.clientX,
      y: e.clientY,
    });
  }

  function handlePointerMove(e) {
    if (lastCoordinates) {
      setLastCoordinates({
        x: e.clientX,
        y: e.clientY,
      });
      const dx = e.clientX - lastCoordinates.x;
      const dy = e.clientY - lastCoordinates.y;
      onMove(dx, dy);
    }
  }

  function handlePointerUp(e) {
    setLastCoordinates(null);
  }

  return (
    <div
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      style={{
        width: 100,
        height: 100,
        cursor: 'grab',
        backgroundColor: color,
        position: 'absolute',
        border: '1px solid black',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        transform: `translate(
          ${position.x}px,
          ${position.y}px
        )`,
      }}
    >
      {children}
    </div>
  );
}
```

```js src/Background.js
export default function Background({ position }) {
  return (
    <div
      style={{
        position: 'absolute',
        transform: `translate(
        ${position.x}px,
        ${position.y}px
      )`,
        width: 250,
        height: 250,
        backgroundColor: 'rgba(200, 200, 0, 0.2)',
      }}
    />
  );
}
```

```css
body {
  height: 280px;
}
select {
  margin-bottom: 10px;
}
```

</Sandpack>

---

## D√©fi 8

Voici le m√™me exemple que dans le d√©fi pr√©c√©dent. Cette fois-ci, il faut r√©parer la mutation via Immer. Pour vous aider, `useImmer` est d√©j√† import√©. Il ne reste qu'√† changer la variable shape.

<Sandpack s="70">

```js src/App.js
import { useState } from 'react';
import { useImmer } from 'use-immer';
import Background from './Background.js';
import Box from './Box.js';

const initialPosition = {
  x: 0,
  y: 0,
};

export default function Canvas() {
  const [shape, setShape] = useState({
    color: 'orange',
    position: initialPosition,
  });

  function handleMove(dx, dy) {
    shape.position.x += dx;
    shape.position.y += dy;
  }

  function handleColorChange(e) {
    setShape({
      ...shape,
      color: e.target.value,
    });
  }

  return (
    <>
      <select value={shape.color} onChange={handleColorChange}>
        <option value='orange'>orange</option>
        <option value='lightpink'>lightpink</option>
        <option value='aliceblue'>aliceblue</option>
      </select>
      <Background position={initialPosition} />
      <Box color={shape.color} position={shape.position} onMove={handleMove}>
        Bougez moi!
      </Box>
    </>
  );
}
```

```js src/Box.js
import { useState } from 'react';

export default function Box({ children, color, position, onMove }) {
  const [lastCoordinates, setLastCoordinates] = useState(null);

  function handlePointerDown(e) {
    e.target.setPointerCapture(e.pointerId);
    setLastCoordinates({
      x: e.clientX,
      y: e.clientY,
    });
  }

  function handlePointerMove(e) {
    if (lastCoordinates) {
      setLastCoordinates({
        x: e.clientX,
        y: e.clientY,
      });
      const dx = e.clientX - lastCoordinates.x;
      const dy = e.clientY - lastCoordinates.y;
      onMove(dx, dy);
    }
  }

  function handlePointerUp(e) {
    setLastCoordinates(null);
  }

  return (
    <div
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      style={{
        width: 100,
        height: 100,
        cursor: 'grab',
        backgroundColor: color,
        position: 'absolute',
        border: '1px solid black',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        transform: `translate(
          ${position.x}px,
          ${position.y}px
        )`,
      }}
    >
      {children}
    </div>
  );
}
```

```js src/Background.js
export default function Background({ position }) {
  return (
    <div
      style={{
        position: 'absolute',
        transform: `translate(
        ${position.x}px,
        ${position.y}px
      )`,
        width: 250,
        height: 250,
        backgroundColor: 'rgba(200, 200, 0, 0.2)',
      }}
    />
  );
}
```

```css
body {
  height: 280px;
}
select {
  margin-bottom: 10px;
}
```

```json package.json
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

</Sandpack>

---

## Modifier les tableaux

- En JavaScript, il est permis de muter les tableaux, (comme les objets)
- En React, l'√©tat doit √™tre trait√© de fa√ßon immuable
- Quand on veut modifier un tableau, il faut en cr√©er un nouveau ou le cloner
- Consid√©rez les tableaux dans l'√©tat comme s'ils sont en lecture seule
- √âvitez la r√©assignation: `arr[0] = 'non'`
- √âvitez les m√©thodes qui mutent le tableau (ex: `push()` et `pop()`).

---

## Modifier les tableaux sans mutation

- Pour modifier le tableau dans l'√©tat, il faut passer un nouveau tableau au `setState`
- Voici une table de r√©f√©rence des op√©rations de tableau communes
- √âvitez les m√©thodes de la colonne de gauche. Pr√©f√©rez les m√©thodes de la colonne de droite.

<div className="my-tbl" >

| Action       | Tableau mut√© üö´                               | Nouveau tableau ‚úÖ                                    |
| ------------ | --------------------------------------------- | ----------------------------------------------------- |
| Ajout        | `push()`, <br /> `unshift()`                  | `concat()`, <br /> `[...arr]` (spread syntax)         |
| Suppression  | `pop()`, <br /> `shift()`, <br /> `splice()`  | `filter()`, <br /> `slice()`, <br /> `toSpliced()` üÜï |
| Remplacement | `splice()`, <br /> `arr[i] = x` (assignation) | `map()`, <br /> `.with()` üÜï                          |
| Tri          | `sort()`, <br /> `reverse()`,                 | `toSorted()` üÜï, <br /> `toReversed()` üÜï             |

</div>
<hr />
<Alert>
Alternativement, on peut utiliser Immer qui permet l'usage des mutations.
</Alert>

---

## Ajouter √† un tableau avec push üö´

`push()` mute un tableau en ajoutant un item. (√Ä √©viter) üö´

<Sandpack s="70">

```js
import { useState } from 'react';

let nextId = 0;

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState([]);

  return (
    <>
      <h1>Artists:</h1>
      <input value={name} onChange={(e) => setName(e.target.value)} />
      <button
        onClick={() => {
          setName('');
          artists.push({
            id: nextId++,
            name: name,
          });
        }}
      >
        Add
      </button>
      <ul>
        {artists.map((artist) => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}
```

```css
button {
  margin-left: 5px;
}
```

</Sandpack>

---

## Ajouter √† un tableau avec d√©composition

- On pr√©f√®re plut√¥t la cr√©ation d'un _nouveau_ tableau
- Qui contient les items existants et un nouvel item √† la fin
- Plusieurs approches possibles, mais le plus simple est d'utiliser la syntaxe de d√©composition: "`...`"

```js
setArtists(
  // Remplacer l'√©tat avec un nouveau tableau
  [
    ...artists, //                   contenant les anciens items
    { id: nextId++, name: name }, // et un item additionnel √† la fin.
  ]
);
```

- Si on doit ajouter au d√©but, on inverse l'ordre:

```js
setArtists([
  { id: nextId++, name: name }, // ici, on ins√®re item au d√©but du tableau
  ...artists, //                   on ajoute le contenu existant par la suite
]);
```

- Permet d'ajouter √† la fin (comme `push()`) ou au d√©but (comme `unshift()`).

---

## Exemple d'ajout au tableau avec d√©composition

<Sandpack s="70">

```js
import { useState } from 'react';

let nextId = 0;

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState([]);

  return (
    <>
      <h1>Artists:</h1>
      <input value={name} onChange={(e) => setName(e.target.value)} />
      <button
        onClick={() => {
          setName('');
          setArtists([...artists, { id: nextId++, name: name }]);
        }}
      >
        Add
      </button>
      <ul>
        {artists.map((artist) => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}
```

```css
button {
  margin-left: 5px;
}
```

</Sandpack>

---

## Enlever √† un Tableau

```js
setArtists(artists.filter((a) => a.id !== artist.id));
```

- `filter()` g√©n√®re un nouveau tableau d'`artists` avec des items en moins.

<Sandpack s="70">

```js
import { useState } from 'react';

let initialArtists = [
  { id: 0, name: 'Marta Colvin Andrade' },
  { id: 1, name: 'Lamidi Olonade Fakeye' },
  { id: 2, name: 'Louise Nevelson' },
];

export default function List() {
  const [artists, setArtists] = useState(initialArtists);

  return (
    <>
      <h1>Artists:</h1>
      <ul>
        {artists.map((artist) => (
          <li key={artist.id}>
            {artist.name}{' '}
            <button
              onClick={() => {
                setArtists(artists.filter((a) => a.id !== artist.id));
              }}
            >
              Remove
            </button>
          </li>
        ))}
      </ul>
    </>
  );
}
```

</Sandpack>

---

## Transformer un tableau avec `map`

- `map()` g√©n√®re un nouveau tableau
- La fonction pass√©e √† `map` d√©termine comment traiter chaque item, bas√© sur le contenu
- Dans cet exemple, un tableau d√©tient les coordonn√©es de deux cercles et un carr√©
- Quand on clique le bouton, on d√©place les cercles de 50 pixels vers le bas

<Sandpack s="70">

```js
import { useState } from 'react';

let initialShapes = [
  { id: 0, type: 'circle', x: 50, y: 100 },
  { id: 1, type: 'square', x: 150, y: 100 },
  { id: 2, type: 'circle', x: 250, y: 100 },
];

export default function ShapeEditor() {
  const [shapes, setShapes] = useState(initialShapes);

  function handleClick() {
    const nextShapes = shapes.map((shape) => {
      if (shape.type === 'square') {
        // Pas de changement
        return shape;
      } else {
        // Retourne un cercle 50 pixels plus bas
        return {
          ...shape,
          y: shape.y + 50,
        };
      }
    });
    // Provoque un re-rendu avec le nouveau tableau
    setShapes(nextShapes);
  }

  return (
    <>
      <button onClick={handleClick}>D√©placez les cercles!</button>
      {shapes.map((shape) => (
        <div
          key={shape.id}
          style={{
            background: 'purple',
            position: 'absolute',
            left: shape.x,
            top: shape.y,
            borderRadius: shape.type === 'circle' ? '50%' : '',
            width: 20,
            height: 20,
          }}
        />
      ))}
    </>
  );
}
```

```css
body {
  height: 300px;
}
```

</Sandpack>

---

## Remplacer les items d'un tableau

- On √©vite les asignations du genre `arr[0] = x` qui mutent l'objet
- On pr√©f√®re utiliser `map()` pour g√©n√©rer un nouveau tableau, bas√© sur le contenu et l'index

<Sandpack  s="70">

```js
import { useState } from 'react';

let initialCounters = [0, 0, 0];

export default function CounterList() {
  const [counters, setCounters] = useState(initialCounters);

  function handleIncrementClick(index) {
    const nextCounters = counters.map((c, i) => {
      if (i === index) {
        // Incr√©mente le compteur cliqu√©
        return c + 1;
      } else {
        // Le reste demeure la m√™me chose
        return c;
      }
    });
    setCounters(nextCounters);
  }

  return (
    <ul>
      {counters.map((counter, i) => (
        <li key={i}>
          {counter}
          <button
            onClick={() => {
              handleIncrementClick(i);
            }}
          >
            +1
          </button>
        </li>
      ))}
    </ul>
  );
}
```

```css
button {
  margin: 5px;
}
```

</Sandpack>

---

## Ins√©rer au milieu d'un tableau

- Pour ins√©rer un item, il faut cr√©er un tableau qui d√©compose la portion avant le point d'ins√©rtion, par la suite ajouter le nouvel item, et ensuite d√©composer le reste du tableau.
- Pour cela, on peut utiliser la m√©thode `slice(start, end)` avec la syntaxe de d√©composition de tableau "`...`". (Dans cet exemple, "Ins√©rer" ins√®re √† la position 1.)

<Sandpack  s="70">

```js
import { useState } from 'react';

let nextId = 3;
const initialArtists = [
  { id: 0, name: 'Marta Colvin Andrade' },
  { id: 1, name: 'Lamidi Olonade Fakeye' },
  { id: 2, name: 'Louise Nevelson' },
];

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState(initialArtists);

  function handleClick() {
    const insertAt = 1; // Pourrait √™tre n'importe quel index
    const nextArtists = [
      // Items avant le point d'insertion:
      ...artists.slice(0, insertAt),
      // Nouvel item
      { id: nextId++, name: name },
      // Items apr√®s le point d'insertion:
      ...artists.slice(insertAt),
    ];
    setArtists(nextArtists);
    setName('');
  }

  return (
    <>
      <h1>Artists:</h1>
      <input value={name} onChange={(e) => setName(e.target.value)} />
      <button onClick={handleClick}>Insert</button>
      <ul>
        {artists.map((artist) => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}
```

```css
button {
  margin-left: 5px;
}
```

</Sandpack>

---

## Faire des changements avanc√©s

- Les m√©thodes `reverse()` et `sort()` mutent le tableau orginal
- Que faire si nous sommes avant 2023?
- Faites une **copie** du tableau d'abord, et faites des changements **mutatifs** ensuite
- La syntaxe de d√©composition `[...list]` peut cr√©er un clone du tableau original

<Sandpack s="70">

```js
import { useState } from 'react';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies' },
  { id: 1, title: 'Lunar Landscape' },
  { id: 2, title: 'Terracotta Army' },
];

export default function List() {
  const [list, setList] = useState(initialList);

  function handleClick() {
    const nextList = [...list];
    nextList.reverse();
    setList(nextList);
  }

  return (
    <>
      <button onClick={handleClick}>Inverse</button>
      <ul>
        {list.map((artwork) => (
          <li key={artwork.id}>{artwork.title}</li>
        ))}
      </ul>
    </>
  );
}
```

</Sandpack>

---

## Tableau r√©f√©rant des objets

- Imaginons `nextList` qui clone `list`. Le code suivant est probl√©matique:

```js
const nextList = [...list];
nextList[0].seen = true; // Probl√®me: mutation  üö´
setList(nextList);
```

- `nextList` et `list` sont deux tableaux distincts
- **Mais** `nextList[0]` et `list[0]` pointent vers le m√™me objet
- En modifiant `nextList[0].seen`, on modifie aussi `list[0].seen`
- C'est donc une mutation d'√©tat. üö´

<hr />

- On r√©sout ce probl√®me de la m√™me fa√ßon qu'avec les objets JS imbriqu√©s
- On g√©n√®re un nouvel objet plut√¥t que de le muter

<div style={{fontSize:"2rem"}}>
```js
nextList[0] = {...nextList[0], seen: true }; ‚úÖ
```
</div>

---

## Modifier des objets dans des tableaux

- Lorsqu'on met √† jour des √©tats imbriqu√©s, il faut cr√©er des copies des objets √† modifier, **jusqu'au top niveau.**
- Dans cet exemple, deux listes d'oeuvres d'art partagent le m√™me √©tat initial
- √Ä cause d'une valeur mut√©e, leur √©tat est accidentellement partag√©

<Sandpack  s="70">

```js
import { useState } from 'react';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [myList, setMyList] = useState(initialList);
  const [yourList, setYourList] = useState(initialList);

  function handleToggleMyList(artworkId, nextSeen) {
    const myNextList = [...myList];
    const artwork = myNextList.find((a) => a.id === artworkId);
    artwork.seen = nextSeen;
    setMyList(myNextList);
  }

  function handleToggleYourList(artworkId, nextSeen) {
    const yourNextList = [...yourList];
    const artwork = yourNextList.find((a) => a.id === artworkId);
    artwork.seen = nextSeen;
    setYourList(yourNextList);
  }

  return (
    <>
      <h1>Oeuvres d'art (Artwork)</h1>
      <h2>Ma liste d'art:</h2>
      <ItemList artworks={myList} onToggle={handleToggleMyList} />
      <h2>Ta liste d'art:</h2>
      <ItemList artworks={yourList} onToggle={handleToggleYourList} />
    </>
  );
}

function ItemList({ artworks, onToggle }) {
  return (
    <ul>
      {artworks.map((artwork) => (
        <li key={artwork.id}>
          <label>
            <input
              type='checkbox'
              checked={artwork.seen}
              onChange={(e) => {
                onToggle(artwork.id, e.target.checked);
              }}
            />
            {artwork.title}
          </label>
        </li>
      ))}
    </ul>
  );
}
```

</Sandpack>

---

## D√©crire le probl√®me

Le probl√®me est ici:

```js
const myNextList = [...myList]; // On clone
const artwork = myNextList.find((a) => a.id === artworkId); // On trouve l'item
artwork.seen = nextSeen; // Probl√®me: on mute l'item  üö´
setMyList(myNextList);
```

- Le tableau `myNextList` est nouveau
- MAIS les _items_ sont les m√™mes que dans le tableau original `myList`
- Changer `artwork.seen` modifie donc l'objet _original_
- Cet objet se trouve aussi dans `yourArtworks`, causant le bogue
- Ce bogue est difficile √† trouver, mais il disparait d√®s qu'on arr√™te de muter.
- **Solution:** utiliser `map` pour substituer un vieil objet avec une nouvelle version, sans mutation:

```js
setMyList(myList.map(artwork => {
  if (artwork.id === artworkId) {
    // Cr√©er un nouvel objet, avec changements
    return { ...artwork, seen: nextSeen };
  } else {
    // Pas de changements, on conserve l'objet
    return artwork;
  }
});
```

---

## Dolution en d√©composant les items des tableaux

- Ici, "`...`" est la syntaxe de d√©composition pour cr√©er la copie d'un objet
- Il n'y a plus de mutations, le bogue est r√©gl√©.

<Sandpack  s="70">

```js
import { useState } from 'react';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [myList, setMyList] = useState(initialList);
  const [yourList, setYourList] = useState(initialList);

  function handleToggleMyList(artworkId, nextSeen) {
    setMyList(
      myList.map((artwork) => {
        if (artwork.id === artworkId) {
          // Cr√©√© un nouvel objet, avec changements
          return { ...artwork, seen: nextSeen };
        } else {
          // Pas de changements, on conserve l'objet
          return artwork;
        }
      })
    );
  }

  function handleToggleYourList(artworkId, nextSeen) {
    setYourList(
      yourList.map((artwork) => {
        if (artwork.id === artworkId) {
          // Cr√©√© un nouvel objet, avec changements
          return { ...artwork, seen: nextSeen };
        } else {
          // Pas de changements, on conserve l'objet
          return artwork;
        }
      })
    );
  }

  return (
    <>
      <h1>Liste des oeuvres d'art</h1>
      <h2>Ma liste:</h2>
      <ItemList artworks={myList} onToggle={handleToggleMyList} />
      <h2>Ta liste:</h2>
      <ItemList artworks={yourList} onToggle={handleToggleYourList} />
    </>
  );
}

function ItemList({ artworks, onToggle }) {
  return (
    <ul>
      {artworks.map((artwork) => (
        <li key={artwork.id}>
          <label>
            <input
              type='checkbox'
              checked={artwork.seen}
              onChange={(e) => {
                onToggle(artwork.id, e.target.checked);
              }}
            />
            {artwork.title}
          </label>
        </li>
      ))}
    </ul>
  );
}
```

</Sandpack>

- En g√©n√©ral, **il est permis de muter un objet qui vient tout juste d'√™tre cr√©√©.**
- Si on ins√®re une nouvelle oeuvre d'art, c'est donc correct de la muter
- Si on modifie un objet provenant de l'√©tat, il faut faire un clone avant de muter

---

## √âcrire une logique concise avec Immer

- En g√©n√©ral, on ne devrait pas modifier les donn√©es profond√©ment imbriqu√©es
- Modifier des tableaux imbriqu√©s, sans mutation, est r√©p√©titif et complexe
- Alternative 1: r√©√©crire la structure pour la rendre moins profonde (aplatir)
- Alternative 2: utiliser [Immer](https://github.com/immerjs/use-immer)
- On peut alors utiliser la mutation (car Immer g√©n√®re une copie de ces mutations)

<Sandpack  s="70">

```js src/App.js
import { useState } from 'react';
import { useImmer } from 'use-immer';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [myList, updateMyList] = useImmer(initialList);
  const [yourArtworks, updateYourList] = useImmer(initialList);

  function handleToggleMyList(id, nextSeen) {
    updateMyList((draft) => {
      const artwork = draft.find((a) => a.id === id);
      artwork.seen = nextSeen;
    });
  }

  function handleToggleYourList(artworkId, nextSeen) {
    updateYourList((draft) => {
      const artwork = draft.find((a) => a.id === artworkId);
      artwork.seen = nextSeen;
    });
  }

  return (
    <>
      <h1>Liste d'oeuvres d'art</h1>
      <h2>Ma liste:</h2>
      <ItemList artworks={myList} onToggle={handleToggleMyList} />
      <h2>Ta liste:</h2>
      <ItemList artworks={yourArtworks} onToggle={handleToggleYourList} />
    </>
  );
}

function ItemList({ artworks, onToggle }) {
  return (
    <ul>
      {artworks.map((artwork) => (
        <li key={artwork.id}>
          <label>
            <input
              type='checkbox'
              checked={artwork.seen}
              onChange={(e) => {
                onToggle(artwork.id, e.target.checked);
              }}
            />
            {artwork.title}
          </label>
        </li>
      ))}
    </ul>
  );
}
```

```json package.json
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

</Sandpack>

---

## Utiliser Immer

- Avec Immer, **les mutations comme `artwork.seen = nextSeen` sont permises:**

```js
updateMyTodos((draft) => {
  const artwork = draft.find((a) => a.id === artworkId);
  artwork.seen = nextSeen;
});
```

- C'est correct ici car on ne mute pas l'√©tat original
- On mute un objet sp√©cial `draft`, fourni par Immer
- On peut aussi utiliser `push()` ou `pop()` pour modifier `draft`.
- Dans les coulisses, Immer construit le prochain objet d'√©tat √† partir des mutations de `draft`
- Ceci permet d'avoir des gestionnaires d'√©v√©nemnts plus simples et courts.

---

## D√©fi 9

- √âcrivez la logique de `handleIncreaseClick`.
- Quand on clique "+", on incr√©mente le nombre

<Sandpack s="70">

```js
import { useState } from 'react';

const initialProducts = [
  {
    id: 0,
    name: 'Baklava',
    count: 1,
  },
  {
    id: 1,
    name: 'Sandwich',
    count: 5,
  },
  {
    id: 2,
    name: 'Spaghetti',
    count: 2,
  },
];

export default function ShoppingCart() {
  const [products, setProducts] = useState(initialProducts);

  function handleIncreaseClick(productId) {}

  return (
    <ul>
      {products.map((product) => (
        <li key={product.id}>
          {product.name} (<b>{product.count}</b>)
          <button
            onClick={() => {
              handleIncreaseClick(product.id);
            }}
          >
            +
          </button>
        </li>
      ))}
    </ul>
  );
}
```

```css
button {
  margin: 5px;
}
```

</Sandpack>

---

## D√©fi 10

- Le bouton "-" ne fait rien
- Il faut ajouter un gestionnaire d'√©v√©nements qui d√©cr√©mente le `count`du produit
- Quand on p√®se "-" et que le compte est 1, il faut enlever le produit du panier d'achat
- On ne doit pas afficher 0

<Sandpack  s="70">

```js
import { useState } from 'react';

const initialProducts = [
  {
    id: 0,
    name: 'Baklava',
    count: 1,
  },
  {
    id: 1,
    name: 'Sandwich',
    count: 5,
  },
  {
    id: 2,
    name: 'Spaghetti',
    count: 2,
  },
];

export default function ShoppingCart() {
  const [products, setProducts] = useState(initialProducts);

  function handleIncreaseClick(productId) {
    setProducts(
      products.map((product) => {
        if (product.id === productId) {
          return {
            ...product,
            count: product.count + 1,
          };
        } else {
          return product;
        }
      })
    );
  }

  return (
    <ul>
      {products.map((product) => (
        <li key={product.id}>
          {product.name} (<b>{product.count}</b>)
          <button
            onClick={() => {
              handleIncreaseClick(product.id);
            }}
          >
            +
          </button>
          <button>‚Äì</button>
        </li>
      ))}
    </ul>
  );
}
```

```css
button {
  margin: 5px;
}
```

</Sandpack>

---

## D√©fi 11

- Tous les gestionnaires d'√©v√©nements de `App.js` utilisent la mutation
- L'√©dition et la supression des todos ne fonctionnent pas
- Il faut r√©√©crire les 3 handlers pour ne plus muter.

<Sandpack  s="70">

```js src/App.js
import { useState } from 'react';
import AddTodo from './AddTodo.js';
import TaskList from './TaskList.js';

let nextId = 3;
const initialTodos = [
  { id: 0, title: 'Acheter lait', done: true },
  { id: 1, title: 'Manger collation', done: false },
  { id: 2, title: 'Pr√©parer du th√©', done: false },
];

export default function TaskApp() {
  const [todos, setTodos] = useState(initialTodos);

  function handleAddTodo(title) {
    todos.push({
      id: nextId++,
      title: title,
      done: false,
    });
  }

  function handleChangeTodo(nextTodo) {
    const todo = todos.find((t) => t.id === nextTodo.id);
    todo.title = nextTodo.title;
    todo.done = nextTodo.done;
  }

  function handleDeleteTodo(todoId) {
    const index = todos.findIndex((t) => t.id === todoId);
    todos.splice(index, 1);
  }

  return (
    <>
      <AddTodo onAddTodo={handleAddTodo} />
      <TaskList
        todos={todos}
        onChangeTodo={handleChangeTodo}
        onDeleteTodo={handleDeleteTodo}
      />
    </>
  );
}
```

```js src/AddTodo.js
import { useState } from 'react';

export default function AddTodo({ onAddTodo }) {
  const [title, setTitle] = useState('');
  return (
    <>
      <input
        placeholder='Ajouter Todo'
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />
      <button
        onClick={() => {
          setTitle('');
          onAddTodo(title);
        }}
      >
        Ajouter
      </button>
    </>
  );
}
```

```js src/TaskList.js
import { useState } from 'react';

export default function TaskList({ todos, onChangeTodo, onDeleteTodo }) {
  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>
          <Task todo={todo} onChange={onChangeTodo} onDelete={onDeleteTodo} />
        </li>
      ))}
    </ul>
  );
}

function Task({ todo, onChange, onDelete }) {
  const [isEditing, setIsEditing] = useState(false);
  let todoContent;
  if (isEditing) {
    todoContent = (
      <>
        <input
          value={todo.title}
          onChange={(e) => {
            onChange({
              ...todo,
              title: e.target.value,
            });
          }}
        />
        <button onClick={() => setIsEditing(false)}>Confirmer</button>
      </>
    );
  } else {
    todoContent = (
      <>
        {todo.title}
        <button onClick={() => setIsEditing(true)}>Modifier</button>
      </>
    );
  }
  return (
    <label>
      <input
        type='checkbox'
        checked={todo.done}
        onChange={(e) => {
          onChange({
            ...todo,
            done: e.target.checked,
          });
        }}
      />
      {todoContent}
      <button onClick={() => onDelete(todo.id)}>Suprimer</button>
    </label>
  );
}
```

```css
button {
  margin: 5px;
}
li {
  list-style-type: none;
}
ul,
li {
  margin: 0;
  padding: 0;
}
```

</Sandpack>

---

## D√©fi 12

- M√™me exemple que pr√©c√©demment, mais on r√©pare les mutations en utilisant Immer.
- `useImmer` est d√©j√† import√©.

<Sandpack  s="70">

```js src/App.js
import { useState } from 'react';
import { useImmer } from 'use-immer';
import AddTodo from './AddTodo.js';
import TaskList from './TaskList.js';

let nextId = 3;
const initialTodos = [
  { id: 0, title: 'Acheter lait', done: true },
  { id: 1, title: 'Manger collation', done: false },
  { id: 2, title: 'Pr√©parer du th√©', done: false },
];

export default function TaskApp() {
  const [todos, setTodos] = useState(initialTodos);

  function handleAddTodo(title) {
    todos.push({
      id: nextId++,
      title: title,
      done: false,
    });
  }

  function handleChangeTodo(nextTodo) {
    const todo = todos.find((t) => t.id === nextTodo.id);
    todo.title = nextTodo.title;
    todo.done = nextTodo.done;
  }

  function handleDeleteTodo(todoId) {
    const index = todos.findIndex((t) => t.id === todoId);
    todos.splice(index, 1);
  }

  return (
    <>
      <AddTodo onAddTodo={handleAddTodo} />
      <TaskList
        todos={todos}
        onChangeTodo={handleChangeTodo}
        onDeleteTodo={handleDeleteTodo}
      />
    </>
  );
}
```

```js src/AddTodo.js
import { useState } from 'react';

export default function AddTodo({ onAddTodo }) {
  const [title, setTitle] = useState('');
  return (
    <>
      <input
        placeholder='Ajouter Todo'
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />
      <button
        onClick={() => {
          setTitle('');
          onAddTodo(title);
        }}
      >
        Ajouter
      </button>
    </>
  );
}
```

```js src/TaskList.js
import { useState } from 'react';

export default function TaskList({ todos, onChangeTodo, onDeleteTodo }) {
  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>
          <Task todo={todo} onChange={onChangeTodo} onDelete={onDeleteTodo} />
        </li>
      ))}
    </ul>
  );
}

function Task({ todo, onChange, onDelete }) {
  const [isEditing, setIsEditing] = useState(false);
  let todoContent;
  if (isEditing) {
    todoContent = (
      <>
        <input
          value={todo.title}
          onChange={(e) => {
            onChange({
              ...todo,
              title: e.target.value,
            });
          }}
        />
        <button onClick={() => setIsEditing(false)}>Confirmer</button>
      </>
    );
  } else {
    todoContent = (
      <>
        {todo.title}
        <button onClick={() => setIsEditing(true)}>Modifier</button>
      </>
    );
  }
  return (
    <label>
      <input
        type='checkbox'
        checked={todo.done}
        onChange={(e) => {
          onChange({
            ...todo,
            done: e.target.checked,
          });
        }}
      />
      {todoContent}
      <button onClick={() => onDelete(todo.id)}>Supprimer</button>
    </label>
  );
}
```

```css
button {
  margin: 5px;
}
li {
  list-style-type: none;
}
ul,
li {
  margin: 0;
  padding: 0;
}
```

```json package.json
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

</Sandpack>

---

## Devoir 4

G√©n√©rer des composants React qui devrait avoir ces caract√©ristiques:

Un composant parent nomm√© "Compteur" qui g√®re un √©tat nomm√© "compte". Ce composant aura aussi quelques gestionnaires d'√©tats.

Ce composant g√©n√®re des composants enfants.

- Un "Titre" qui affiche le contenu du compteur dans un `<h1>`.
- Des "Bouton" qui permetent d'incr√©menter le contenu du compteur. On affiche 3 de ces boutons:
  - Un "Bouton" qui permet d'incr√©menter le contenu par 1.
  - Un "Bouton" qui permet d'incr√©menter le contenu par 10.
  - Un "Bouton" qui permet d'incr√©menter le contenu par 100.

On veut le bouton affich√© 3 fois, avec des props correctement configur√©s.

---

## Devoir (extras)

**Extra 1:** Modifier le code du bouton permettre d'ajouter un bouton qui d√©cr√©mente le contenu de 10. (C'est-√†-dire qui incr√©mente de -10) G√©rer le formattage pour que ce bouton affiche d'une couleur diff√©rente quand on d√©cr√©mente, et qui utilie le vocabulaire "incr√©mente/d√©cr√©mente" correctement.

**Extra 2:** Ajouter un composant nomm√© "Boite", qui affiche un `<input>` avec le nombre. Il faudra g√©rer correctment le gestionnaire d'√©v√©nement `onChange` pour lire le contenu du input (e.target.value). Il faudra convertir ce contenu vers un nombre pour modifier correctement l'√©tat. (indice: utiliser parseInt ou (+) unaire.)

Bonne chance!

---
