---
title: '√âtat (State)'
date: '2023-02-22'
---

# √âtat (State)

---

import myFile from './4-state/datafile.js';

## Une variable ne suffit pas

<Sandpack  files={{
    "src/data.js": myFile
  }}  >

```js
import { sculptureList } from './data.js';

export default function Gallery() {
  let index = 0;

  function handleClick() {
    index = index + 1;
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <img src={sculpture.url} alt={sculpture.alt} />
      <p>{sculpture.description}</p>
    </>
  );
}
```

```js src/useForceRefresh.js hidden
import { useState } from 'react';

export default function useForceRefresh() {
  const [_, forceRefresh] = useState({});
  return function () {
    forceRefresh({});
  };
}
```

```css
h2 {
  margin-top: 10px;
  margin-bottom: 0;
}
h3 {
  margin-top: 5px;
  font-weight: normal;
  font-size: 100%;
}
img {
  width: 120px;
  height: 120px;
}
button {
  display: block;
  margin-top: 10px;
  margin-bottom: 10px;
}
```

</Sandpack>

`handleClick` modifie une variable locale, `index`. Mais il y a deux probl√®mes:

1. **Une variable locale ne persiste pas entre les rendus.** Chaque fois qu'on fait un nouveau rendu, toutes les variables locales sont recr√©√©es.
2. **Modifier une variable locale ne g√©n√®re pas de rendu .** React ne r√©alise pas qu'il faut g√©n√©rer un nouveau rendu.

---

## Solution fournie par React

Il faut:

1. **Conserver** les donn√©es entre les rendus
2. **D√©clencher** la g√©n√©ration d'un nouveau rendu (_re-rendering_)

Le Hook [`useState`](https://reactjs.org/reference/react/useState) fournit ces deux choses.

1. **Variable state (√âtat)** Garde les donn√©es entre les rendus.
2. **Fonction state setter (Fonction modification d'√©tat)** pour modifier la donn√©e et g√©n√©rer un rendu.

---

## Ajouter une variable State

```js
import { useState } from 'react';
...

const [data, setData] = useState(0);
```

`data` est une variable d'√©tat (pour lire), et `setData` est la fonction setter (pour modifier).

> La syntaxe `[` et `]` se nomme _d√©composition de tableau_ ([array destructuring](https://javascript.info/destructuring-assignment)) Cela permet de lire les valeurs provenant d'un tableau. Le tableau retourn√© par `useState` a toujours 2 items.

---

## Modifier le state

<TwoColumns top>

On modifie le state dans `handleClick`:

```js
function handleClick() {
  setIndex(index + 1);
}
```

</TwoColumns>
Voici le code r√©par√©:

<Sandpack    files={{
    "src/data.js": myFile
  }}  >

```js
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);

  function handleClick() {
    setIndex(index + 1);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <img src={sculpture.url} alt={sculpture.alt} />
      <p>{sculpture.description}</p>
    </>
  );
}
```

```css
h2 {
  margin-top: 10px;
  margin-bottom: 0;
}
h3 {
  margin-top: 5px;
  font-weight: normal;
  font-size: 100%;
}
img {
  width: 120px;
  height: 120px;
}
button {
  display: block;
  margin-top: 10px;
  margin-bottom: 10px;
}
```

</Sandpack>

---

## useState, le premier Hook

- `useState` n'est pas le seul _hook_. Toute fonction d√©marrant par "`use`" est un _hook_.
- Les _hooks_ sont des fonctions sp√©ciales, disponibles seulement pendant que React fait un [rendu](https://reactjs.org/learn/render-and-commit#step-1-trigger-a-render).
- Les _hooks_ permettent de se connecter ("hook into") dans les fonctionnalit√©s de React.
- L'√©tat (State) est une fonctionalit√©, mais on en verra d'autres.

---

## Caract√©ristiques des Hooks

<Alert type='warning'>
  **Attention:** les hooks (d√©butant par `use`) ne peuvent √™tre appel√©s qu'√†
  partir du "top niveau" de votre composant, ou de vos propres hooks.
</Alert>

On ne peut **PAS** appeler un hook dans:

- une condition
- une boucle
- une fonction imbriqu√©e (gestionnaire d'√©v√©nements).

M√™me si les hooks sont des fonctions, vaut mieux consid√©rer ceux-ci comme des d√©clarations des besoins de votre composant. On utilise les fonctionalit√©s React au "top niveau" d'un composant, de la m√™me fa√ßon qu'on importe les modules au d√©but des fichiers.

---

## Anatomie du `useState`

Quand on appelle [`useState`](https://beta.reactjs.org/reference/react/useState), React stocke la valeur.

```js
const [index, setIndex] = useState(0);
```

**Convention:**

- On nomme cette paire: `const [chose, setChose]`.
- On pourrait nommer diff√©remment, mais cette convention aide la compr√©hension.

L'argument de `useState` est la **valeur initiale** de l'√©tat. (Ici, la valeur 0).

√Ä chaque rendu, `useState` donne un tableau de 2 valeurs:

1. La **variable d'√©tat** (`index`) qui stocke la valeur.
2. La **fonction state setter** (`setIndex`) pour modifier la valeur de l'√©tat et d√©clencher un rendu.

---

## D√©tail du Hook:

```js
const [index, setIndex] = useState(0);
```

1. **Au premier rendu**, on passe `0` √† `useState`, le hook retourne `[0, setIndex]`. React stocke `0` dans l'√©tat.
2. **On met √† jour le state** quand l'usager clique, l'√©v√©nement appelle `setIndex(index + 1)`. Puisqu'`index` est `0`, cela appelle `setIndex(1)`. React stocke `1` et g√©n√®re un nouveau rendu.
3. **Au second rendu** React appelle `useState(0)`, mais React a d√©j√† stock√© `1` dans `index`. Donc React retourne `[1, setIndex]`.
4. Ainsi de suite...

---

## Composants avec des √©tats multiples

Un composant peut avoir de multiples variables d'√©tats.

L'exemple suivant poss√®de deux variables d'√©tat: un nombre `index` et un bool√©en `showMore` qui bascule quand on clique "Afficher D√©tails" .

<Sandpack    files={{
    "src/data.js": myFile
  }}  >

```js
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleNextClick}>Suivant</button>
      <h2>
        <i>{sculpture.name} </i>
        par {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} de {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Cacher' : 'Afficher'} d√©tails
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img src={sculpture.url} alt={sculpture.alt} />
    </>
  );
}
```

```css
h2 {
  margin-top: 10px;
  margin-bottom: 0;
}
h3 {
  margin-top: 5px;
  font-weight: normal;
  font-size: 100%;
}
img {
  width: 120px;
  height: 120px;
}
button {
  display: block;
  margin-top: 10px;
  margin-bottom: 10px;
}
```

</Sandpack>

On s√©pare le state quand les valeurs ne sont pas li√©es. (C'est le cas ci-haut).

Si les valeurs sont li√©es ou modifi√©es ensemble, on pr√©f√®re les combiner dans un objet unique. (Ex: un formulaire)

---

## Comment React sait quoi retourner?

Il n'y a pas d'identifiant pass√© en arguments √† `useState`. Comment sait-il quelle valeur retourner?

Les hooks se fient sur **un ordre d'appel, qui reste stable** dans un composant donn√©. C'est gr√¢ce √† la r√®gle des hooks: il faut les placer au "top niveau" d'un composant. (Il y a m√™me un [linter](https://www.npmjs.com/package/eslint-plugin-react-hooks) qui permet de d√©tecter les erreurs.)

React utilise un tableau de paires pour chaque composant. Il maintient un index sur l'usage des hooks et l'incr√©mente √† chaque appel de useState. Voir: [React Hooks: Not Magic, Just Arrays.](https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e)

L'exemple suivant n'utilise **PAS** React. Mais il d√©montre comment fonctionne les hooks.

<Sandpack    files={{
    "src/data.js": myFile
  }}  >

```js src/index.js active
import { sculptureList } from './data.js';

let componentHooks = [];
let currentHookIndex = 0;

// D√©montre le concept de useState (simplifi√©).
function useState(initialState) {
  let pair = componentHooks[currentHookIndex];
  if (pair) {
    // Apr√®s le premier rendu,
    // La paire d'√©tat existe d√©j√†
    // Il faut incr√©menter l'index et retourner la paire
    currentHookIndex++;
    return pair;
  }

  // Quand c'est un premier rendu,
  // On cr√©√© la paire d'√©tat et on la stocke.
  pair = [initialState, setState];

  function setState(nextState) {
    // Quand on modifie l'√©tat,
    // On met la nouvelle valeur dans la paire
    pair[0] = nextState;
    updateDOM();
  }

  // Stockons la paire pour les prochains rendus
  // Et on se pr√©pare pour le prochain appel Hook
  componentHooks[currentHookIndex] = pair;
  currentHookIndex++;
  return pair;
}

function Gallery() {
  // Chaque appel √† useState() obtient la paire suivante.
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  // On n'utilise pas React
  // On retourne un objet plut√¥t que du JSX.
  return {
    onNextClick: handleNextClick,
    onMoreClick: handleMoreClick,
    header: `${sculpture.name} by ${sculpture.artist}`,
    counter: `${index + 1} of ${sculptureList.length}`,
    more: `${showMore ? 'Hide' : 'Show'} details`,
    description: showMore ? sculpture.description : null,
    imageSrc: sculpture.url,
    imageAlt: sculpture.alt,
  };
}

function updateDOM() {
  // Reset the current Hook index
  // before rendering the component.
  currentHookIndex = 0;
  let output = Gallery();

  // Update the DOM to match the output.
  // This is the part React does for you.
  nextButton.onclick = output.onNextClick;
  header.textContent = output.header;
  moreButton.onclick = output.onMoreClick;
  moreButton.textContent = output.more;
  image.src = output.imageSrc;
  image.alt = output.imageAlt;
  if (output.description !== null) {
    description.textContent = output.description;
    description.style.display = '';
  } else {
    description.style.display = 'none';
  }
}

let nextButton = document.getElementById('nextButton');
let header = document.getElementById('header');
let moreButton = document.getElementById('moreButton');
let description = document.getElementById('description');
let image = document.getElementById('image');

// Make UI match the initial state.
updateDOM();
```

```html public/index.html
<button id="nextButton">Next</button>
<h3 id="header"></h3>
<button id="moreButton"></button>
<p id="description"></p>
<img id="image" />

<style>
  * {
    box-sizing: border-box;
  }
  body {
    font-family: sans-serif;
    margin: 20px;
    padding: 0;
  }
  button {
    display: block;
    margin-bottom: 10px;
  }
</style>
```

```css
button {
  display: block;
  margin-bottom: 10px;
}
```

</Sandpack>

---

## L'√©tat est isol√© et priv√©

L'√©tat est local √† l'instance du composant. **Si vous affichez deux fois le m√™me composant, chacun d'eux aura son propre √©tat isol√©.** Changer l'un n'affecte pas l'autre.

Dans l'exemple suivant, le composant `Gallery` est rendu deux fois. Les √©tats sont ind√©pendants.

<Sandpack    files={{
    "src/data.js": myFile
  }}  >

```js
import Gallery from './Gallery.js';

export default function Page() {
  return (
    <div className='Page'>
      <Gallery />
      <Gallery />
    </div>
  );
}
```

```js src/Gallery.js
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <section>
      <button onClick={handleNextClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Hide' : 'Show'} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img src={sculpture.url} alt={sculpture.alt} />
    </section>
  );
}
```

```css
button {
  display: block;
  margin-bottom: 10px;
}
.Page > * {
  float: left;
  width: 50%;
  padding: 10px;
}
h2 {
  margin-top: 10px;
  margin-bottom: 0;
}
h3 {
  margin-top: 5px;
  font-weight: normal;
  font-size: 100%;
}
img {
  width: 120px;
  height: 120px;
}
button {
  display: block;
  margin-top: 10px;
  margin-bottom: 10px;
}
```

</Sandpack>

---

## L'√©tat est isol√©

L'√©tat n'est li√© ni √† une fonction, ni √† un module. Il est li√© √† l'instance d'un composant qui affiche sur la page. Quand on affiche deux composants `Gallery`, React g√®re donc deux states.

Le composant `Page` ne connait rien de l'√©tat de `Gallery`. L'√©tat est compl√®tement priv√© au composant qui le d√©clare. Le parent ne peut le changer. On peut ajouter ou enlever de l'√©tat sans affecter le reste des composants.

Si on veut que les deux galleries partagent leurs √©tats? La bonne pratique en React, c'est d'enlever l'√©tat aux composants enfants pour le rajouter √† leur parent partag√©. (On couvre cela plus tard.)

---

## D√©fi 1

Quand on clique "Next" √† la derni√®re image, le code plante. R√©parons le code. 2 approches: On ajoute de la logique au gestionnaire d'√©v√©nments, ou on d√©sactive le bouton quand l'action n'est pas possible.

Apr√®s avoir r√©par√© le code, ajoutez un bouton "previous" pour revenir en arri√®re. Emp√™chez que √ßa plante √† la premi√®re image.

<Sandpack    files={{
    "src/data.js": myFile
  }}  >

```js
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleNextClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Hide' : 'Show'} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img src={sculpture.url} alt={sculpture.alt} />
    </>
  );
}
```

```css
button {
  display: block;
  margin-bottom: 10px;
}
.Page > * {
  float: left;
  width: 50%;
  padding: 10px;
}
h2 {
  margin-top: 10px;
  margin-bottom: 0;
}
h3 {
  margin-top: 5px;
  font-weight: normal;
  font-size: 100%;
}
img {
  width: 120px;
  height: 120px;
}
```

</Sandpack>

---

## D√©fi 2

Quand on tape dans les champs de saisie, rien n'apparait. Le valeurs sont "bloqu√©es" avec des strings vides. La valeur `value` du premier `<input>` est li√©e √† `firstName`. La valeur du second `<input>` est li√©e √† `lastName`. Les deux entr√©es ont le gestionnaire d'√©v√©nements `onChange`, qui modifie les variables d'apr√®s le champ de saisie (`e.target.value`). Par contre, les variables ne se rappellent pas de leur valeurs entre les rendus. Il faudrait reprogrammer en utilisant des variables d'√©tat.

<Sandpack>

```js
export default function Form() {
  let firstName = '';
  let lastName = '';

  function handleFirstNameChange(e) {
    firstName = e.target.value;
  }

  function handleLastNameChange(e) {
    lastName = e.target.value;
  }

  function handleReset() {
    firstName = '';
    lastName = '';
  }

  return (
    <form onSubmit={(e) => e.preventDefault()}>
      <input
        placeholder='First name'
        value={firstName}
        onChange={handleFirstNameChange}
      />
      <input
        placeholder='Last name'
        value={lastName}
        onChange={handleLastNameChange}
      />
      <h1>
        Hi, {firstName} {lastName}
      </h1>
      <button onClick={handleReset}>Reset</button>
    </form>
  );
}
```

```css
h1 {
  margin-top: 10px;
}
```

</Sandpack>

---

## D√©fi 3

Ce formulaire permet aux usagers de laisser du feedback. Quand on soumet du feedback, on devrait afficher "Merci". Mais cela plante avec le message d'erreur: "Rendered fewer hooks than expected". Il faut r√©parer l'erreur

**Indice:** D'o√π peut-on appeler un hook? Ce composant brise-t-il une r√®gle? Y a-t-il un commentaire qui d√©sactive les validations du linter?

<Sandpack>

```js
import { useState } from 'react';

export default function FeedbackForm() {
  const [isSent, setIsSent] = useState(false);
  if (isSent) {
    return <h1>Thank you!</h1>;
  } else {
    // eslint-disable-next-line
    const [message, setMessage] = useState('');
    return (
      <form
        onSubmit={(e) => {
          e.preventDefault();
          alert(`Sending: "${message}"`);
          setIsSent(true);
        }}
      >
        <textarea
          placeholder='Message'
          value={message}
          onChange={(e) => setMessage(e.target.value)}
        />
        <br />
        <button type='submit'>Send</button>
      </form>
    );
  }
}
```

</Sandpack>

---

## Rendu et commit

React g√®re un cycle pour afficher des donn√©es. Voici ce cycle:

1. **Lancer un d√©clencheur** qui provoque un rendu
2. **G√©n√®rer le rendu** du composant
3. **√âcrire le commit** vers le DOM

---

## √âtape 1: Lancer un d√©clencheur

Il y a deux raisons pour qu'un composant soit rendu.

1. C'est le **rendu initial** du composant
2. **L'√©tat est modifi√©** sur le composant (ou l'un des parents).

---

## Rendu initial

Quand l'application d√©marre, il faut d√©clencher le rendu initial. Certaines bo√Ætes √† outils cachent ce code. Quand ce code n'est pas cach√©, on appelle `createRoot` sur l'√©l√©ment du DOM, et on appelle la m√©thode `render`.

<Sandpack>

```js src/index.js active
import Image from './Image.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(<Image />);
```

```js src/Image.js
export default function Image() {
  return (
    <img
      src='https://i.imgur.com/ZF6s192.jpg'
      alt="'Floralis Gen√©rica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"
    />
  );
}
```

</Sandpack>

**NOTE:** Commentez `root.render()` et le composant disparait.

---

## Re-rendus d√©clench√©s par une modification de l'√©tat

- Apr√®s le rendu initial, on peut d√©clencher des rendus additionnels en modifiant l'√©tat avec `setState`.
- Modifier l'√©tat va placer un re-rendu dans la file.
- On peut ajouter plusieurs rendus additionnels dans la file.
- React regroupe les √©l√©ments de la file dans **un seul rendu** (Automatic batching of renders)

---

## √âtape 2: On g√©n√®re un Rendu du composant

- Apr√®s le d√©clenchement du rendu, React appelle vos composants pour d√©terminer l'affichage.

**"Faire un rendu", c'est React qui appelle vos composants.**

- **Au rendu initial** React appelle le composant racine.
- **Pour les rendus suivants** React appelle le composant ayant l'√©tat modifi√©.

C'est un processus r√©cursif. Si le composant retourne d'autres composants, ils seront aussi appel√©s, ainsi que leurs enfants, et ainsi de suite. Le processus continue jusqu'√† ce que tous les sous-composants soient rendus, et que React sache exactement quoi afficher.

---

## G√©n√©rer un rendu

<Sandpack>

```js src/Gallery.js active
export default function Gallery() {
  return (
    <section>
      <h1>Inspiring Sculptures</h1>
      <Image />
      <Image />
      <Image />
    </section>
  );
}

function Image() {
  return (
    <img
      src='https://i.imgur.com/ZF6s192.jpg'
      alt="'Floralis Gen√©rica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"
    />
  );
}
```

```js src/index.js
import Gallery from './Gallery.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(<Gallery />);
```

```css
img {
  margin: 0 10px 10px 0;
}
```

</Sandpack>

- **Pendant le rendu initial** React devra [cr√©er des noeuds (node) du DOM](https://developer.mozilla.org/docs/Web/API/Document/createElement) pour `<section>`, `<h1>`, et trois balises `<img>`.
- **Pendant le re-rendu,** React d√©terminera quelles propri√©t√©s ont chang√©, si c'est le cas. On compare avec le rendu pr√©c√©dent. (Cette information sera utile √† la prochaine √©tape.)

---

## Le Rendu est pur

<Alert type="warning">

Le rendu doit toujours √™tre une [fonction pure](https://react.dev/learn/keeping-components-pure):

</Alert>

- **'M√™mes entr√©es, m√™mes sorties'** Avec les m√™me entr√©es et param√®tres, le composant retourne le m√™me JSX
- **On ne touche √† rien √† l'ext√©rieur du composant** On ne doit modifier ni objets, ni variables existantes.

  - Si on oublie ces pricipes, on pourrait rencontrer des bogues difficiles √† d√©tecter.
  - Quand on d√©veloppe en **Strict Mode**, React appelle chaque fonction 2 fois au rendu initial.
  - Ceci aide √† d√©tecter les fonctions impures.

---

## Optimiser la performance

- Par d√©faut, un changement de state provoque un re-rendu du composant
- Ainsi que **tous ses sous-composants** (et ainsi de suite). √áa peut √™tre lourd.
- Il existe des strat√©gies pour optimiser la performance. Ex: `createMemo()`.

---

## √âtape 3: React √©crit le commit vers le DOM

Apr√®s le rendu (l'appel) des composants, React fait un commit en modifiant le DOM.

- **Pour le rendu initial** React appelle [`appendChild()`](https://developer.mozilla.org/docs/Web/API/Node/appendChild) pour ajouter les noeuds DOM.
- **Pour les rendus suivants** React applique les modifications minimales (compar√©es pendant le rendu) pour que le DOM corresponde au dernier rendu g√©n√©r√©.

---

## React ne modifie le DOM que pour les √©l√©ments modifi√©s

Par exemple, dans l'exemple suivant, le composant g√©n√®re un re-rendu avec de nouvelles props √† chaque seconde. On peut ajouter du texte au `<input>`, modifier la `value` du `<input>`, et le texte ne disparait pas au moment du re-rendu:

<Sandpack>

```js src/Clock.js active
export default function Clock({ time }) {
  return (
    <>
      <h1>{time}</h1>
      <input />
    </>
  );
}
```

```js src/App.js hidden
import { useState, useEffect } from 'react';
import Clock from './Clock.js';

function useTime() {
  const [time, setTime] = useState(() => new Date());
  useEffect(() => {
    const id = setInterval(() => {
      setTime(new Date());
    }, 1000);
    return () => clearInterval(id);
  }, []);
  return time;
}

export default function App() {
  const time = useTime();
  return <Clock time={time.toLocaleTimeString()} />;
}
```

</Sandpack>

Durant la derni√®re √©tape, React ne modifie que le contenu `<h1>` avec la nouvelle heure. `<input>` apparait √† chaque nouveau re-rendu, mais sans modification. Donc React ne touche pas √† `<input>`.

---

## L'apr√®s-ex√©cution: Browser paint

Rappel des diff√©rentes √©tapes:

1. **Lancer un d√©clencheur** qui provoque un rendu
2. **G√©n√®rer le rendu** du composant
3. **√âcrire le commit** en modifiant le DOM

- Apr√®s le commit, les modifications sont affich√©es.
  - Le navigateur appelle cela "_browser rendering_"
  - La documentation React appelle cela "**browser painting**"

---

## En r√©sum√©

- Voici les trois √©tapes d'affichage sur React
  1. D√©clencheur (Trigger)
  2. Rendu (Render)
  3. √âcriture du DOM (Commit)
- `<StrictMode>` permet de trouver les composants impurs
- React ne touche pas au DOM quand le rendu est le m√™me que la fois pr√©c√©dente

---

## Modifier l'√©tat d√©clenche un rendu

Dans plusieurs environnements, on consid√®re que la modification d'une interface usager est le r√©sultat d'un √©v√©nement, tel que le clic d'un bouton.

Dans React, c'est diff√©rent.

Il faut **modifier l'√©tat** pour que l'interface usager soit affect√©e.

---

## Exemple

Dans l'exemple suivant, quand on presse "send", le `setIsSent(true)` modifie l'√©tat et g√©n√®re un re-rendu.

<Sandpack>

```js
import { useState } from 'react';

export default function Form() {
  const [isSent, setIsSent] = useState(false);
  const [message, setMessage] = useState('Bonjour!');
  if (isSent) {
    return <h1>Votre message est envoy√©</h1>;
  }
  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        setIsSent(true);
        sendMessage(message);
      }}
    >
      <textarea
        placeholder='Message'
        value={message}
        onChange={(e) => setMessage(e.target.value)}
      />
      <button type='submit'>Envoyer</button>
    </form>
  );
}

function sendMessage(message) {
  // ...
}
```

```css
label,
textarea {
  margin-bottom: 10px;
  display: block;
}
```

</Sandpack>

Quand on clique le bouton

1. Le gestionnaire d'√©v√©nements `onSubmit` ex√©cute.
2. `setIsSent(true)` modifie `isSent` √† `true` place le rendu dans la file.
3. React g√©n√®re le re-rendu en utilisant la nouvelle valeur de `isSent`.

---

## Rendu g√©n√®re un Snapshot dans le temps

G√©n√©rer un "rendu" signifie que React appelle votre Composant (i.e. la fonction de votre composant).

Le JSX retourn√© est comme une photo instantan√©e (un snapshot) de l'interface usager, √† ce moment pr√©cis dans le temps.

Les props, gestionnnaires d'√©v√©nements et variables locales ont √©t√© g√©n√©r√©es **√† partir de l'√©tat au moment du rendu.**

Ce snapshot du UI inclut de la logique comme des gesionnaires d'√©v√©nements qui sp√©cifient ce qui ce passe quand un usager interagit. React modifie l'√©cran pour synchroniser ce qui est affich√© et ce qui a √©t√© g√©n√©r√© (incluant la connection √† des event handlers.)

<Alert >
Quand React fait un re-rendu d'un composant:

1. React appelle votre fonction.
2. Cette fonction retourne un snapshot JSX.
3. React modifie l'√©cran pour synchroniser avec le snapshot.

</Alert>

---

## L'√©tat est g√©r√© par React

Contrairement aux variables locales qui disparaissent quand la fonction est compl√©t√©e (quand le JSX est retourn√©), l'√©tat est conserv√© entre les appels.

L'√©tat est conserv√© par React, √† l'ext√©rieur de la fonction. Quand React appelle votre composant, il vous donne acc√®s au snapshot de l'√©tat pour ce rendu particulier. Votre composant retourne un snapshot du UI avec de nouveaux props et gestionnaires d'√©v√©nements, g√©n√©r√©es √† partir des valeurs d'√©tats de ce rendu.

---

## L'√©tat nest pas g√©r√© comme le reste

Dans cet exemple, on pourrait s'attendre √† ce que cliquer le bouton +3 incr√©mente de le compteur 3 fois car il appelle `setNumber(number + 1)` trois fois.

Mais ce n'est pas le cas.

<Sandpack>

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

On n'incr√©mente qu'une seule fois.

---

## Modifier le state n'affecte que le prochain rendu

Pendant le premier rendu, `number` √©tait `0`. C'est pourquoi, le gestionnaire d'√©v√©nement `onClick` consid√®re que la valeur de `number` demeure `0` m√™me apr√®s l'appel √† `setNumber(number + 1)`:

<TwoColumns style={{gridTemplateColumns:'15em auto'}}>

```js
<button
  onClick={() => {
    setNumber(number + 1);
    setNumber(number + 1);
    setNumber(number + 1);
  }}
>
  +3
</button>
```

<div>
Voici ce qui est ex√©cut√©:

1. `setNumber(number + 1)`: `number` est `0` donc `setNumber(0 + 1)`.
   - React ne modifiera `number` √† `1` qu'au prochain rendu.
2. `setNumber(number + 1)`: `number` est `0` donc `setNumber(0 + 1)`.
   - React ne modifiera `number` √† `1` qu'au prochain rendu.
3. `setNumber(number + 1)`: `number` est `0` donc `setNumber(0 + 1)`.
   - React ne modifiera `number` √† `1` qu'au prochain rendu.

</div>
</TwoColumns>

M√™me en appelant `setNumber(number + 1)` trois fois, dans le gestionnaire d'√©v√©nements de _ce rendu_, le `number` demeure `0`.
On modifie la valeur vers `1` trois fois. Le r√©sultat final affiche `1` plut√¥t que `3`.

---

## Autre explication

<TwoColumns>
<div>
Une autre fa√ßon de visualiser, c'est de substituer les √©tats avec leur valeur dans votre code.

```js
<button
  onClick={() => {
    setNumber(0 + 1);
    setNumber(0 + 1);
    setNumber(0 + 1);
  }}
>
  +3
</button>
```

</div>
<div>
Au prochain rendu, `number` sera `1`, Donc pour _ce rendu_ le gestionnaire d'√©v√©nements sera

```js
<button
  onClick={() => {
    setNumber(1 + 1);
    setNumber(1 + 1);
    setNumber(1 + 1);
  }}
>
  +3
</button>
```

</div>
</TwoColumns >

C'est pourquoi que la progression sera `1`, `2`, `3`, `4` et ainsi de suite.

---

## L'√©tat √† travers le temps

Quel sera le r√©sultat de cette alerte?

<Sandpack>

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          alert(number);
        }}
      >
        +5
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

Si vous substituez, vous pouvez deviner que ce sera z√©ro.

```js
setNumber(0 + 5);
alert(0);
```

---

## Question

Et si on met un minuteur sur cette alerte, pour qu'elle soit lanc√©e seulement apr√®s que le re-rendu soit compl√©t√©? Ce serait "0" ou "5"? (Devinez!)

<Sandpack>

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          setTimeout(() => {
            alert(number);
          }, 3000);
        }}
      >
        +5
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

Si vous utilisez la m√©thode de substitution, on voit clairement l'√©tat pass√© √† l'alerte.

<TwoColumns>

```js
setNumber(0 + 5);
setTimeout(() => {
  alert(0);
}, 3000);
```

L'√©tat stock√© dans React est chang√© au moment o√π l'alerte √©x√©cute, mais il a √©t√© planifi√© au moment o√π la valeur n'avait pas chang√©. C'est le moment du snapshot.

</TwoColumns>

---

## L'√©tat n'est jamais modifi√© pendant le rendu

La variable d'√©tat n'est pas modifi√©e durant le rendu, m√™me si le code est asynchrone (comme un minuteur ou un timer).

Dans le `onClick`, la valeur `number` continue d'√™tre `0` m√™me apr√®s que `setNumber(number + 5)` ne soit appel√©. Sa valeur s'est fix√©e quand React a "pris son snapshot" de l'IU.

Ceci permet au code d'√™tre moins fragile aux erreurs de synchonisation et de timing.

<hr />

Imaginons un fomulaire qui envoie un message avec un d√©lai de 5 secondes. Imaginez le sc√©nario:

1. On clique sur "Envoyer" pour dire "Bonjour" √† Alice
2. Avant la fin du d√©lai de 5 secondes, on change la valeur du "destinataire" pour "Bob"

Que devrait afficher `alert`? "Vous dites Bonjour √† Alice" ou "Vous dites Bonjour √† Bob"? (Consultez le code sur la prochaine diapositive.)

---

## L'√©tat est une machine √† voyager dans le temps

<Sandpack>

```js
import { useState } from 'react';

export default function Form() {
  const [to, setTo] = useState('Alice');
  const [message, setMessage] = useState('Bonjour');

  function handleSubmit(e) {
    e.preventDefault();
    setTimeout(() => {
      alert(`Vous dites ${message} √† ${to}`);
    }, 5000);
  }

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Destinataire:{' '}
        <select value={to} onChange={(e) => setTo(e.target.value)}>
          <option value='Alice'>Alice</option>
          <option value='Bob'>Bob</option>
        </select>
      </label>
      <textarea
        placeholder='Message'
        value={message}
        onChange={(e) => setMessage(e.target.value)}
      />
      <button type='submit'>Envoyer</button>
    </form>
  );
}
```

```css
label,
textarea {
  margin-bottom: 10px;
  display: block;
}
```

</Sandpack>

**React conserve les valeurs d'√©tats "fix√©es" dans les gestionnaires d'√©v√©nements de _ce rendu_.** Ne vous inqui√©tez pas d'un changement d'√©tat pendant l'ex√©cution de votre code.

Que faire si on doit lire le dernier √©tat avant un re-render? on pourrait utiliser une fonction de modification d'√©tat. On verra cela bient√¥t.

---

## D√©fi 4

Voici un feu de circulation pour pi√©tons.

Ajoutez une `alert` au gestionnaire du clic. Quand la lumi√®re est verte et dit ¬®Walk¬®, cliquer le bouton devrait afficher "Stop is next". Quand la lumi√®re est rouge et dit "Stop", cliquer le bouton devrait afficher "Walk is next".

Est-ce que √ßa fait une diff√©rence lorsqu'on met l'alerte avant ou apr√®s l'appel `setWalk`?

<Sandpack>

```js
import { useState } from 'react';

export default function TrafficLight() {
  const [walk, setWalk] = useState(true);

  function handleClick() {
    setWalk(!walk);
  }

  return (
    <>
      <button onClick={handleClick}>Change to {walk ? 'Stop' : 'Walk'}</button>
      <h1
        style={{
          color: walk ? 'darkgreen' : 'darkred',
        }}
      >
        {walk ? 'Walk' : 'Stop'}
      </h1>
    </>
  );
}
```

```css
h1 {
  margin-top: 20px;
}
```

</Sandpack>

---

## React regroupe les modification d'√©tats en lots (batch)

<Sandpack>

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

<TwoColumns>

```js
setNumber(0 + 1);
setNumber(0 + 1);
setNumber(0 + 1);
```

Chaque rendu est fix√© au moment qu'il est g√©n√©r√©, donc la valeur `number` demeure `0`, m√™me lorsqu'on appelle `setNumber(1)` plusieurs fois.

</TwoColumns>

Il y a aussi une autre raison. **React attend que tous les gestionnaires d'√©v√©nements aient fini de rouler avant de modifier l'√©tat.**
C'est pourquoi le re-rendu ne s'ex√©cute _qu'apr√®s_ tous les `setNumber()`;

---

## Optimisation: Regrouper les setState en lot (batch)

Similaire √† l'exp√©rience au resto: un serveur prend tous les d√©tails de la commande avant de partir √† la cuisine.

S'il n'√©tait pas tr√®s fut√©, il pourrait partir √† la cuisine d√®s que vous commandez de la soupe, et revenir... Et repartir d√®s que vous commandez un drink, et revenir... ainsi de suite... √ßa ne serait pas tr√®s efficace.

Cette approche permet de modifier plusieurs variables d'√©tats, provenant de plusieurs composants, dans un seul re-rendu. L'Interface Usager ne sera pas mis-√†-jour tant qu'on aura pas compl√©t√© le gestionnaire d'√©v√©nements. C'est ce qu'on appelle le regroupement par lot (batching). Cette optimisation am√©liore les performances. Cela √©vite les "rendus √† moiti√©", o√π seulement certaines variables ont √©t√© mises-√†-jour.

**React ne regroupe pas √† travers de _multiples_ √©v√©nements intentionnels (comme de multiples clics).** Chaque clic est g√©r√© s√©par√©ment. React ne regroupe que l√† o√π √ßa fait du sens. Cela nous assure que si le premier clic d√©sactive le fomulaire, le second clic ne soumettra pas le formulaire une seconde fois.

---

## Modifier l'√©tat de multiples fois dans un lot

C'est un cas rare, mais si on d√©sire modifier l'√©tat plusieurs fois...

On remplace la valeur `setNumber(number + 1)`, par une fonction `setNumber(n => n + 1)`. Ceci dit √† React "d'ex√©cuter le code plus tard".

La fonction prend un param√®tre (l'√©tat courant) et retourne l'√©tat suivant.

<Sandpack>

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber((n) => n + 1);
          setNumber((n) => n + 1);
          setNumber((n) => n + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

---

## Explications

Ici, `n => n + 1` est une **fonction d'updater.** Quand on passe cette fonction √† un setState():

1. React ajoute cette fonction √† la file pour √™tre trait√© apr√®s le gestionnaire d'√©v√©nements ait termin√©.
2. Durant le prochain rendu, React passe √† travers la file pour ex√©cuter et retourner l'√©tat modifi√©.

<TwoColumns>

```js
setNumber((n) => n + 1);
setNumber((n) => n + 1);
setNumber((n) => n + 1);
```

<div>
Voici comment React g√®re ces lignes de code dans le gestionnaire d'√©v√©nements

1. `setNumber(n => n + 1)`: `n => n + 1` est une fonction. React l'ajoute √† la file.
1. `setNumber(n => n + 1)`: `n => n + 1` est une fonction. React l'ajoute √† la file.
1. `setNumber(n => n + 1)`: `n => n + 1` est une fonction. React l'ajoute √† la file.

</div>
</TwoColumns >

---

## Explications

Quand on appelle `useState` au prochain rendu, React passe √† travers la file. L'√©tat pr√©c√©dent `number` est `0`, React passe cette valeur √† la premi√®re fonction updater (par le param√®tre `n`).

<div style={{display: 'flex',   flexDirection: 'column'}}  >

| file de fonctions | `n` | retourne    |
| ----------------- | --- | ----------- |
| `n => n + 1`      | `0` | `0 + 1 = 1` |
| `n => n + 1`      | `1` | `1 + 1 = 2` |
| `n => n + 1`      | `2` | `2 + 1 = 3` |

</div>

React stocke `3` comme r√©sultat final et le retourne via le `useState`.

C'est pour cela que l'exemple pr√©c√©dent fonctionne lorsqu'on clique "+3"

---

## Si on modifie le state apr√®s l'avoir remplac√©

Que penser de ce gestionnaire d'√©v√©nements.

```js
<button onClick={() => {
  setNumber(number + 5);
  setNumber(n => n + 1);
}}>
```

<Sandpack>

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          setNumber((n) => n + 1);
        }}
      >
        Increase the number
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

---

## Explications

1. `setNumber(number + 5)`: `number` est `0`, donc `setNumber(0 + 5)`. React ajoute _"replacer avec `5`"_ dans la file.
2. `setNumber(n => n + 1)`: `n => n + 1` est une fonction updater. React ajoute _cette fonction_ dans la file.

Pendant le prochain rendu, React passe par la file d'√©tat:

<div style={{display:'flex', flexDirection: 'column'}}>

| file               | `n`           | retourne    |
| ------------------ | ------------- | ----------- |
| "remplace par `5`" | `0` (inutile) | `5`         |
| `n => n + 1`       | `5`           | `5 + 1 = 6` |

</div>
<hr/>

React stocke `6` comme r√©sultat final et le retourne via le `useState`

Remarquez que `setState(x)` fonctionne comme `setState(n => x)`, mais `n` n'est pas utilis√©!

---

## Si on remplace l'√©tat apr√®s l'avoir modifi√©

Quelle sera la valeur ici?

```js
<button onClick={() => {
  setNumber(number + 5);
  setNumber(n => n + 1);
  setNumber(42);
}}>
```

<Sandpack>

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          setNumber((n) => n + 1);
          setNumber(42);
        }}
      >
        Increase the number
      </button>
    </>
  );
}
```

```css
button {
  display: inline-block;
  margin: 10px;
  font-size: 20px;
}
h1 {
  display: inline-block;
  margin: 10px;
  width: 30px;
  text-align: center;
}
```

</Sandpack>

---

## Explications

1. `setNumber(number + 5)`: `number` est `0`, donc `setNumber(0 + 5)`. React ajoute _"remplacer avec `5`"_ √† la file.
2. `setNumber(n => n + 1)`: `n => n + 1` est une fonction updater. React ajoute _cette fonction_ √† la file.
3. `setNumber(42)`: React ajoute _"remplacer avec `42`"_ √† la file.

Pendant le prochain rendu, React passe √† travers la file

<div style={{display:'flex', flexDirection: 'column'}}>

| file                  | `n`           | retourne    |
| --------------------- | ------------- | ----------- |
| "remplacer avec `5`"  | `0` (inutile) | `5`         |
| `n => n + 1`          | `5`           | `5 + 1 = 6` |
| "remplacer avec `42`" | `6` (inutile) | `42`        |

</div>
<hr/>

React stocke `42` comme r√©sultat final et le retourne via le `useState`

---

## Explications

Deux fa√ßons d'appeler `setNumber`:

1. **Avec une fonction updater n** (i.e. `n => n + 1`) qui se fait ajouter dans la file.
2. **Avec une valeur** (i.e. nombre `5`) ajoute "remplacer avec `5`" √† la file, en ignorant ce qui est d√©j√† pr√©sent.

- C'est apr√®s la s√©rie d'√©v√©nements, au d√©but du re-rendu, que React appelle la file des **updaters**.
- Les **updaters** doivent √™tre des fonctions pures
- Ne pas mettre d'effets de bord, ni de setState.
- En mode Strict, React ex√©cute chaque fonction **updater** deux fois (mais exclut le second r√©sultat)
  - √áa aide √† trouver les effets de bords ind√©sirables.

---

## Convention de noms

C'est commun de nommer l'argument de la fonction par les premi√®res lettres du state.

```js
setEnabled((e) => !e);
setLastName((ln) => ln.reverse());
setFriendCount((fc) => fc * 2);
```

Si on pr√©f√®re utiliser plus de lettres, une autre convention serait d'utiliser le nom de l'√©tat, avec ou sans pr√©fixe.

```js
setEnabled((enabled) => !enabled);
setEnabled((prevEnabled) => !prevEnabled);
```

---

## D√©fi 1

Vous travaillez sur une application de march√© d'euvres d'art o√π les usagers peuvent soumettre plusieurs commandes simultan√©ment √† une oeuvre. Chaque fois qu'un usager clique le boutton "Acheter", le compteur "achats en attente" doit augmenter de un. Apr√®s 3 secondes, le compteur "en attente" doit diminuer et le compteur "achats compl√©t√©s" doit augmenter.

Par contre, le compteur "en attente" ne fonctionne pas. Quand on clique "Acheter", il diminue √† "-1" (√ßa ne devrait pas √™tre possible). Et si on clique rapidement, le r√©sultat est bizarre.

R√©parez les compteurs.

<Sandpack>

```js
import { useState } from 'react';

export default function RequestTracker() {
  const [pending, setPending] = useState(0);
  const [completed, setCompleted] = useState(0);

  async function handleClick() {
    setPending(pending + 1);
    await delay(3000);
    setPending(pending - 1);
    setCompleted(completed + 1);
  }

  return (
    <>
      <h3>Achats en attente: {pending}</h3>
      <h3>Achats compl√©t√©s: {completed}</h3>
      <button onClick={handleClick}>Acheter</button>
    </>
  );
}

function delay(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
```

</Sandpack>

---

## React et les mutations d'objets

En React, on ne devrait jamais modifier un objet stock√© dans l'√©tat. Plut√¥t que de muter un objet, on devrait cr√©er de nouvelles copies qu'on modifie.

---

## Types immuables

N'importe quel type de valeur peut √™tre stock√© par l'√©tat.

```js
const [x, setX] = useState(0);
```

Types immuables (qu'on ne peut modifier):

- nombres
- chaines de caract√®res
- bool√©ens

On ne peut _modifier_ ces types. Mais on peut d√©clencher un re-rendu pour _remplacer_ une valeur.

```js
setX(5);
```

L'√©tat `x` est modifi√© de `0` √† `5`, (mais le _nombre `0`_ n'a pas mut√©.)

---

## Types muables

Mais consid√©rons un objet dans l'√©tat:

```js
const [position, setPosition] = useState({ x: 0, y: 0 });
```

Quand on change le contenu de l'objet, **c'est nomm√© une mutation:**

```js
position.x = 5;
```

- Les objets dans un √©tat React sont, techniquement, muables.
- **MAIS** On devrait toujours les traiter **comme si** ils √©taient immuables. (Tel un nombre, bool√©en ou cha√Æne de caract√®res)
- Plut√¥t que de les modifier, on pr√©f√®re les **remplacer**.

---

## Consid√©rer l'√©tat comme un objet "read-only"

On devrait toujours traiter les **objets JS plac√©s dans l'√©tat comme √©tant en lecture seulement.**

Cet objet d√©tient un objet dans l'√©tat pour repr√©senter la position d'un pointeur. Le point rouge devrait se d√©placer via l'√©tat quand on touche ou d√©place le curseur. Mais le point reste immobile:

<Sandpack>

```js
import { useState } from 'react';
export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0,
  });
  return (
    <div
      onPointerMove={(e) => {
        position.x = e.clientX;
        position.y = e.clientY;
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}
    >
      <div
        style={{
          position: 'absolute',
          backgroundColor: 'red',
          borderRadius: '50%',
          transform: `translate(${position.x}px, ${position.y}px)`,
          left: -10,
          top: -10,
          width: 20,
          height: 20,
        }}
      />
    </div>
  );
}
```

```css
body {
  margin: 0;
  padding: 0;
  height: 250px;
}
```

</Sandpack>

O√π est le probl√®me?

---

## R√©ponse

Le probl√®me se situe ici:

<TwoColumns top>

```js
onPointerMove={e => {
  position.x = e.clientX;  // üö´
  position.y = e.clientY;  // üö´
}}
```

Ce code mute l'objet assign√© √† `position` du rendu pr√©c√©dent. Mais sans utiliser la fonction `setState`, React n'a pas moyen de savoir que l'objet est modifi√©. Donc React ne r√©agit pas.

<div style={{textAlign:"right"}}>

Pour d√©clencher un re-rendu, **il faut cr√©er un nouvel objet dans lequel on place les informations** :

</div>

```js
onPointerMove={e => {
  setPosition({
    x: e.clientX,
    y: e.clientY
  });
}}
```

</TwoColumns >

---

## Explications

Avec `setPosition`, on dit √† React de:

- Remplacer `position` avec ce nouvel objet
- Faire un re-rendu du composant.

Maintenant, le point rouge suit notre curseur.

<Sandpack>

```js
import { useState } from 'react';
export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0,
  });
  return (
    <div
      onPointerMove={(e) => {
        setPosition({
          x: e.clientX,
          y: e.clientY,
        });
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}
    >
      <div
        style={{
          position: 'absolute',
          backgroundColor: 'red',
          borderRadius: '50%',
          transform: `translate(${position.x}px, ${position.y}px)`,
          left: -10,
          top: -10,
          width: 20,
          height: 20,
        }}
      />
    </div>
  );
}
```

```css
body {
  margin: 0;
  padding: 0;
  height: 250px;
}
```

</Sandpack>

---

## La mutation locale est permise

<TwoColumns top style={{gap:'2em'}}>

<div>
Ce code est **parfaitement correct** car on mute un nouvel object qui vient tout juste d'√™tre cr√©√©.

```js
const nextPosition = {};
nextPosition.x = e.clientX;
nextPosition.y = e.clientY;
setPosition(nextPosition);
```

Aussi √©quivalent √† ceci:

```js
setPosition({
  x: e.clientX,
  y: e.clientY,
});
```

Mais le code suivant est probl√©matique car il modifie un objet d'√©tat _existant_:

```js
position.x = e.clientX; //üö´
position.y = e.clientY; //üö´
```

</div>

<Alert type="info">

- La mutation est un probl√®me seulement quand on modifie des objets _existants_ dans l'√©tat.
- Muter un objet qui vient tout juste d'√™tre cr√©√© est correct, car _aucun autre code n'y fait encore r√©f√©rence._
- Muter un nouvel objet n'a pas d'impact. C'est ce qu'on appelle une "mutation locale". (On peut m√™me faire des mutations locales durant un rendu.)

</Alert>

</TwoColumns>

---

## Modifier partiellement un objet

Que faire si on d√©sire inclure les donn√©es existantes dans le nouvel objet?
Exemple: modifier un seul champ d'un formulaire, tout en gardant les autres donn√©es existantes?

Les champs de saisie ci-bas ne fonctionnent pas (les `onChange` ne modifient pas l'√©tat)

<Sandpack>

```js
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com',
  });

  function handleFirstNameChange(e) {
    person.firstName = e.target.value;
  }

  function handleLastNameChange(e) {
    person.lastName = e.target.value;
  }

  function handleEmailChange(e) {
    person.email = e.target.value;
  }

  return (
    <>
      <label>
        First name:
        <input value={person.firstName} onChange={handleFirstNameChange} />
      </label>
      <label>
        Last name:
        <input value={person.lastName} onChange={handleLastNameChange} />
      </label>
      <label>
        Email:
        <input value={person.email} onChange={handleEmailChange} />
      </label>
      <p>
        {person.firstName} {person.lastName} ({person.email})
      </p>
    </>
  );
}
```

```css
label {
  display: block;
}
input {
  margin-left: 5px;
  margin-bottom: 5px;
}
```

</Sandpack>

---

## Conserver les valeurs existantes

Par exemple, ceci modifie l'objet `person` en modifiant le "firstName" du rendu pr√©c√©dent.

```js
person.firstName = e.target.value; // üö´
```

La fa√ßon fiable de modifier l'√©tat est de cr√©er un nouvel objet et de le passer √† `setPerson`. En plus, il faut aussi **copier les donn√©es existantes**.

```js
setPerson({
  firstName: e.target.value, // Nouveau pr√©nom
  lastName: person.lastName,
  email: person.email,
});
```

---

## D√©composition (spread syntax)

On peut utiliser la syntaxe `...` de la [d√©composition d'objet](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals) pour ne pas avoir besoin de recopier chaque propri√©t√© s√©par√©ment.

```js
setPerson({
  ...person, // copie les anciennes propri√©t√©s
  firstName: e.target.value, // Modifie firstName
});
```

---

## Valider l'usage de la d√©composition (spread syntax)

Maintenant, le formulaire fonctionne.

Pas besoin de d√©clarer une variable d'√©tat pour chaque champ de saisie. Pour les gros formulaires, garder toutes les donn√©es group√©es dans un seul objet est tr√®s pratique. (En autant qu'il soit modifi√© correctement.)

<Sandpack>

```js
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com',
  });

  function handleFirstNameChange(e) {
    setPerson({
      ...person,
      firstName: e.target.value,
    });
  }

  function handleLastNameChange(e) {
    setPerson({
      ...person,
      lastName: e.target.value,
    });
  }

  function handleEmailChange(e) {
    setPerson({
      ...person,
      email: e.target.value,
    });
  }

  return (
    <>
      <label>
        First name:
        <input value={person.firstName} onChange={handleFirstNameChange} />
      </label>
      <label>
        Last name:
        <input value={person.lastName} onChange={handleLastNameChange} />
      </label>
      <label>
        Email:
        <input value={person.email} onChange={handleEmailChange} />
      </label>
      <p>
        {person.firstName} {person.lastName} ({person.email})
      </p>
    </>
  );
}
```

```css
label {
  display: block;
}
input {
  margin-left: 5px;
  margin-bottom: 5px;
}
```

</Sandpack>

Notez que `...` (la syntaxe de d√©composition, spread syntax) est "superficielle". Elle ne copie qu'√† un seul niveau de profondeur. √áa garde de bonnes performances, mais quand on a des objets imbriqu√©s, il faut utiliser cette syntaxe √† de multiples niveaux.

---

## Utiliser qu'un seul gestionnaire d'√©v√©nements pour plusieurs champs

<Alert type="warning">

Il est possible d'utiliser les accolades carr√©es `[` et `]` dans votre objet pour sp√©cifier une propri√©t√© avec un nom dynamique. Voici le m√™me exemple, avec un seul gestionnaire d'√©v√©nement plut√¥t que trois.

<Sandpack>

```js
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com',
  });

  function handleChange(e) {
    setPerson({
      ...person,
      [e.target.name]: e.target.value,
    });
  }

  return (
    <>
      <label>
        First name:
        <input
          name='firstName'
          value={person.firstName}
          onChange={handleChange}
        />
      </label>
      <label>
        Last name:
        <input
          name='lastName'
          value={person.lastName}
          onChange={handleChange}
        />
      </label>
      <label>
        Email:
        <input name='email' value={person.email} onChange={handleChange} />
      </label>
      <p>
        {person.firstName} {person.lastName} ({person.email})
      </p>
    </>
  );
}
```

```css
label {
  display: block;
}
input {
  margin-left: 5px;
  margin-bottom: 5px;
}
```

</Sandpack>

Ici, `e.target.name` r√©f√®re √† la propri√©t√© `name` dans l'√©l√©ment `<input>` du DOM.

</Alert>

---

## Mettre √† jour un objet imbriqu√©

Consid√©rez l'objet imbriqu√© suivant:

```js
const [person, setPerson] = useState({
  name: 'Niki de Saint Phalle',
  artwork: {
    title: 'Blue Nana',
    city: 'Hamburg',
    image: 'https://i.imgur.com/Sd1AgUOm.jpg',
  },
});
```

Pour modifier `person.artwork.city`, c'est tout simple avec une mutation.

```js
person.artwork.city = 'New Delhi';
```

---

## Remplacer un objet imbriqu√© avec la d√©composition

Mais en React, on doit approcher l'√©tat de fa√ßon immuable.

<TwoColumns top style={{ gridTemplateColumns:"1fr 3fr"}}>

<div style={{ marginTop: 20 }}>
  On cr√©√© un nouvel objet `artwork` (copiant les donn√©es de l'√©tat pr√©c√©dent)
  ainsi qu'un nouvel objet `person` qui r√©f√®re au nouvel `artwork`.
</div>

```js
const nextArtwork = { ...person.artwork, city: 'New Delhi' };
const nextPerson = { ...person, artwork: nextArtwork };
setPerson(nextPerson);
```

<div style={{marginTop:30}}>
Alternativement, en une seule commande:
</div >
```js
setPerson({
  ...person, // Copier les propri√©t√©s
  artwork: {
    // remplacer artwork
    ...person.artwork, // avec les m√™mes donn√©es
    city: 'New Delhi', // mais √† New Delhi!
  },
});
```

</TwoColumns>

---

## Exemple de modification avec imbrication

La syntaxe de d√©composition d'objets imbriqu√©s n'est pas toujours facile √† √©crire, mais √ßa fonctionne tr√®s bien.

<Sandpack>

```js
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: 'https://i.imgur.com/Sd1AgUOm.jpg',
    },
  });

  function handleNameChange(e) {
    setPerson({
      ...person,
      name: e.target.value,
    });
  }

  function handleTitleChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        title: e.target.value,
      },
    });
  }

  function handleCityChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        city: e.target.value,
      },
    });
  }

  function handleImageChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        image: e.target.value,
      },
    });
  }

  return (
    <>
      <label>
        Name:
        <input value={person.name} onChange={handleNameChange} />
      </label>
      <label>
        Title:
        <input value={person.artwork.title} onChange={handleTitleChange} />
      </label>
      <label>
        City:
        <input value={person.artwork.city} onChange={handleCityChange} />
      </label>
      <label>
        Image:
        <input value={person.artwork.image} onChange={handleImageChange} />
      </label>
      <p>
        <i>{person.artwork.title}</i>
        {' by '}
        {person.name}
        <br />
        (located in {person.artwork.city})
      </p>
      <img src={person.artwork.image} alt={person.artwork.title} />
    </>
  );
}
```

```css
label {
  display: block;
}
input {
  margin-left: 5px;
  margin-bottom: 5px;
}
img {
  width: 200px;
  height: 200px;
}
```

</Sandpack>

---

## Les objets sont-il imbriqu√©s?

<TwoColumns top style={{ gridTemplateColumns:"1fr 2fr"}}>

<div style={{marginTop:'1em'}}>

Les objets suivants semblent "imbriqu√©s" dans le code.

</div>

```js
let obj = {
  name: 'Niki de Saint Phalle',
  artwork: {
    title: 'Blue Nana',
    city: 'Hamburg',
    image: 'https://i.imgur.com/Sd1AgUOm.jpg',
  },
};
```

<div style={{ marginTop: '1em' }}>
  C'est trompeur. Quand le code ex√©cute, la notion d'imbrication n'existe pas.
  En fait, ce sont deux objets distincts.
</div>

```js
let obj1 = {
  title: 'Blue Nana',
  city: 'Hamburg',
  image: 'https://i.imgur.com/Sd1AgUOm.jpg',
};

let obj2 = {
  name: 'Niki de Saint Phalle',
  artwork: obj1,
};
```

</TwoColumns>

---

## Les objet ne sont pas vraiment imbriqu√©s

L'objet `obj1` n'est pas vraiment stock√© dans `obj2`. La preuve, `obj3` pourrait r√©f√©rer √† `obj1` aussi:

<TwoColumns top>

```js
let obj1 = {
  title: 'Blue Nana',
  city: 'Hamburg',
  image: 'https://i.imgur.com/Sd1AgUOm.jpg',
};

let obj2 = {
  name: 'Niki de Saint Phalle',
  artwork: obj1,
};

let obj3 = {
  name: 'Copycat',
  artwork: obj1,
};
```

<div style={{marginTop:20}}>
Si on mute `obj3.artwork.city`, cela affecte `obj2.artwork.city` ainsi que `obj1.city`.

C'est que `obj3.artwork`, `obj2.artwork`, ainsi qu'`obj1` r√©f√®rent tous au m√™me objet.

Ils ne sont donc pas "imbriqu√©s". Il est pr√©f√©rable de les concevoir en tant qu'objets s√©par√©s, qui r√©f√®rent ou pointent les uns les autres.

</div>
</TwoColumns>

---

## R√©aliser des modifications complexes avec immer

<Alert type="warning">

Quand l'√©tat est complexe, avec plusieurs objets "imbriqu√©s", on pourrait consid√©rer le
rendre plat (le rendre moins complexe). Mais si on pr√©f√®re conserver la structure complexe, il existe
un outil: [Immer](https://github.com/immerjs/use-immer) est
une biblioth√®que populaire qui permet d'utiliser une syntaxe de changements mutatifs,
mais qui produit un r√©sultat en copie d'objet. On pourrait croire que le code suivant brise
la r√®gle d'immuabilit√© du state. Mais avec Immer, ce n'est pas le cas.

```js
updatePerson((draft) => {
  draft.artwork.city = 'Lagos';
});
```

Contrairement aux mutations r√©guli√®res, **immer** n'√©crase pas les √©tats pr√©c√©dents.

</Alert>

---

## Comment fonctionne Immer?

Pour utiliser Immer

1. `npm install use-immer` pour ajouter Immer en tant que d√©pendance.
2. Remplacez `import { useState } from 'react'` par `import { useImmer } from 'use-immer'`

<Alert type="warning">
Le `draft` (brouillon) fourni par Immer est un objet sp√©cial, nomm√© [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy), qui enregistre toutes les mutations qui affectent l'objet. C'est pour cela qu'il est possible de muter l'objet autant qu'on le d√©sire. Dans les coulisses, Immer d√©termine les modifications √† `draft` et produit un nouvel objet avec toutes vos modifications.

</Alert>

---

## Exemple qui utilise Immer

<Sandpack>

```js
import { useImmer } from 'use-immer';

export default function Form() {
  const [person, updatePerson] = useImmer({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: 'https://i.imgur.com/Sd1AgUOm.jpg',
    },
  });

  function handleNameChange(e) {
    updatePerson((draft) => {
      draft.name = e.target.value;
    });
  }

  function handleTitleChange(e) {
    updatePerson((draft) => {
      draft.artwork.title = e.target.value;
    });
  }

  function handleCityChange(e) {
    updatePerson((draft) => {
      draft.artwork.city = e.target.value;
    });
  }

  function handleImageChange(e) {
    updatePerson((draft) => {
      draft.artwork.image = e.target.value;
    });
  }

  return (
    <>
      <label>
        Name:
        <input value={person.name} onChange={handleNameChange} />
      </label>
      <label>
        Title:
        <input value={person.artwork.title} onChange={handleTitleChange} />
      </label>
      <label>
        City:
        <input value={person.artwork.city} onChange={handleCityChange} />
      </label>
      <label>
        Image:
        <input value={person.artwork.image} onChange={handleImageChange} />
      </label>
      <p>
        <i>{person.artwork.title}</i>
        {' by '}
        {person.name}
        <br />
        (located in {person.artwork.city})
      </p>
      <img src={person.artwork.image} alt={person.artwork.title} />
    </>
  );
}
```

```json package.json
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

```css
label {
  display: block;
}
input {
  margin-left: 5px;
  margin-bottom: 5px;
}
img {
  width: 200px;
  height: 200px;
}
```

</Sandpack>

Les gestionnaires d'√©v√©nements ci-haut sont simples et concis.

Il serait possible d'utiliser le `useState` et le `useImmer` dans le m√™me composant.

Immer est une fa√ßon de garder le code simple et concis, surtout avec des objets imbriqu√©s, o√π la copie d'objet g√©n√®re du code complexe.

---

## Pourquoi √©viter la mutation d'√©tat en React (1/2)

Voici les raisons:

- **D√©bogage:** Si vous utilisez `console.log` et ne mutez pas le state, vos logs pr√©c√©dents ne seront pas √©cras√©s par vos logs plus r√©cents. C'est plus simple et clair de suivre l'historique des changements.
- **Optimisations:** Plusieurs strat√©gies d'optimisation de React (memo) vont 'sauter' le rendu quand les props ou le state n'a pas √©t√© modifi√©. Quand on ne mute jamais l'√©tat, c'est tr√®s simple de valider s'il y a des changements avec une simple comparaison `prevObj ===  obj`
- **Nouvelles fonctionnalit√©s:** L'√©quipe React pr√©pare de nouvelles fonctionnalit√©s qui se fient que l'√©tat n'est jamais mut√©. Ces nouvelles fonctionnalit√©s pourraient √©chouer si votre projet utilise de la mutation.

---

## Pourquoi √©viter la mutation d'√©tat en React (2/2)

- **Ajout de besoins:** Certaines fonctionnalit√©s, tel qu'implanter annuler/r√©tablir, afficher un historique de changements, permettre de r√©initialiser un formulaire aux valeurs pr√©c√©dentes, sont des actions simples √† r√©aliser quand rien n'est mut√©. C'est plus simple de garder des copies des √©tats pr√©c√©dents, et de les ramener au besoin. C'est plus compliqu√© √† implanter quand il y a des mutations.
- **Simplicit√©:** Quand React ne fait aucune mutation, il n'y a alors rien de sp√©cial √† coder. Pas besoin de proxy, ni de propri√©t√©s captur√©es, ni d'objets r√©actifs √† initialiser. C'est pourquoi React nous permet d'ajouter n'importe quel objet dans l'√©tat, sans aucun impact sur la performance.

Il est souvent possible de muter l'√©tat en React sans ressentir d'impact n√©gatif. Mais √† mesure que des nouvelles fonctionnalit√©s sont ajout√©es √† React, celles-ci s'attendent √† ce que les objets soient immuables. Donc, pour que votre code soit compatible avec une future version de React, assurez-vous d'√©crire du code avec un √©tat immuable.

---

## D√©fi 1

Ce formulaire a quelques bogues. Cliquez le bouton pour ajouter du pointage quelques fois. Rien ne change... Modifiez le pr√©nom, et soudainement le pointage est corrig√©. Modifiez le nom, et tout disparait.

Trouvez les bogues et r√©parez-les...

<Sandpack>

```js
import { useState } from 'react';

export default function Scoreboard() {
  const [joueur, setJoueur] = useState({
    prenom: 'Ranjani',
    nom: 'Shettar',
    pointage: 10,
  });

  function handlePlusClick() {
    joueur.pointage++;
  }

  function handlePrenomChange(e) {
    setJoueur({
      ...joueur,
      prenom: e.target.value,
    });
  }

  function handleNomChange(e) {
    setJoueur({
      nom: e.target.value,
    });
  }

  return (
    <>
      <label>
        Pointages: <b>{joueur.pointage}</b>{' '}
        <button onClick={handlePlusClick}>+1</button>
      </label>
      <label>
        Pr√©nom:
        <input value={joueur.prenom} onChange={handlePrenomChange} />
      </label>
      <label>
        Nom:
        <input value={joueur.nom} onChange={handleNomChange} />
      </label>
    </>
  );
}
```

```css
label {
  display: block;
  margin-bottom: 10px;
}
input {
  margin-left: 5px;
  margin-bottom: 5px;
}
```

</Sandpack>

---

## D√©fi 2

Voci un bo√Æte que l'on peut d√©placer. On peut changer sa couleur avec le champ de saisie.

Mais il y a un bogue. Si vous d√©placez la bo√Æte d'abord, et ensuite changez sa couleur, le fond va sauter √† une nouvelle position. Ce n'est pas normal.

R√©parez le bogue.

Il y a un changement innatendu via mutation.

<Sandpack>

```js src/App.js
import { useState } from 'react';
import Background from './Background.js';
import Box from './Box.js';

const initialPosition = {
  x: 0,
  y: 0,
};

export default function Canvas() {
  const [shape, setShape] = useState({
    color: 'orange',
    position: initialPosition,
  });

  function handleMove(dx, dy) {
    shape.position.x += dx;
    shape.position.y += dy;
  }

  function handleColorChange(e) {
    setShape({
      ...shape,
      color: e.target.value,
    });
  }

  return (
    <>
      <select value={shape.color} onChange={handleColorChange}>
        <option value='orange'>orange</option>
        <option value='lightpink'>lightpink</option>
        <option value='aliceblue'>aliceblue</option>
      </select>
      <Background position={initialPosition} />
      <Box color={shape.color} position={shape.position} onMove={handleMove}>
        Bougez moi!
      </Box>
    </>
  );
}
```

```js src/Box.js
import { useState } from 'react';

export default function Box({ children, color, position, onMove }) {
  const [lastCoordinates, setLastCoordinates] = useState(null);

  function handlePointerDown(e) {
    e.target.setPointerCapture(e.pointerId);
    setLastCoordinates({
      x: e.clientX,
      y: e.clientY,
    });
  }

  function handlePointerMove(e) {
    if (lastCoordinates) {
      setLastCoordinates({
        x: e.clientX,
        y: e.clientY,
      });
      const dx = e.clientX - lastCoordinates.x;
      const dy = e.clientY - lastCoordinates.y;
      onMove(dx, dy);
    }
  }

  function handlePointerUp(e) {
    setLastCoordinates(null);
  }

  return (
    <div
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      style={{
        width: 100,
        height: 100,
        cursor: 'grab',
        backgroundColor: color,
        position: 'absolute',
        border: '1px solid black',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        transform: `translate(
          ${position.x}px,
          ${position.y}px
        )`,
      }}
    >
      {children}
    </div>
  );
}
```

```js src/Background.js
export default function Background({ position }) {
  return (
    <div
      style={{
        position: 'absolute',
        transform: `translate(
        ${position.x}px,
        ${position.y}px
      )`,
        width: 250,
        height: 250,
        backgroundColor: 'rgba(200, 200, 0, 0.2)',
      }}
    />
  );
}
```

```css
body {
  height: 280px;
}
select {
  margin-bottom: 10px;
}
```

</Sandpack>

---

## D√©fi 3

Voici le m√™me exemple que dans le d√©fi pr√©c√©dent. Cette fois-ci, il faut r√©parer la mutation via Immer. Pour vous aider, `useImmer` est d√©j√† import√©. Il ne reste qu'√† changer la variable shape.

<Sandpack>

```js src/App.js
import { useState } from 'react';
import { useImmer } from 'use-immer';
import Background from './Background.js';
import Box from './Box.js';

const initialPosition = {
  x: 0,
  y: 0,
};

export default function Canvas() {
  const [shape, setShape] = useState({
    color: 'orange',
    position: initialPosition,
  });

  function handleMove(dx, dy) {
    shape.position.x += dx;
    shape.position.y += dy;
  }

  function handleColorChange(e) {
    setShape({
      ...shape,
      color: e.target.value,
    });
  }

  return (
    <>
      <select value={shape.color} onChange={handleColorChange}>
        <option value='orange'>orange</option>
        <option value='lightpink'>lightpink</option>
        <option value='aliceblue'>aliceblue</option>
      </select>
      <Background position={initialPosition} />
      <Box color={shape.color} position={shape.position} onMove={handleMove}>
        Bougez moi!
      </Box>
    </>
  );
}
```

```js src/Box.js
import { useState } from 'react';

export default function Box({ children, color, position, onMove }) {
  const [lastCoordinates, setLastCoordinates] = useState(null);

  function handlePointerDown(e) {
    e.target.setPointerCapture(e.pointerId);
    setLastCoordinates({
      x: e.clientX,
      y: e.clientY,
    });
  }

  function handlePointerMove(e) {
    if (lastCoordinates) {
      setLastCoordinates({
        x: e.clientX,
        y: e.clientY,
      });
      const dx = e.clientX - lastCoordinates.x;
      const dy = e.clientY - lastCoordinates.y;
      onMove(dx, dy);
    }
  }

  function handlePointerUp(e) {
    setLastCoordinates(null);
  }

  return (
    <div
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      style={{
        width: 100,
        height: 100,
        cursor: 'grab',
        backgroundColor: color,
        position: 'absolute',
        border: '1px solid black',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        transform: `translate(
          ${position.x}px,
          ${position.y}px
        )`,
      }}
    >
      {children}
    </div>
  );
}
```

```js src/Background.js
export default function Background({ position }) {
  return (
    <div
      style={{
        position: 'absolute',
        transform: `translate(
        ${position.x}px,
        ${position.y}px
      )`,
        width: 250,
        height: 250,
        backgroundColor: 'rgba(200, 200, 0, 0.2)',
      }}
    />
  );
}
```

```css
body {
  height: 280px;
}
select {
  margin-bottom: 10px;
}
```

```json package.json
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

</Sandpack>

---

## Modifier les tableaux

En JavaScript, il est permis de muter les tableaux. Mais pour l'√©tat React, on doit les traiter de fa√ßon immuable. Comme les objets, quand on veut modifier un tableau, il faut en cr√©er un nouveau ou le cloner.

---

## Modifier les tableaux sans mutation

En JS, les tableaux sont un type d'objet. Et de la m√™me fa√ßon qu'on g√®re les objets en React, on doit g√©rer les tableaux dans l'√©tat React comme s'ils sont en lecture seule. Il faut √©viter la r√©assignation: `arr[0] = 'non'` ainsi que les m√©thodes qui mutent le tableau (ex: `push()` et `pop()`).

Chaque fois qu'on veut modifier le tableau, il faut passer un nouveau tableau au setState. On peut utiliser les m√©thodes `filter()` et `map()`. On peut √©crire l'√©tat avec le nouveau tableau.

Voici une table de r√©f√©rence des op√©rations de tableau communes. Evitez les m√©thodes de la colonne de gauche. Pr√©f√©rez les m√©thodes de la colonne de droite.

<div style={{display: "flex", flexDirection: "column"}}>

|              | Mutation du tableau üö´               | Nouveau Tableau ‚úÖ                           |
| ------------ | ------------------------------------ | -------------------------------------------- |
| Ajout        | `push()`, `unshift()`                | `concat()`, `[...arr]` syntaxe d√©composition |
| Suppression  | `pop()`, `shift()`, `splice()`       | `filter()`, `slice()`, `toSpliced()` üÜï      |
| Remplacement | `splice()`, `arr[i] = x` assignation | `map()`, `.with()` üÜï                        |
| Tri          | `sort()`, `reverse()`,               | `toSorted()` üÜï, `toReversed()` üÜï           |

</div>
<hr />
<Alert>
Alternativement, on peut utiliser Immer qui permet l'usage des mutations.
</Alert>

---

## Ajouter √† un tableau avec push üö´

`push()` mute un tableau en ajoutant un item. (√Ä √©viter) üö´

<Sandpack>

```js
import { useState } from 'react';

let nextId = 0;

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState([]);

  return (
    <>
      <h1>Sculpteurs:</h1>
      <input value={name} onChange={(e) => setName(e.target.value)} />
      <button
        onClick={() => {
          setName('');
          artists.push({
            id: nextId++,
            name: name,
          });
        }}
      >
        Add
      </button>
      <ul>
        {artists.map((artist) => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}
```

```css
button {
  margin-left: 5px;
}
```

</Sandpack>

---

## Ajouter √† un tableau avec d√©composition

Pr√©f√©rez plut√¥t la cr√©ation d'un _nouveau_ tableau contenant les items existants et un nouvel item √† la fin. Il y a plusieurs approches possibles, mais le plus simple est d'utiliser la syntaxe de d√©composition de tableau: `...`

```js
setArtists(
  // Remplacer l'√©tat
  [
    // avec un nouveau tableau
    ...artists, // contenant les anciens items
    { id: nextId++, name: name }, // et un item additionnel √† la fin.
  ]
);
```

---

## Exemple de tableau avec d√©composition

<Sandpack>

```js
import { useState } from 'react';

let nextId = 0;

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState([]);

  return (
    <>
      <h1>Sculpteurs:</h1>
      <input value={name} onChange={(e) => setName(e.target.value)} />
      <button
        onClick={() => {
          setName('');
          setArtists([...artists, { id: nextId++, name: name }]);
        }}
      >
        Ajouter
      </button>
      <ul>
        {artists.map((artist) => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}
```

```css
button {
  margin-left: 5px;
}
```

</Sandpack>

La d√©composition permet d'ajouter √† la fin (comme `push()`) ou au d√©but (comme `unshift()`).

```js
setArtists([
  { id: nextId++, name: name }, //  ici, on ins√®re au d√©but du tableau
  ...artists, //            on ajoute le contenu existant par la suite
]);
```

---

## Enlever √† un Tableau

Pour enlever un item, il suffit de le _filtrer_ avec `filter`.

<Sandpack>

```js
import { useState } from 'react';

let initialArtists = [
  { id: 0, name: 'Marta Colvin Andrade' },
  { id: 1, name: 'Lamidi Olonade Fakeye' },
  { id: 2, name: 'Louise Nevelson' },
];

export default function List() {
  const [artists, setArtists] = useState(initialArtists);

  return (
    <>
      <h1>Sculpteurs:</h1>
      <ul>
        {artists.map((artist) => (
          <li key={artist.id}>
            {artist.name}{' '}
            <button
              onClick={() => {
                setArtists(artists.filter((a) => a.id !== artist.id));
              }}
            >
              Enlever
            </button>
          </li>
        ))}
      </ul>
    </>
  );
}
```

</Sandpack>

```js
setArtists(artists.filter((a) => a.id !== artist.id));
```

`filter()` g√©n√®re un nouveau tableau d'`artists`.

---

## Transformer un tableau avec `map`

`map()` g√©n√®re un nouveau tableau. La fonction pass√©e √† `map` d√©termine quoi faire avec chaque item, bas√© sur son contenu ou son index (ou les deux).

Dans cet exemple, un tableau d√©tient les coordonn√©es de deux cercles et un carr√©. Quand on clique le bouton, on d√©place les cercles de 50 pixels vers le bas. `map()` va cr√©er ce nouveau tableau.

<Sandpack>

```js
import { useState } from 'react';

let initialShapes = [
  { id: 0, type: 'circle', x: 50, y: 100 },
  { id: 1, type: 'square', x: 150, y: 100 },
  { id: 2, type: 'circle', x: 250, y: 100 },
];

export default function ShapeEditor() {
  const [shapes, setShapes] = useState(initialShapes);

  function handleClick() {
    const nextShapes = shapes.map((shape) => {
      if (shape.type === 'square') {
        // Pas de changement
        return shape;
      } else {
        // Retourne un cercle 50 pixels plus bas
        return {
          ...shape,
          y: shape.y + 50,
        };
      }
    });
    // Provoque un re-rendu avec le nouveau tableau
    setShapes(nextShapes);
  }

  return (
    <>
      <button onClick={handleClick}>D√©placez les cercles!</button>
      {shapes.map((shape) => (
        <div
          key={shape.id}
          style={{
            background: 'purple',
            position: 'absolute',
            left: shape.x,
            top: shape.y,
            borderRadius: shape.type === 'circle' ? '50%' : '',
            width: 20,
            height: 20,
          }}
        />
      ))}
    </>
  );
}
```

```css
body {
  height: 300px;
}
```

</Sandpack>

---

## Remplacer les items d'un tableau

Les asignations du genre `arr[0] = x` mutent l'objet. On pr√©f√®re utiliser `map` pour g√©n√©rer un nouveau tableau.

`map`, re√ßoit l'item et l'index comme arguments. On peut utiliser l'index (la position) pour d√©cider si on retourne l'item original, ou autre chose.

<Sandpack>

```js
import { useState } from 'react';

let initialCounters = [0, 0, 0];

export default function CounterList() {
  const [counters, setCounters] = useState(initialCounters);

  function handleIncrementClick(index) {
    const nextCounters = counters.map((c, i) => {
      if (i === index) {
        // Incr√©mente le compteur cliqu√©
        return c + 1;
      } else {
        // Le reste demeure la m√™me chose
        return c;
      }
    });
    setCounters(nextCounters);
  }

  return (
    <ul>
      {counters.map((counter, i) => (
        <li key={i}>
          {counter}
          <button
            onClick={() => {
              handleIncrementClick(i);
            }}
          >
            +1
          </button>
        </li>
      ))}
    </ul>
  );
}
```

```css
button {
  margin: 5px;
}
```

</Sandpack>

---

## Ins√©rer au milieu d'un tableau

Pour ins√©rer un item, il faut cr√©er un tableau qui d√©compose la portion avant le point d'ins√©rtion, par la suite ajouter le nouvel item, et ensuite d√©composer le reste du tableau.

Pour cela, on peut utiliser la m√©thode `slice()` avec la syntaxe de d√©composition de tableau `...`. (Dans cet exemple, "Ins√©rer" tente d'ins√©rer √† la position 1.)

<Sandpack>

```js
import { useState } from 'react';

let nextId = 3;
const initialArtists = [
  { id: 0, name: 'Marta Colvin Andrade' },
  { id: 1, name: 'Lamidi Olonade Fakeye' },
  { id: 2, name: 'Louise Nevelson' },
];

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState(initialArtists);

  function handleClick() {
    const insertAt = 1; // Pourrait √™tre n'importe quel index
    const nextArtists = [
      // Items avant le point d'insertion:
      ...artists.slice(0, insertAt),
      // Nouvel item
      { id: nextId++, name: name },
      // Items apr√®s le point d'insertion:
      ...artists.slice(insertAt),
    ];
    setArtists(nextArtists);
    setName('');
  }

  return (
    <>
      <h1>Sculpteurs:</h1>
      <input value={name} onChange={(e) => setName(e.target.value)} />
      <button onClick={handleClick}>Ins√©rer</button>
      <ul>
        {artists.map((artist) => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}
```

```css
button {
  margin-left: 5px;
}
```

</Sandpack>

---

## Faire des changements avanc√©s

On pourrait vouloir renverser un tableau, ou le trier. Mais les m√©thodes `reverse()` et `sort()` mutent le tableau orginal. Que faire si nous sommes avant 2023?

**Faites une copie du tableau d'abord, et faites des changements mutatifs ensuite**

On utilise la syntaxe de d√©composition `[...list]` pour cr√©er une copie du tableau original.

<Sandpack>

```js
import { useState } from 'react';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies' },
  { id: 1, title: 'Lunar Landscape' },
  { id: 2, title: 'Terracotta Army' },
];

export default function List() {
  const [list, setList] = useState(initialList);

  function handleClick() {
    const nextList = [...list];
    nextList.reverse();
    setList(nextList);
  }

  return (
    <>
      <button onClick={handleClick}>Inverser</button>
      <ul>
        {list.map((artwork) => (
          <li key={artwork.id}>{artwork.title}</li>
        ))}
      </ul>
    </>
  );
}
```

</Sandpack>

---

## Tableau r√©f√©rant des objets

Par contre, m√™me si on copie un tableau, on ne peut muter les objets du tableau. La copie est superficielle (shallow), et ce nouveau tableau contient les m√™mes objets que l'original. Si on modifie un objet dans le tableau copi√©, on mute l'√©tat.

Le code suivant est probl√©matique:

```js
const nextList = [...list];
nextList[0].seen = true; // Probl√®me: mutation  üö´
setList(nextList);
```

M√™me si `nextList` et `list` sont deux tableaux distincts, **`nextList[0]` et `list[0]` pointent vers le m√™me objet** En modifiant `nextList[0].seen`, on modifie aussi `list[0].seen`. C'est donc une mutation d'√©tat. üö´

On r√©sout ce probl√®me de la m√™me fa√ßon qu'avec les objets JS imbriqu√©s: en clonant plut√¥t que de muter.

<div style={{fontSize:"2rem"}}>
```js
nextList[0] = {...nextList[0], seen: true }; ‚úÖ
```
</div>

---

## Modifier des objets dans des tableaux

Les objets ne sont pas r√©ellement dans les tableaux. M√™me si on dirait qu'ils sont imbriqu√©s, chaque objet est une valeur s√©par√©e, vers lequel le tableau pointe. **Lorsqu'on met √† jour des √©tats imbriqu√©s, il faut cr√©er des copies des objets √† modifier, jusqu'au top niveau.**

Dans cet exemple, deux listes d'oeuvres d'art partagent le m√™me √©tat initial. √Ä cause d'une valeur mut√©e, leur √©tat est accidentellement partag√©. Cocher la boite d'une liste affecte l'autre liste.

<Sandpack>

```js
import { useState } from 'react';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [myList, setMyList] = useState(initialList);
  const [yourList, setYourList] = useState(initialList);

  function handleToggleMyList(artworkId, nextSeen) {
    const myNextList = [...myList];
    const artwork = myNextList.find((a) => a.id === artworkId);
    artwork.seen = nextSeen;
    setMyList(myNextList);
  }

  function handleToggleYourList(artworkId, nextSeen) {
    const yourNextList = [...yourList];
    const artwork = yourNextList.find((a) => a.id === artworkId);
    artwork.seen = nextSeen;
    setYourList(yourNextList);
  }

  return (
    <>
      <h1>Oeuvres d'art</h1>
      <h2>Ma liste d'art:</h2>
      <ItemList artworks={myList} onToggle={handleToggleMyList} />
      <h2>Ta liste d'art:</h2>
      <ItemList artworks={yourList} onToggle={handleToggleYourList} />
    </>
  );
}

function ItemList({ artworks, onToggle }) {
  return (
    <ul>
      {artworks.map((artwork) => (
        <li key={artwork.id}>
          <label>
            <input
              type='checkbox'
              checked={artwork.seen}
              onChange={(e) => {
                onToggle(artwork.id, e.target.checked);
              }}
            />
            {artwork.title}
          </label>
        </li>
      ))}
    </ul>
  );
}
```

</Sandpack>

---

## le probl√®me

Le probl√®me est ici:

```js
const myNextList = [...myList];
const artwork = myNextList.find((a) => a.id === artworkId);
artwork.seen = nextSeen; // Probl√®me: on mute un item existant üö´
setMyList(myNextList);
```

M√™me si le tableau `myNextList` est nouveau, les _items_ sont les m√™mes que dans le tableau original `myList`. Changer `artwork.seen` modifie donc l'objet _original_. Cet objet se trouve aussi dans `yourArtworks`, causant le bogue. Ce bogue est difficile √† trouver, mais il disparait d√®s qu'on arr√™te de muter.

**On peut utiliser `map` pour substituer un vieil objet avec une nouvelle version, sans mutation**

```js
setMyList(myList.map(artwork => {
  if (artwork.id === artworkId) {
    // Cr√©er un nouvel objet, avec changements
    return { ...artwork, seen: nextSeen };
  } else {
    // Pas de changements, on conserve l'objet
    return artwork;
  }
});
```

---

## D√©composer les items des tableaux

Ici, `...` est la syntaxe de d√©composition pour cr√©er la copie d'un objet. Aucun des items d'√©tat n'est mut√©, et le bogue est r√©gl√©.

<Sandpack>

```js
import { useState } from 'react';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [myList, setMyList] = useState(initialList);
  const [yourList, setYourList] = useState(initialList);

  function handleToggleMyList(artworkId, nextSeen) {
    setMyList(
      myList.map((artwork) => {
        if (artwork.id === artworkId) {
          // Cr√©√© un nouvel objet, avec changements
          return { ...artwork, seen: nextSeen };
        } else {
          // Pas de changements, on conserve l'objet
          return artwork;
        }
      })
    );
  }

  function handleToggleYourList(artworkId, nextSeen) {
    setYourList(
      yourList.map((artwork) => {
        if (artwork.id === artworkId) {
          // Cr√©√© un nouvel objet, avec changements
          return { ...artwork, seen: nextSeen };
        } else {
          // Pas de changements, on conserve l'objet
          return artwork;
        }
      })
    );
  }

  return (
    <>
      <h1>Liste des oeuvres d'art</h1>
      <h2>Ma liste:</h2>
      <ItemList artworks={myList} onToggle={handleToggleMyList} />
      <h2>Ta liste:</h2>
      <ItemList artworks={yourList} onToggle={handleToggleYourList} />
    </>
  );
}

function ItemList({ artworks, onToggle }) {
  return (
    <ul>
      {artworks.map((artwork) => (
        <li key={artwork.id}>
          <label>
            <input
              type='checkbox'
              checked={artwork.seen}
              onChange={(e) => {
                onToggle(artwork.id, e.target.checked);
              }}
            />
            {artwork.title}
          </label>
        </li>
      ))}
    </ul>
  );
}
```

</Sandpack>

En g√©n√©ral, **le seul objet d'√©tat que l'on peut muter, c'est celui qui vient tout juste d'√™tre cr√©√©.** Si on ins√®re une nouvelle oeuvre d'art, c'est correct de la muter. Mais si on modifie un objet provenant de l'√©tat, il faut faire une copie.

---

## √âcrire une logique concise avec Immer

Modifier des tableaux imbriqu√©s, sans mutation, est r√©p√©titif et complexe.

- En g√©n√©ral, on ne devrait pas modifier les donn√©es profond√©ment imbriqu√©es.
- On pourrait r√©√©crire la structure pour avoir une structure moins profonde (aplatir la structure)
- Aleternative, on pourrait utiliser [Immer](https://github.com/immerjs/use-immer). On peut alors utiliser la mutation (car Immer fait une copie des mutations)

<Sandpack>

```js src/App.js
import { useState } from 'react';
import { useImmer } from 'use-immer';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [myList, updateMyList] = useImmer(initialList);
  const [yourArtworks, updateYourList] = useImmer(initialList);

  function handleToggleMyList(id, nextSeen) {
    updateMyList((draft) => {
      const artwork = draft.find((a) => a.id === id);
      artwork.seen = nextSeen;
    });
  }

  function handleToggleYourList(artworkId, nextSeen) {
    updateYourList((draft) => {
      const artwork = draft.find((a) => a.id === artworkId);
      artwork.seen = nextSeen;
    });
  }

  return (
    <>
      <h1>Liste d'oeuvres d'art</h1>
      <h2>Ma liste:</h2>
      <ItemList artworks={myList} onToggle={handleToggleMyList} />
      <h2>Ta liste:</h2>
      <ItemList artworks={yourArtworks} onToggle={handleToggleYourList} />
    </>
  );
}

function ItemList({ artworks, onToggle }) {
  return (
    <ul>
      {artworks.map((artwork) => (
        <li key={artwork.id}>
          <label>
            <input
              type='checkbox'
              checked={artwork.seen}
              onChange={(e) => {
                onToggle(artwork.id, e.target.checked);
              }}
            />
            {artwork.title}
          </label>
        </li>
      ))}
    </ul>
  );
}
```

```json package.json
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

</Sandpack>

---

## Utiliser Immer

Avec Immer, **les mutations comme `artwork.seen = nextSeen` sont permises:**

```js
updateMyTodos((draft) => {
  const artwork = draft.find((a) => a.id === artworkId);
  artwork.seen = nextSeen;
});
```

C'est correct ici car on ne mute pas l'√©tat original. On mute un objet sp√©cial `draft`, fourni par Immer. On pourait aussi utiliser `push()` and `pop()` pour modifier `draft`.

Dans les coulisses, Immer construit le prochain objet d'√©tat √† partir des mutations de `draft`. Ceci permet d'avoir des gestionnaires d'√©v√©nemnts plus simples et courts.

---

## D√©fi 5

√âcrivez la logique de `handleIncreaseClick`. Quand on clique "+", cela incr√©mente le nombre

<Sandpack>

```js
import { useState } from 'react';

const initialProducts = [
  {
    id: 0,
    name: 'Baklava',
    count: 1,
  },
  {
    id: 1,
    name: 'Sandwich',
    count: 5,
  },
  {
    id: 2,
    name: 'Spaghetti',
    count: 2,
  },
];

export default function ShoppingCart() {
  const [products, setProducts] = useState(initialProducts);

  function handleIncreaseClick(productId) {}

  return (
    <ul>
      {products.map((product) => (
        <li key={product.id}>
          {product.name} (<b>{product.count}</b>)
          <button
            onClick={() => {
              handleIncreaseClick(product.id);
            }}
          >
            +
          </button>
        </li>
      ))}
    </ul>
  );
}
```

```css
button {
  margin: 5px;
}
```

</Sandpack>

---

## D√©fi 6

Le bouton "-" ne fait rien. Il faut ajouter un gestionnaire d'√©v√©nements qui d√©cr√©mente le `count`du produit. Quand on p√®se "-" et que le compte est 1, il faut enlever le produit du panier d'achat. (On ne doit pas afficher 0)

<Sandpack>

```js
import { useState } from 'react';

const initialProducts = [
  {
    id: 0,
    name: 'Baklava',
    count: 1,
  },
  {
    id: 1,
    name: 'Sandwich',
    count: 5,
  },
  {
    id: 2,
    name: 'Spaghetti',
    count: 2,
  },
];

export default function ShoppingCart() {
  const [products, setProducts] = useState(initialProducts);

  function handleIncreaseClick(productId) {
    setProducts(
      products.map((product) => {
        if (product.id === productId) {
          return {
            ...product,
            count: product.count + 1,
          };
        } else {
          return product;
        }
      })
    );
  }

  return (
    <ul>
      {products.map((product) => (
        <li key={product.id}>
          {product.name} (<b>{product.count}</b>)
          <button
            onClick={() => {
              handleIncreaseClick(product.id);
            }}
          >
            +
          </button>
          <button>‚Äì</button>
        </li>
      ))}
    </ul>
  );
}
```

```css
button {
  margin: 5px;
}
```

</Sandpack>

---

## D√©fi 7

Tous les gestionnaires d'√©v√©nements de `App.js` utilisent la mutation. L'√©dition et la supression des todos ne fonctionnent pas. Il faut r√©√©crire `handleAddTodo`, `handleChangeTodo` et `handleDeleteTodo` pour ne plus muter.

<Sandpack>

```js src/App.js
import { useState } from 'react';
import AddTodo from './AddTodo.js';
import TaskList from './TaskList.js';

let nextId = 3;
const initialTodos = [
  { id: 0, title: 'Acheter lait', done: true },
  { id: 1, title: 'Manger collation', done: false },
  { id: 2, title: 'Pr√©parer du th√©', done: false },
];

export default function TaskApp() {
  const [todos, setTodos] = useState(initialTodos);

  function handleAddTodo(title) {
    todos.push({
      id: nextId++,
      title: title,
      done: false,
    });
  }

  function handleChangeTodo(nextTodo) {
    const todo = todos.find((t) => t.id === nextTodo.id);
    todo.title = nextTodo.title;
    todo.done = nextTodo.done;
  }

  function handleDeleteTodo(todoId) {
    const index = todos.findIndex((t) => t.id === todoId);
    todos.splice(index, 1);
  }

  return (
    <>
      <AddTodo onAddTodo={handleAddTodo} />
      <TaskList
        todos={todos}
        onChangeTodo={handleChangeTodo}
        onDeleteTodo={handleDeleteTodo}
      />
    </>
  );
}
```

```js src/AddTodo.js
import { useState } from 'react';

export default function AddTodo({ onAddTodo }) {
  const [title, setTitle] = useState('');
  return (
    <>
      <input
        placeholder='Ajouter Todo'
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />
      <button
        onClick={() => {
          setTitle('');
          onAddTodo(title);
        }}
      >
        Ajouter
      </button>
    </>
  );
}
```

```js src/TaskList.js
import { useState } from 'react';

export default function TaskList({ todos, onChangeTodo, onDeleteTodo }) {
  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>
          <Task todo={todo} onChange={onChangeTodo} onDelete={onDeleteTodo} />
        </li>
      ))}
    </ul>
  );
}

function Task({ todo, onChange, onDelete }) {
  const [isEditing, setIsEditing] = useState(false);
  let todoContent;
  if (isEditing) {
    todoContent = (
      <>
        <input
          value={todo.title}
          onChange={(e) => {
            onChange({
              ...todo,
              title: e.target.value,
            });
          }}
        />
        <button onClick={() => setIsEditing(false)}>Confirmer</button>
      </>
    );
  } else {
    todoContent = (
      <>
        {todo.title}
        <button onClick={() => setIsEditing(true)}>Modifier</button>
      </>
    );
  }
  return (
    <label>
      <input
        type='checkbox'
        checked={todo.done}
        onChange={(e) => {
          onChange({
            ...todo,
            done: e.target.checked,
          });
        }}
      />
      {todoContent}
      <button onClick={() => onDelete(todo.id)}>Suprimer</button>
    </label>
  );
}
```

```css
button {
  margin: 5px;
}
li {
  list-style-type: none;
}
ul,
li {
  margin: 0;
  padding: 0;
}
```

</Sandpack>

---

## D√©fi 8

M√™me exemple que pr√©c√©demment. Cette fois-ci, on r√©pare les mutations en utilisant Immer. `useImmer` est d√©j√† import√©.

<Sandpack>

```js src/App.js
import { useState } from 'react';
import { useImmer } from 'use-immer';
import AddTodo from './AddTodo.js';
import TaskList from './TaskList.js';

let nextId = 3;
const initialTodos = [
  { id: 0, title: 'Acheter lait', done: true },
  { id: 1, title: 'Manger collation', done: false },
  { id: 2, title: 'Pr√©parer du th√©', done: false },
];

export default function TaskApp() {
  const [todos, setTodos] = useState(initialTodos);

  function handleAddTodo(title) {
    todos.push({
      id: nextId++,
      title: title,
      done: false,
    });
  }

  function handleChangeTodo(nextTodo) {
    const todo = todos.find((t) => t.id === nextTodo.id);
    todo.title = nextTodo.title;
    todo.done = nextTodo.done;
  }

  function handleDeleteTodo(todoId) {
    const index = todos.findIndex((t) => t.id === todoId);
    todos.splice(index, 1);
  }

  return (
    <>
      <AddTodo onAddTodo={handleAddTodo} />
      <TaskList
        todos={todos}
        onChangeTodo={handleChangeTodo}
        onDeleteTodo={handleDeleteTodo}
      />
    </>
  );
}
```

```js src/AddTodo.js
import { useState } from 'react';

export default function AddTodo({ onAddTodo }) {
  const [title, setTitle] = useState('');
  return (
    <>
      <input
        placeholder='Ajouter Todo'
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />
      <button
        onClick={() => {
          setTitle('');
          onAddTodo(title);
        }}
      >
        Ajouter
      </button>
    </>
  );
}
```

```js src/TaskList.js
import { useState } from 'react';

export default function TaskList({ todos, onChangeTodo, onDeleteTodo }) {
  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>
          <Task todo={todo} onChange={onChangeTodo} onDelete={onDeleteTodo} />
        </li>
      ))}
    </ul>
  );
}

function Task({ todo, onChange, onDelete }) {
  const [isEditing, setIsEditing] = useState(false);
  let todoContent;
  if (isEditing) {
    todoContent = (
      <>
        <input
          value={todo.title}
          onChange={(e) => {
            onChange({
              ...todo,
              title: e.target.value,
            });
          }}
        />
        <button onClick={() => setIsEditing(false)}>Confirmer</button>
      </>
    );
  } else {
    todoContent = (
      <>
        {todo.title}
        <button onClick={() => setIsEditing(true)}>Modifier</button>
      </>
    );
  }
  return (
    <label>
      <input
        type='checkbox'
        checked={todo.done}
        onChange={(e) => {
          onChange({
            ...todo,
            done: e.target.checked,
          });
        }}
      />
      {todoContent}
      <button onClick={() => onDelete(todo.id)}>Supprimer</button>
    </label>
  );
}
```

```css
button {
  margin: 5px;
}
li {
  list-style-type: none;
}
ul,
li {
  margin: 0;
  padding: 0;
}
```

```json package.json
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

</Sandpack>

---

## Devoir 4

G√©n√©rer des composants React qui devrait avoir ces caract√©ristiques:

Un composant parent nomm√© "Compteur" qui g√®re un √©tat nomm√© "compte". Ce composant aura aussi quelques gestionnaires d'√©tats.

Ce composant g√©n√®re des composants enfants.

- Un "Titre" qui affiche le contenu du compteur dans un `<h1>`.
- Des "Bouton" qui permetent d'incr√©menter le contenu du compteur. On affiche 3 de ces boutons:
  - Un "Bouton" qui permet d'incr√©menter le contenu par 1.
  - Un "Bouton" qui permet d'incr√©menter le contenu par 10.
  - Un "Bouton" qui permet d'incr√©menter le contenu par 100.

On veut le bouton affich√© 3 fois, avec des props correctement configur√©s.

---

## Devoir (extras)

**Extra 1:** Modifier le code du bouton permettre d'ajouter un bouton qui d√©cr√©mente le contenu de 10. (C'est-√†-dire qui incr√©mente de -10) G√©rer le formattage pour que ce bouton affiche d'une couleur diff√©rente quand on d√©cr√©mente, et qui utilie le vocabulaire "incr√©mente/d√©cr√©mente" correctement.

**Extra 2:** Ajouter un composant nomm√© "Boite", qui affiche un `<input>` avec le nombre. Il faudra g√©rer correctment le gestionnaire d'√©v√©nement `onChange` pour lire le contenu du input (e.target.value). Il faudra convertir ce contenu vers un nombre pour modifier correctement l'√©tat. (indice: utiliser parseInt ou (+) unaire.)

Bonne chance!

---
