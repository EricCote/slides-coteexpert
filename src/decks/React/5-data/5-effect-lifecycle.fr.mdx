---
title: 'Cycle de vie des Effects'
---

# Cycle de vie des Effects

---

## Intro

- Les cycles de vie diff√®rent pour les composants et les effets
- Composants vont :
  - Monter (mount)
  - Mettre √† jour (update)
  - D√©monter (unmount)
- Effets vont :
  - D√©marrer la synchro
  - Arr√™ter la synchro
- Le linter de React s'assure que les d√©pendances soient bien d√©finies

---

## Contenu

- Diff√©rences entre les cycles de vie entre Composants et Effects
- Comment isoler chaque Effect individuellement
- Resynchroniser les Effects
- Comment d√©terminer les d√©pendances
- Qu'est-ce qu'une valeur r√©active
- Que signifie un tableau de d√©pendance vide
- Valider les d√©pendances avec un Linter
- Forcer la main du Linter

---

## Cycle de vie d'un Effect

- Chaque composant passe √† travers un cycle:
  - _montage_ (mount) quand le composant est ajout√© √† l'√©cran
  - _update_ quand le composant obtient de nouveaux props ou √©tat, suite √† une interaction .
  - _d√©montage_ (unmount) quand le composant est retir√© de l'√©cran
- Ce cycle d√©crit les composants, mais pas les Effects
- Un Effects permet la synchro avec un syst√®me externe

---

## Exemple sur le clavardage

```js
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}
```

---

## D√©marrer la synchronisation

```js {2-3}
// ...
const connection = createConnection(serverUrl, roomId);
connection.connect();
return () => {
  connection.disconnect();
};
// ...
```

---

## Arr√™ter la synchronisation

Avec la fonction _Cleanup_

```js {5}
// ...
const connection = createConnection(serverUrl, roomId);
connection.connect();
return () => {
  connection.disconnect();
};
// ...
```

---

## Arr√™ter et d√©marrer la synchro de multiples fois

- On commence la synchro au moment du montage (mount),
- On arr√™te la synchro au d√©montage (unmount).
- Parfois, on fait cela plusieurs fois, pendant que le composant demeure mont√©.

---

## La fonction de cleanup vide

- Les Effects ne retournent pas toujours de fonction de cleanup
- React consid√®re alors que cleanup est une fonction vide

---

## Rendu initial du composant

- Imaginons que `ChatRoom` re√ßoit une prop `roomId` choisie dans une liste d√©roulante.
- On choisi originalement le roomID `"general"`
- √áa affiche le roomID.

```js {3}
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId /* "general" */ }) {
  // ...
  return <h1>Welcome to the {roomId} room!</h1>;
}
```

---

## D√©marrer la synchro

- Apr√®s l'affichage, React ex√©cute l'Effect pour d√©marrer la synchro
- √áa connecte √† `general`:

```js {3,4}
function ChatRoom({ roomId /* "general" */ }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    // Connects to the "general" room
    connection.connect();
    return () => {
      connection.disconnect(); // Disconnects from the "general" room
    };
  }, [roomId]);
  // ...
```

---

## Second rendu avec un autre choix

- L'utilisateur choisit `"travel"` dans la liste d√©roulante
- React met √† jour l'IU

```js {1}
function ChatRoom({ roomId /* "travel" */ }) {
  // ...
  return <h1>Welcome to the {roomId} room!</h1>;
}
```

- Apr√®s le rendu, on affiche `"travel"`
- Mais l'Effect n'a pas encore roul√©.
  - On est toujours connect√© √† `"general"`
  - L'interface est d√©synchronis√© de la connexion

---

## Modifier la synchronisation

- React doit faire deux choses:

1. Arr√™ter la synchro de l'ancien `roomId` (se d√©connecter de `"general"`)
2. D√©marrer la synchro du nouveau `roomId` (se connecter √† `"travel"`)

---

## Arr√™ter la synchronisation

- On arr√™te la synchronisation avec la fonction Cleanup de la chambre `"general"`

```js {6}
function ChatRoom({ roomId /* "general" */ }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    // Connects to the "general" room
    connection.connect();
    return () => {
      connection.disconnect(); // Disconnects from "general" room
    };
    // ...
```

---

## Re-synchroniser l'Effect

- On ex√©cute l'Effect qui se connecte √† `"travel"`

```js {3,4}
function ChatRoom({ roomId /* "travel" */ }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Connects to the "travel" room
    connection.connect();
    // ...
```

- Le Cleanup est appel√© au d√©montage

---

## Perspective de l'Effect

- Voici ce qui se passe de la perspective de composant

1. `ChatRoom` est mont√© avec `roomId` √† `"general"`
1. `ChatRoom` est mis √† jour avec `roomId` √† `"travel"`
1. `ChatRoom` est mis √† jour avec `roomId` √† `"music"`
1. `ChatRoom` est d√©mont√©

- Du point de vue des Effects:

1. L'Effect se connecte √† `"general"`
1. L'effect se d√©connecte de `"general"` et se connecte √† `"travel"`
1. L'effect se d√©connecte de `"travel"` et se connecte √† `"music"`
1. L'effect se d√©connecte de `"music"`

---

## Perspective du code

```js
useEffect(() => {
  // Your Effect connected to the room specified with roomId...
  const connection = createConnection(serverUrl, roomId);
  connection.connect();
  return () => {
    // ...until it disconnected
    connection.disconnect();
  };
}, [roomId]);
```

---

## R√©sultat du code

Voici la s√©quence du code

1. L'Effect se connete √† `"general"` (se d√©connecte plus tard)
1. L'Effect se connecte √† `"travel"` (se d√©connecte plus tard)
1. L'Effect se connecte √† `"music"` (se d√©connecte plus tard)

- L'√©quipe React veut simplifier notre pens√©e.
  - Il suffit de comprendre comment d√©buter et arr√™ter la synchro
  - React s'occupe d'appeler la synchro au moment opportun
- Similaire au rendu de JSX:
  - On d√©crit le r√©sultat final d√©sir√©
  - React s'occuppe d'afficher durant le commit

---

## Exemple de re-synchronisation

- Le bouton "Open chat" permet de monter et d√©monter le composant `ChatRoom` :

<Sandpack>

```js
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
  return <h1>Welcome to the {roomId} room!</h1>;
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [show, setShow] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select value={roomId} onChange={(e) => setRoomId(e.target.value)}>
          <option value='general'>general</option>
          <option value='travel'>travel</option>
          <option value='music'>music</option>
        </select>
      </label>
      <button onClick={() => setShow(!show)}>
        {show ? 'Close chat' : 'Open chat'}
      </button>
      {show && <hr />}
      {show && <ChatRoom roomId={roomId} />}
    </>
  );
}
```

```js src/chat.js
export function createConnection(serverUrl, roomId) {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log(
        '‚úÖ Connecting to "' + roomId + '" room at ' + serverUrl + '...'
      );
    },
    disconnect() {
      console.log('‚ùå Disconnected from "' + roomId + '" room at ' + serverUrl);
    },
  };
}
```

```css
input {
  display: block;
  margin-bottom: 20px;
}
button {
  margin-left: 10px;
}
```

</Sandpack>

---

## En mode Dev (StrictMode)

Remarquez les logs g√©n√©r√©s au montage:

1. `‚úÖ Connecting to "general" room at https://localhost:1234...` _(development-only)_
1. `‚ùå Disconnected from "general" room at https://localhost:1234.` _(development-only)_
1. `‚úÖ Connecting to "general" room at https://localhost:1234...`

- Ces deux premiers logs n'existent que dans le mode dev.
- En mode dev, React remonte les composants deux fois.
- **React valide la synchro en for√ßant une re-synchro imm√©diate pendant le mode dev**

---

## Ce qui provoque la re-synchronisation

- React re-synchronise quand il y des donn√©es qui changent (ex: `roomId`)
- Il pourrait y avoir re-synchronisation si on modifie `serverUrl` pendant l'ex√©cution du mode dev.
- React pourrait ajouter d'autre raisons de re-synchroniser dans le futur.

---

## Comment React d√©termine qu'il faut re-synchroniser

- React sait qu'il faut re-synchroniser quand `roomId` change
- Car `roomId` est inclus dans le tableau de d√©pendances

```js {1,3,8}
function ChatRoom({ roomId }) { // The roomId prop may change over time
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // This Effect reads roomId
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]); // So you tell React that this Effect "depends on" roomId
  // ...
```

---

## Tableau de d√©pendances

Comment √ßa fonctionne

1. `roomId` est une prop, qui peut changer de valeur
2. L'Effect ira lire `roomId` (sa logique d√©pend d'une valeur qui peut changer).
3. C'est pourquoi on sp√©cifie cette valeur dans le tableau de d√©pendances (provoque une re-synchro quand `roomId` change).

- Apr√®s chaque re-rendu, React observe le tableau de d√©pendance.
- Si une des valeurs contenue dans le tableau diff√®re du tableau pr√©c√©dent, React re-synchronise.
- React compare les valeur en utilisant `Object.is()`

---

## Evitez les synchros multiples dans un m√™me Effect

- On pourrait vouloir ajouter plusieurs actions dans un m√™me Effect
- Ex: Envoyer de la t√©l√©m√©trie quand un utilisateur change de chambre

```js {3}
function ChatRoom({ roomId }) {
  useEffect(() => {
    logVisit(roomId);
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}
```

---

## Isolez les Synchros dans diff√©rents Effects

- Imaginons qu'un jour, on ajoute des d√©pendances additionnelles pour re-synchroniser la connexion, m√™me si on demeure dans le m√™me `roomId`
- Ceci va aussi envoyer un signal de t√©l√©m√©trie.
- Mais ce n'est pas n√©cessaire si on reste dans le m√™me `roomId`
- Si on isole dans des Effects diff√©rents, ce n'est plus un probl√®me

```js {2-4}
function ChatRoom({ roomId }) {
  useEffect(() => {
    logVisit(roomId);
  }, [roomId]);

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    // ...
  }, [roomId]);
  // ...
}
```

---

## Chaque Effect et une synchro s√©par√©e et ind√©pendante

**Chaque Effect doit repr√©senter un processus de synchronisation ind√©pendant et distinct.**

- Les processus interreli√©s doivent partager le m√™me Effect.
- Il faut s√©parer les Effects l√† o√π √ßa fait du sens.

---

## Les Effects r√©agissent aux valeurs R√©actives

- Deux variables sont lues (`serverUrl` et `roomId`)
- Mais seulement `roomId` est une d√©pendance:

```js {5,10}
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}
```

---

## Une valeur r√©active peut changer

- `serverUrl` ne change pas suite √† un re-rendu
- Il demeure constant, d'un re-rendu √† l'autre
- Ce n'est pas une valeur _r√©active_
- On pourrait l'ajouter dans la liste de d√©pendance, mais √ßa n'aurait aucun effet
  <hr />
- Les props, l'√©tat et les valeurs d√©clar√©es dans un composant sont r√©actives
- Ces valeurs peuvent changer
- Ces valeurs participent au flot de donn√©es React

---

## Rendre une valeur r√©active

- Si `serverUrl` √©tait un √©tat, √ßa serait une valeur r√©active
- On doit inclure ces valeurs r√©actives dans le tableau de d√©pendances :

```js {2,5,10}
function ChatRoom({ roomId }) {
  // Props change over time
  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // State may change over time

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Your Effect reads props and state
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId, serverUrl]); // So you tell React that this Effect "depends on" on props and state
  // ...
}
```

- Quand `serverUrl` est une d√©pendance, cela permet la re-synchro apr√®s un changement

---

## Ajout des valeurs r√©actives √† l'Effect

- Quand on modifie roomId ou serverUrl, cela re-synchronise.

<Sandpack>

```js
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]);

  return (
    <>
      <label>
        Server URL:{' '}
        <input
          value={serverUrl}
          onChange={(e) => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select value={roomId} onChange={(e) => setRoomId(e.target.value)}>
          <option value='general'>general</option>
          <option value='travel'>travel</option>
          <option value='music'>music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

```js src/chat.js
export function createConnection(serverUrl, roomId) {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log(
        '‚úÖ Connecting to "' + roomId + '" room at ' + serverUrl + '...'
      );
    },
    disconnect() {
      console.log('‚ùå Disconnected from "' + roomId + '" room at ' + serverUrl);
    },
  };
}
```

```css
input {
  display: block;
  margin-bottom: 20px;
}
button {
  margin-left: 10px;
}
```

</Sandpack>

---

## Que signifie un tableau de d√©pendances vide?

- Si on d√©place `serverUrl` et `roomId` hors du composant?

```js {1,2}
const serverUrl = 'https://localhost:1234';
const roomId = 'general';

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []); // ‚úÖ All dependencies declared
  // ...
}
```

- On n'utilise plus de valeurs r√©actives.
- Le tableau des d√©pendances peut √™tre vide (`[]`)
- Ex√©cute l'Effect au moment du montage
  - La fonction Cleanup ex√©cute au moment du d√©montage
  - En mode dev, le montage et synchro a lieu deux fois

---

## Exemple d'un tableau de d√©pendances vide

<Sandpack>

```js
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';
const roomId = 'general';

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []);
  return <h1>Welcome to the {roomId} room!</h1>;
}

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(!show)}>
        {show ? 'Close chat' : 'Open chat'}
      </button>
      {show && <hr />}
      {show && <ChatRoom />}
    </>
  );
}
```

```js src/chat.js
export function createConnection(serverUrl, roomId) {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log(
        '‚úÖ Connecting to "' + roomId + '" room at ' + serverUrl + '...'
      );
    },
    disconnect() {
      console.log('‚ùå Disconnected from "' + roomId + '" room at ' + serverUrl);
    },
  };
}
```

```css
input {
  display: block;
  margin-bottom: 20px;
}
button {
  margin-left: 10px;
}
```

</Sandpack>

- Pas de valeurs r√©actives dans cette version
- Si un jour, `roomId` ou `serverUrl` deviennent reactives, on les ajoute aux d√©pendances

---

### Les variables d√©clar√©es dans le composant sont r√©actives

- Il y a diff√©rents types de d√©pendances
  - Props
  - √âtat (state)
  - Valeurs calcul√©es ou d√©riv√©es dans le corps du composant

---

## Exemple Reactif

```js {3,5,10}
function ChatRoom({ roomId, selectedServerUrl }) {
  // roomId is reactive
  const settings = useContext(SettingsContext); // settings is reactive
  const serverUrl = selectedServerUrl ?? settings.defaultServerUrl; // serverUrl is reactive
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Your Effect reads roomId and serverUrl
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId, serverUrl]); // So it needs to re-synchronize when either of them changes!
  // ...
}
```

- `serverUrl` n'est ni une prop ni une variable d'√©tat
- C'est une variable calcul√©e pendant le rendu
- Elle peut changer d'un rendu √† l'autre
- C'est donc une valeur r√©active

---

#### Les valeurs muables et variables globales ne peuvent √™tre des d√©pendance

- Les valeurs muables (incluant les variables gobales) ne sont pas reactives
- **Une valeur muable telle que `location.pathname` ne peut √™tre une d√©pendance.**
- Une valeur muable peut changer √† l'ext√©rieur du rendu React
- Modifier cette valeur ne provoque pas de re-rendu
- Ne sera pas re-synchronis√© (les Effects n'ex√©cutent qu'apr√®s un re-rendu)
- De toute fa√ßon, lire des donn√©es muables dans un rendu **brise les r√®gles de puret√© des composants**
- On pourrait g√©rer ces donn√©es externes via `useSyncExternalStore()
  <hr />
- Une valeur muable telle que `ref.current` ne peut √™tre une d√©pendance.
- Le but de `ref.current`, c'est de pouvoir stocker des valeurs qui ne d√©clenchent pas de re-rendu quand elles sont modifi√©es
- Ce n'est donc pas r√©actif

---

## React s'assure que chaque valeur r√©active soit une d√©pendance

- Si le linter est bien configur√© pour React, le code suivant provoque un avertissement
- `roomId` et `serverUrl` sont r√©actifs. Ils doivent √™tre dans la liste de d√©pendances

<Sandpack>

```js
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) {
  // roomId is reactive
  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // serverUrl is reactive

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // <-- Something's wrong here!

  return (
    <>
      <label>
        Server URL:{' '}
        <input
          value={serverUrl}
          onChange={(e) => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select value={roomId} onChange={(e) => setRoomId(e.target.value)}>
          <option value='general'>general</option>
          <option value='travel'>travel</option>
          <option value='music'>music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

```js src/chat.js
export function createConnection(serverUrl, roomId) {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log(
        '‚úÖ Connecting to "' + roomId + '" room at ' + serverUrl + '...'
      );
    },
    disconnect() {
      console.log('‚ùå Disconnected from "' + roomId + '" room at ' + serverUrl);
    },
  };
}
```

```css
input {
  display: block;
  margin-bottom: 20px;
}
button {
  margin-left: 10px;
}
```

</Sandpack>

---

## R√©parer le bogue en ajoutant les d√©pendances

On ajoute `roomId` et `serverUrl` en dependances de l'effect

{/* prettier-ignore */}
```js {9}
function ChatRoom({ roomId }) { // roomId is reactive
  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // serverUrl is reactive
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [serverUrl, roomId]); // ‚úÖ All dependencies declared
  // ...
}
```

- R√©parez le code de la diapo pr√©c√©dente

---

## Valeurs stables

- Certaines valeurs ne changeront pas m√™me quand elles sont d√©clar√©es dans un composant
  - La fonction `setState` retourn√©e par `useState()`
  - L'objet `ref` retourn√© par `useRef()`
- Ces valeurs sont _stables_
  - Ne changeront pas au prochain re-rendu
  - Ne sont pas des valeurs r√©actives
  - Pas besoin de les ajouter au tableau de d√©pendances
  - Si on les ajoute, cela ne change rien √† l'ex√©cution

---

## √âviter la re-synchronisation en √©liminant la r√©activit√©

- On remplace les valeurs r√©actives par des valeurs qui ne changent pas
- Ex: des valeurs qui proviennent √† l'ext√©rieur du composant

```js {1,2,11}
const serverUrl = 'https://localhost:1234'; // serverUrl is not reactive
const roomId = 'general'; // roomId is not reactive

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []); // ‚úÖ All dependencies declared
  // ...
}
```

---

## √âviter la re-synchronisation en d√©clarant dans l'Effect

- Ces valeurs peuvent √™tre d√©clar√©es dans l'Effect
- Ces valeurs ne sont pas utilis√©es pendant le rendu, elles ne sont pas r√©actives.

```js {3,4,10}
function ChatRoom() {
  useEffect(() => {
    const serverUrl = 'https://localhost:1234'; // serverUrl is not reactive
    const roomId = 'general'; // roomId is not reactive
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []); // ‚úÖ All dependencies declared
  // ...
}
```

---

## D√©tails sur les valeurs r√©actives

- **Les Effects sont des blocs de code r√©actifs**
- Permet de re-synchroniser quand la valeur change
- Diff√©rent des gestionnaires d'√©v√©nement
  - Un gestionnaire d'√©v√©nement roule √† chaque interaction
  - Un Effect roule quand la synchronisation est n√©cessaire, apr√®s une modification des d√©pendances

---

## Bonnes pratiques

- **On ne peut choisir les d√©pendances**
  - Les d√©pendances incluent toutes les valeurs r√©actives utilis√©es dans l'Effect
  - Le linter nous aide √† d√©terminer les d√©pendances
- **Validez que votre Effect repr√©sente un processus de synchronisation ind√©pendant**
  - Si cela ne synchronise rien, on n'a pas besoin d'un Effect
  - Si cela synchronise plusieurs √©l√©ments, il faut s√©parer dans des Effects isol√©s)
- **Pour lire la valeur d'une prop ou d'un state sans √™tre r√©actif, ni re-synchroniser l'Effect**
  - On s√©pare l'Effect en deux
  - Une partie r√©active (dans l'Effect)
  - Une partie non-r√©active (dans l'_Effect Event_)
- **Evitez d'utiliser des d√©pendances de type objet ou fonction**
  - Si on cr√©√© des objets ou des fonctions pendant le rendu, ils seront diff√©rents dans les re-rendus futurs
  - L'effect sera re-synchronis√© √† chaque fois
  - On devrait √©liminer les d√©pendances non-n√©cessaires

---

## Attention aux boucles infinies

- Le Linter n'est pas parfait
- Le Linter indique parfois des d√©pendances additionnelles
- Ajouter ces d√©pendances pourrait causer une boucle infinie
- On pourrait vouloir ignorer le linter avec un commentaire:

```js {3-4}
useEffect(() => {
  // ...
  // üî¥ Avoid suppressing the linter like this:
  // eslint-ignore-next-line react-hooks/exhaustive-deps
}, []);
```

- L'alternative pr√©f√©rable serait de modifier le code pour que la valeur ne soit pas r√©active et ne n√©cessite plus d'√™tre une d√©pendance.

---

## En r√©sum√©

- Les composants peuvent √™tre mont√©s (mount), mis √† jour (update) et d√©mont√©s (unmount)
- Chaque Effect a un cycle de vie s√©par√© de son composant
- Chaque Effect d√©crit un processus de synchro qui peut _d√©marrer_ ou _arr√™ter_
- Pour √©crire des effects
  - Pensez √† la perspective de l'Effect (d√©marrer et arr√™ter la synchro)
  - Plut√¥t que la perspective du composant (mount, update, unmount)
- Les valeurs d√©clar√©es dans un composant sont r√©actives
- Les valeurs r√©actives provoquent la re-synchronisatio quand elles changent
- Le Linter valide que les valeurs r√©actives sont sp√©cifi√©es dans le tableau de d√©pendance
- Toutes les erreurs rapport√©es par le linter sont l√©gitimes
- Il y a toujours moyen de modifier le code pour ne plus briser les r√®gles

---

## D√©fis

#### √âviter la reconnexion √† chaque touche tap√©e

Le composant `ChatRoom` se connecte et d√©connecte correctement quand on change quand on monte, d√©monte ou change le roomID.

Mais, quand on tape un message dans la bo√Æte en bas, cela re-connecte au chat √† nouveau. Ces re-connexions ne sont pas d√©sirables.

<Hint>

Faudrait ajouter un tableau de d√©pendances √† l'Effect

</Hint>

<Sandpack>

```js
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  });

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={(e) => setMessage(e.target.value)} />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select value={roomId} onChange={(e) => setRoomId(e.target.value)}>
          <option value='general'>general</option>
          <option value='travel'>travel</option>
          <option value='music'>music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

```js src/chat.js
export function createConnection(serverUrl, roomId) {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log(
        '‚úÖ Connecting to "' + roomId + '" room at ' + serverUrl + '...'
      );
    },
    disconnect() {
      console.log('‚ùå Disconnected from "' + roomId + '" room at ' + serverUrl);
    },
  };
}
```

```css
input {
  display: block;
  margin-bottom: 20px;
}
button {
  margin-left: 10px;
}
```

</Sandpack>

---

## Activer et d√©sactiver la synchro

Dans cet exemple, un Effect s'abonne √† l'√©v√©nement `pointermove` pour d√©placer un point rose.

Il y a une cas √† cocher qui modifie l'√©tat `canMove`. Cela ne fait rien pr√©sentement. Il faudrait arr√™ter le d√©placement quand `canMove` est √† false. On veut synchroniser le comportement de l'app d√©pendant de la case √† cocher.

<Hint>

Un Effect ne peut √™tre appel√© de fa√ßon conditionnelle, mais le code dans cet Effect peut utiliser des conditions

</Hint>

<Sandpack>

```js
import { useState, useEffect } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  useEffect(() => {
    function handleMove(e) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
    window.addEventListener('pointermove', handleMove);
    return () => window.removeEventListener('pointermove', handleMove);
  }, []);

  return (
    <>
      <label>
        <input
          type='checkbox'
          checked={canMove}
          onChange={(e) => setCanMove(e.target.checked)}
        />
        The dot is allowed to move
      </label>
      <hr />
      <div
        style={{
          position: 'absolute',
          backgroundColor: 'pink',
          borderRadius: '50%',
          opacity: 0.6,
          transform: `translate(${position.x}px, ${position.y}px)`,
          pointerEvents: 'none',
          left: -20,
          top: -20,
          width: 40,
          height: 40,
        }}
      />
    </>
  );
}
```

```css
body {
  height: 200px;
}
```

</Sandpack>

---

## R√©parer un bogue

Dans cet exemple, le point suit la souris, quelle que soit la valeur de la case √† cocher. R√©parez le bogue pour que le point arr√™te de suivre la souris quand la case n'est pas pas coch√©e.

<Hint>

Il y a une supression de la r√®gle du Linter. C'est un indice qu'on a possiblement un bogue √† cet endroit.

</Hint>

<Sandpack>

```js
import { useState, useEffect } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  function handleMove(e) {
    if (canMove) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
  }

  useEffect(() => {
    window.addEventListener('pointermove', handleMove);
    return () => window.removeEventListener('pointermove', handleMove);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <>
      <label>
        <input
          type='checkbox'
          checked={canMove}
          onChange={(e) => setCanMove(e.target.checked)}
        />
        The dot is allowed to move
      </label>
      <hr />
      <div
        style={{
          position: 'absolute',
          backgroundColor: 'pink',
          borderRadius: '50%',
          opacity: 0.6,
          transform: `translate(${position.x}px, ${position.y}px)`,
          pointerEvents: 'none',
          left: -20,
          top: -20,
          width: 40,
          height: 40,
        }}
      />
    </>
  );
}
```

```css
body {
  height: 200px;
}
```

</Sandpack>

---

## R√©parer la connexion

Le service `chat.js` expose deux APIs: `createEncryptedConnection` et `createUnencryptedConnection`. Le composant `App` permet de choisir le niveau d'encryption, et passe cet √©tat au composant `ChatRoom` dans la prop `createConnection`.

La case √† cocher ne semble rien faire lors d'un clic. Mais elle fonctionne si on modifie la chambre. Pour r√©parer le bogue, on voudrait se reconnecter d√®s qu'on clique la case √† cocher.

<Hint>

On supprime un avertissement du Linter, c'est suspect.

</Hint>

<Sandpack>

```js src/App.js
import { useState } from 'react';
import ChatRoom from './ChatRoom.js';
import {
  createEncryptedConnection,
  createUnencryptedConnection,
} from './chat.js';

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isEncrypted, setIsEncrypted] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select value={roomId} onChange={(e) => setRoomId(e.target.value)}>
          <option value='general'>general</option>
          <option value='travel'>travel</option>
          <option value='music'>music</option>
        </select>
      </label>
      <label>
        <input
          type='checkbox'
          checked={isEncrypted}
          onChange={(e) => setIsEncrypted(e.target.checked)}
        />
        Enable encryption
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        createConnection={
          isEncrypted ? createEncryptedConnection : createUnencryptedConnection
        }
      />
    </>
  );
}
```

```js src/ChatRoom.js active
import { useState, useEffect } from 'react';

export default function ChatRoom({ roomId, createConnection }) {
  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();
    return () => connection.disconnect();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [roomId]);

  return <h1>Welcome to the {roomId} room!</h1>;
}
```

```js src/chat.js
export function createEncryptedConnection(roomId) {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log('‚úÖ üîê Connecting to "' + roomId + '... (encrypted)');
    },
    disconnect() {
      console.log('‚ùå üîê Disconnected from "' + roomId + '" room (encrypted)');
    },
  };
}

export function createUnencryptedConnection(roomId) {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log('‚úÖ Connecting to "' + roomId + '... (unencrypted)');
    },
    disconnect() {
      console.log('‚ùå Disconnected from "' + roomId + '" room (unencrypted)');
    },
  };
}
```

```css
label {
  display: block;
  margin-bottom: 10px;
}
```

</Sandpack>

---

## Remplir une chaine de bo√Ætes de s√©lection

La premi√®re bo√Æte permet de choisir une plan√®te. La seconde devrait permettre de s√©lectionner une place. Mais elle ne fait rien pour le moment.

Il faut ajouter le code pour aller chercher la liste de places. La liste `placeList` est remplie par un API nomm√© `"/planets/" + planetId + "/places"`.

Changer la plan√®te devrait changer la liste des places.

<Hint>

Il y a deux processus de synchronisation ind√©pendants. Il faut donc deux Effects s√©par√©s.

</Hint>

<Sandpack>

```js src/App.js
import { useState, useEffect } from 'react';
import { fetchData } from './api.js';

export default function Page() {
  const [planetList, setPlanetList] = useState([]);
  const [planetId, setPlanetId] = useState('');

  const [placeList, setPlaceList] = useState([]);
  const [placeId, setPlaceId] = useState('');

  useEffect(() => {
    let ignore = false;
    fetchData('/planets').then((result) => {
      if (!ignore) {
        console.log('Fetched a list of planets.');
        setPlanetList(result);
        setPlanetId(result[0].id); // Select the first planet
      }
    });
    return () => {
      ignore = true;
    };
  }, []);

  return (
    <>
      <label>
        Pick a planet:{' '}
        <select
          value={planetId}
          onChange={(e) => {
            setPlanetId(e.target.value);
          }}
        >
          {planetList.map((planet) => (
            <option key={planet.id} value={planet.id}>
              {planet.name}
            </option>
          ))}
        </select>
      </label>
      <label>
        Pick a place:{' '}
        <select
          value={placeId}
          onChange={(e) => {
            setPlaceId(e.target.value);
          }}
        >
          {placeList.map((place) => (
            <option key={place.id} value={place.id}>
              {place.name}
            </option>
          ))}
        </select>
      </label>
      <hr />
      <p>
        You are going to: {placeId || '???'} on {planetId || '???'}{' '}
      </p>
    </>
  );
}
```

```js src/api.js hidden
export function fetchData(url) {
  if (url === '/planets') {
    return fetchPlanets();
  } else if (url.startsWith('/planets/')) {
    const match = url.match(/^\/planets\/([\w-]+)\/places(\/)?$/);
    if (!match || !match[1] || !match[1].length) {
      throw Error(
        'Expected URL like "/planets/earth/places". Received: "' + url + '".'
      );
    }
    return fetchPlaces(match[1]);
  } else
    throw Error(
      'Expected URL like "/planets" or "/planets/earth/places". Received: "' +
        url +
        '".'
    );
}

async function fetchPlanets() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        {
          id: 'earth',
          name: 'Earth',
        },
        {
          id: 'venus',
          name: 'Venus',
        },
        {
          id: 'mars',
          name: 'Mars',
        },
      ]);
    }, 1000);
  });
}

async function fetchPlaces(planetId) {
  if (typeof planetId !== 'string') {
    throw Error(
      'fetchPlaces(planetId) expects a string argument. ' +
        'Instead received: ' +
        planetId +
        '.'
    );
  }
  return new Promise((resolve) => {
    setTimeout(() => {
      if (planetId === 'earth') {
        resolve([
          {
            id: 'laos',
            name: 'Laos',
          },
          {
            id: 'spain',
            name: 'Spain',
          },
          {
            id: 'vietnam',
            name: 'Vietnam',
          },
        ]);
      } else if (planetId === 'venus') {
        resolve([
          {
            id: 'aurelia',
            name: 'Aurelia',
          },
          {
            id: 'diana-chasma',
            name: 'Diana Chasma',
          },
          {
            id: 'kumsong-vallis',
            name: 'K≈≠ms≈èng Vallis',
          },
        ]);
      } else if (planetId === 'mars') {
        resolve([
          {
            id: 'aluminum-city',
            name: 'Aluminum City',
          },
          {
            id: 'new-new-york',
            name: 'New New York',
          },
          {
            id: 'vishniac',
            name: 'Vishniac',
          },
        ]);
      } else throw Error('Unknown planet ID: ' + planetId);
    }, 1000);
  });
}
```

```css
label {
  display: block;
  margin-bottom: 10px;
}
```

</Sandpack>
