---
title: 'Cycle de vie des Effects'
---

# Cycle de vie des Effects

---

## Intro

- Les cycles de vie diff√®rent pour les composants et les effets
- Composants vont :
  - Monter (mount)
  - Mettre √† jour (update)
  - D√©monter (unmount)
- Effets vont :
  - D√©marrer la synchro
  - Arr√™ter la synchro
- Le linter de React s'assure que les d√©pendances soient bien d√©finies

---

## Contenu

- Diff√©rences entre les cycles de vie entre Composants et Effects
- Comment isoler chaque Effect individuellement
- Resynchroniser les Effects
- Comment d√©terminer les d√©pendances
- Qu'est-ce qu'une valeur r√©active
- Que signifie un tableau de d√©pendance vide
- Valider les d√©pendances avec un Linter
- Forcer la main du Linter

---

## Cycle de vie d'un Effect

- Chaque composant passe √† travers un cycle:
  - _montage_ (mount) quand le composant est ajout√© √† l'√©cran
  - _update_ quand le composant obtient de nouveaux props ou √©tat, suite √† une interaction .
  - _d√©montage_ (unmount) quand le composant est retir√© de l'√©cran
- Ce cycle d√©crit les composants, mais pas les Effects
- Un Effects permet la synchro avec un syst√®me externe

---

## Exemple sur le clavardage

```js
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}
```

---

## D√©marrer la synchronisation

```js {2-3}
// ...
const connection = createConnection(serverUrl, roomId);
connection.connect();
return () => {
  connection.disconnect();
};
// ...
```

---

## Arr√™ter la synchronisation

Avec la fonction _Cleanup_

```js {5}
// ...
const connection = createConnection(serverUrl, roomId);
connection.connect();
return () => {
  connection.disconnect();
};
// ...
```

---

## Arr√™ter et d√©marrer la synchro de multiples fois

- On commence la synchro au moment du montage (mount),
- On arr√™te la synchro au d√©montage (unmount).
- Parfois, on fait cela plusieurs fois, pendant que le composant demeure mont√©.

---

## La fonction de cleanup vide

- Les Effects ne retournent pas toujours de fonction de cleanup
- React consid√®re alors que cleanup est une fonction vide

---

## Rendu initial du composant

- Imaginons que `ChatRoom` re√ßoit une prop `roomId` choisie dans une liste d√©roulante.
- On choisi originalement le roomID `"general"`
- √áa affiche le roomID.

```js {3}
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId /* "general" */ }) {
  // ...
  return <h1>Welcome to the {roomId} room!</h1>;
}
```

---

## D√©marrer la synchro

- Apr√®s l'affichage, React ex√©cute l'Effect pour d√©marrer la synchro
- √áa connecte √† `general`:

```js {3,4}
function ChatRoom({ roomId /* "general" */ }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    // Connects to the "general" room
    connection.connect();
    return () => {
      connection.disconnect(); // Disconnects from the "general" room
    };
  }, [roomId]);
  // ...
```

---

## Second rendu avec un autre choix

- L'utilisateur choisit `"travel"` dans la liste d√©roulante
- React met √† jour l'IU

```js {1}
function ChatRoom({ roomId /* "travel" */ }) {
  // ...
  return <h1>Welcome to the {roomId} room!</h1>;
}
```

- Apr√®s le rendu, on affiche `"travel"`
- Mais l'Effect n'a pas encore roul√©.
  - On est toujours connect√© √† `"general"`
  - L'interface est d√©synchronis√© de la connexion

---

## Modifier la synchronisation

- React doit faire deux choses:

1. Arr√™ter la synchro de l'ancien `roomId` (se d√©connecter de `"general"`)
2. D√©marrer la synchro du nouveau `roomId` (se connecter √† `"travel"`)

---

## Arr√™ter la synchronisation

- On arr√™te la synchronisation avec la fonction Cleanup de la chambre `"general"`

```js {6}
function ChatRoom({ roomId /* "general" */ }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    // Connects to the "general" room
    connection.connect();
    return () => {
      connection.disconnect(); // Disconnects from "general" room
    };
    // ...
```

---

## Re-synchroniser l'Effect

- On ex√©cute l'Effect qui se connecte √† `"travel"`

```js {3,4}
function ChatRoom({ roomId /* "travel" */ }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Connects to the "travel" room
    connection.connect();
    // ...
```

- Le Cleanup est appel√© au d√©montage

---

## Perspective de l'Effect

- Voici ce qui se passe de la perspective de composant

1. `ChatRoom` est mont√© avec `roomId` √† `"general"`
1. `ChatRoom` est mis √† jour avec `roomId` √† `"travel"`
1. `ChatRoom` est mis √† jour avec `roomId` √† `"music"`
1. `ChatRoom` est d√©mont√©

- Du point de vue des Effects:

1. L'Effect se connecte √† `"general"`
1. L'effect se d√©connecte de `"general"` et se connecte √† `"travel"`
1. L'effect se d√©connecte de `"travel"` et se connecte √† `"music"`
1. L'effect se d√©connecte de `"music"`

---

## Perspective du code

```js
useEffect(() => {
  // Your Effect connected to the room specified with roomId...
  const connection = createConnection(serverUrl, roomId);
  connection.connect();
  return () => {
    // ...until it disconnected
    connection.disconnect();
  };
}, [roomId]);
```

---

## R√©sultat du code

Voici la s√©quence du code

1. L'Effect se connete √† `"general"` (se d√©connecte plus tard)
1. L'Effect se connecte √† `"travel"` (se d√©connecte plus tard)
1. L'Effect se connecte √† `"music"` (se d√©connecte plus tard)

- L'√©quipe React veut simplifier notre pens√©e.
  - Il suffit de comprendre comment d√©buter et arr√™ter la synchro
  - React s'occupe d'appeler la synchro au moment opportun
- Similaire au rendu de JSX:
  - On d√©crit le r√©sultat final d√©sir√©
  - React s'occuppe d'afficher durant le commit

---

## Exemple de re-synchronisation

- Le bouton "Open chat" permet de monter et d√©monter le composant `ChatRoom` :

<Sandpack>

```js
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
  return <h1>Welcome to the {roomId} room!</h1>;
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [show, setShow] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select value={roomId} onChange={(e) => setRoomId(e.target.value)}>
          <option value='general'>general</option>
          <option value='travel'>travel</option>
          <option value='music'>music</option>
        </select>
      </label>
      <button onClick={() => setShow(!show)}>
        {show ? 'Close chat' : 'Open chat'}
      </button>
      {show && <hr />}
      {show && <ChatRoom roomId={roomId} />}
    </>
  );
}
```

```js src/chat.js
export function createConnection(serverUrl, roomId) {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log(
        '‚úÖ Connecting to "' + roomId + '" room at ' + serverUrl + '...'
      );
    },
    disconnect() {
      console.log('‚ùå Disconnected from "' + roomId + '" room at ' + serverUrl);
    },
  };
}
```

```css
input {
  display: block;
  margin-bottom: 20px;
}
button {
  margin-left: 10px;
}
```

</Sandpack>

---

## En mode Dev (StrictMode)

Remarquez les logs g√©n√©r√©s au montage:

1. `‚úÖ Connecting to "general" room at https://localhost:1234...` _(development-only)_
1. `‚ùå Disconnected from "general" room at https://localhost:1234.` _(development-only)_
1. `‚úÖ Connecting to "general" room at https://localhost:1234...`

- Ces deux premiers logs n'existent que dans le mode dev.
- En mode dev, React remonte les composants deux fois.
- **React valide la synchro en for√ßant une re-synchro imm√©diate pendant le mode dev**

---

## Ce qui provoque la re-synchronisation

- React re-synchronise quand il y des donn√©es qui changent (ex: `roomId`)
- Il pourrait y avoir re-synchronisation si on modifie `serverUrl` pendant l'ex√©cution du mode dev.
- React pourrait ajouter d'autre raisons de re-synchroniser dans le futur.

---

## Comment React d√©termine qu'il faut re-synchroniser

- React sait qu'il faut re-synchroniser quand `roomId` change
- Car `roomId` est inclus dans le tableau de d√©pendances

```js {1,3,8}
function ChatRoom({ roomId }) { // The roomId prop may change over time
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // This Effect reads roomId
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]); // So you tell React that this Effect "depends on" roomId
  // ...
```

---

## Tableau de d√©pendances

Comment √ßa fonctionne

1. `roomId` est une prop, qui peut changer de valeur
2. L'Effect ira lire `roomId` (sa logique d√©pend d'une valeur qui peut changer).
3. C'est pourquoi on sp√©cifie cette valeur dans le tableau de d√©pendances (provoque une re-synchro quand `roomId` change).

- Apr√®s chaque re-rendu, React observe le tableau de d√©pendance.
- Si une des valeurs contenue dans le tableau diff√®re du tableau pr√©c√©dent, React re-synchronise.
- React compare les valeur en utilisant `Object.is()`

---

## Evitez les synchros multiples dans un m√™me Effect

- On pourrait vouloir ajouter plusieurs actions dans un m√™me Effect
- Ex: Envoyer de la t√©l√©m√©trie quand un utilisateur change de chambre

```js {3}
function ChatRoom({ roomId }) {
  useEffect(() => {
    logVisit(roomId);
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}
```

---

## Isolez les Synchros dans diff√©rents Effects

- Imaginons qu'un jour, on ajoute des d√©pendances additionnelles pour re-synchroniser la connexion, m√™me si on demeure dans le m√™me `roomId`
- Ceci va aussi envoyer un signal de t√©l√©m√©trie.
- Mais ce n'est pas n√©cessaire si on reste dans le m√™me `roomId`
- Si on isole dans des Effects diff√©rents, ce n'est plus un probl√®me

```js {2-4}
function ChatRoom({ roomId }) {
  useEffect(() => {
    logVisit(roomId);
  }, [roomId]);

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    // ...
  }, [roomId]);
  // ...
}
```

---

## Chaque Effect et une synchro s√©par√©e et ind√©pendante

**Chaque Effect doit repr√©senter un processus de synchronisation ind√©pendant et distinct.**

- Les processus interreli√©s doivent partager le m√™me Effect.
- Il faut s√©parer les Effects l√† o√π √ßa fait du sens.

---

## Les Effects r√©agissent aux valeurs R√©actives

- Deux variables sont lues (`serverUrl` et `roomId`)
- Mais seulement `roomId` est une d√©pendance:

```js {5,10}
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}
```

---

## Une valeur r√©active peut changer

- `serverUrl` ne change pas suite √† un re-rendu
- Il demeure constant, d'un re-rendu √† l'autre
- Ce n'est pas une valeur _r√©active_
- On pourrait l'ajouter dans la liste de d√©pendance, mais √ßa n'aurait aucun effet
  <hr />
- Les props, l'√©tat et les valeurs d√©clar√©es dans un composant sont r√©actives
- Ces valeurs peuvent changer
- Ces valeurs participent au flot de donn√©es React

---

## Rendre une valeur r√©active

- Si `serverUrl` √©tait un √©tat, √ßa serait une valeur r√©active
- On doit inclure ces valeurs r√©actives dans le tableau de d√©pendances :

```js {2,5,10}
function ChatRoom({ roomId }) {
  // Props change over time
  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // State may change over time

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Your Effect reads props and state
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId, serverUrl]); // So you tell React that this Effect "depends on" on props and state
  // ...
}
```

- Quand `serverUrl` est une d√©pendance, cela permet la re-synchro apr√®s un changement

---

## Ajouter une valeur r√©active √† l'Effect

Modifiez le ChatRoom ou le URL:

<Sandpack>

```js
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]);

  return (
    <>
      <label>
        Server URL:{' '}
        <input
          value={serverUrl}
          onChange={(e) => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select value={roomId} onChange={(e) => setRoomId(e.target.value)}>
          <option value='general'>general</option>
          <option value='travel'>travel</option>
          <option value='music'>music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

```js src/chat.js
export function createConnection(serverUrl, roomId) {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log(
        '‚úÖ Connecting to "' + roomId + '" room at ' + serverUrl + '...'
      );
    },
    disconnect() {
      console.log('‚ùå Disconnected from "' + roomId + '" room at ' + serverUrl);
    },
  };
}
```

```css
input {
  display: block;
  margin-bottom: 20px;
}
button {
  margin-left: 10px;
}
```

</Sandpack>

On se re-synchronise au moment de la modification de roomId, ou du url

---

## Que signifie un tableau de d√©pendances vide?

- Si on d√©place `serverUrl` et `roomId` hors du composant?

```js {1,2}
const serverUrl = 'https://localhost:1234';
const roomId = 'general';

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []); // ‚úÖ All dependencies declared
  // ...
}
```

- On n'utilise plus de valeurs r√©actives.
- Le tableau des d√©pendances peut √™tre vide (`[]`)
- Ex√©cute au moment du montage
  - La fonction Cleanup ex√©cute au moment du d√©montage
  - En mode dev, le montage et synchro a lieu deux fois

---

## Exemple d'un tableau de d√©pendances vide

<Sandpack>

```js
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';
const roomId = 'general';

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []);
  return <h1>Welcome to the {roomId} room!</h1>;
}

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(!show)}>
        {show ? 'Close chat' : 'Open chat'}
      </button>
      {show && <hr />}
      {show && <ChatRoom />}
    </>
  );
}
```

```js src/chat.js
export function createConnection(serverUrl, roomId) {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log(
        '‚úÖ Connecting to "' + roomId + '" room at ' + serverUrl + '...'
      );
    },
    disconnect() {
      console.log('‚ùå Disconnected from "' + roomId + '" room at ' + serverUrl);
    },
  };
}
```

```css
input {
  display: block;
  margin-bottom: 20px;
}
button {
  margin-left: 10px;
}
```

</Sandpack>

- Pas de valeurs r√©actives dans cette version
- Si un jour, `roomId` ou `serverUrl` deviennent reactives, on les ajoute aux d√©pendances

---

### Les variables d√©clar√©es dans le composant sont r√©actives

- Il y a diff√©rents types de d√©pendances
  - Props
  - √âtat (state)
  - Valeurs calcul√©es ou d√©riv√©es dans le corps du composant

---

## Exemple Reactif

```js {3,5,10}
function ChatRoom({ roomId, selectedServerUrl }) {
  // roomId is reactive
  const settings = useContext(SettingsContext); // settings is reactive
  const serverUrl = selectedServerUrl ?? settings.defaultServerUrl; // serverUrl is reactive
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Your Effect reads roomId and serverUrl
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId, serverUrl]); // So it needs to re-synchronize when either of them changes!
  // ...
}
```

- `serverUrl` n'est ni une prop ni une variable d'√©tat
- C'est une variable calcul√©e pendant le rendu
- Elle peut changer d'un rendu √† l'autre
- C'est donc une valeur r√©active

---

#### Les valeurs muables et variables globales ne peuvent √™tre des d√©pendance

- Les valeurs muables (incluant les variables gobales) ne sont pas reactives
- **Une valeur muable telle que `location.pathname` ne peut √™tre une d√©pendance.**
- Une valeur muable peut changer √† l'ext√©rieur du rendu React
- Modifier cette valeur ne provoque pas de re-rendu
- Ne sera pas re-synchronis√© (les Effects n'ex√©cutent qu'apr√®s un re-rendu)
- De toute fa√ßon, lire des donn√©es muables dans un rendu **brise les r√®gles de puret√© des composants**
- On pourrait g√©rer ces donn√©es externes via `useSyncExternalStore()
  <hr />
- Une valeur muable telle que `ref.current` ne peut √™tre une d√©pendance.
- Le but de `ref.current`, c'est de pouvoir stocker des valeurs qui ne d√©clenchent pas de re-rendu quand elles sont modifi√©es
- Ce n'est donc pas r√©actif

---

## React s'assure que chaque valeur r√©active soit une d√©pendance

- Si le linter est bien configur√© pour React, le code suivant provoque un avertissement, car `roomId` et `serverUrl` sont r√©actifs

<Sandpack>

```js
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) {
  // roomId is reactive
  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // serverUrl is reactive

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // <-- Something's wrong here!

  return (
    <>
      <label>
        Server URL:{' '}
        <input
          value={serverUrl}
          onChange={(e) => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select value={roomId} onChange={(e) => setRoomId(e.target.value)}>
          <option value='general'>general</option>
          <option value='travel'>travel</option>
          <option value='music'>music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

```js src/chat.js
export function createConnection(serverUrl, roomId) {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log(
        '‚úÖ Connecting to "' + roomId + '" room at ' + serverUrl + '...'
      );
    },
    disconnect() {
      console.log('‚ùå Disconnected from "' + roomId + '" room at ' + serverUrl);
    },
  };
}
```

```css
input {
  display: block;
  margin-bottom: 20px;
}
button {
  margin-left: 10px;
}
```

</Sandpack>

---

## R√©parer le bogue en ajoutant les d√©pendances

This may look like a React error, but really React is pointing out a bug in your code. Both `roomId` and `serverUrl` may change over time, but you're forgetting to re-synchronize your Effect when they change. You will remain connected to the initial `roomId` and `serverUrl` even after the user picks different values in the UI.

To fix the bug, follow the linter's suggestion to specify `roomId` and `serverUrl` as dependencies of your Effect:

{/* prettier-ignore */}
```js {9}
function ChatRoom({ roomId }) { // roomId is reactive
  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // serverUrl is reactive
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [serverUrl, roomId]); // ‚úÖ All dependencies declared
  // ...
}
```

Try this fix in the sandbox above. Verify that the linter error is gone, and the chat re-connects when needed.

---

## Note

In some cases, React _knows_ that a value never changes even though it's declared inside the component. For example, the [`set` function](/reference/react/useState#setstate) returned from `useState` and the ref object returned by [`useRef`](/reference/react/useRef) are _stable_--they are guaranteed to not change on a re-render. Stable values aren't reactive, so you may omit them from the list. Including them is allowed: they won't change, so it doesn't matter.

---

## Comment √©viter la re-synchronisation

In the previous example, you've fixed the lint error by listing `roomId` and `serverUrl` as dependencies.

**However, you could instead "prove" to the linter that these values aren't reactive values,** i.e. that they _can't_ change as a result of a re-render. For example, if `serverUrl` and `roomId` don't depend on rendering and always have the same values, you can move them outside the component. Now they don't need to be dependencies:

```js {1,2,11}
const serverUrl = 'https://localhost:1234'; // serverUrl is not reactive
const roomId = 'general'; // roomId is not reactive

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []); // ‚úÖ All dependencies declared
  // ...
}
```

---

## D√©placer ces valeurs dans l'effect

Ces valeurs peuvent √™tre d√©clar√©es dans l'Effect. Ces valeurs ne sont pas utilis√©es pendant le rendu, elles ne sont pas r√©actives.

```js {3,4,10}
function ChatRoom() {
  useEffect(() => {
    const serverUrl = 'https://localhost:1234'; // serverUrl is not reactive
    const roomId = 'general'; // roomId is not reactive
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []); // ‚úÖ All dependencies declared
  // ...
}
```

---

## D√©tails sur les valeurs r√©actives

**Effects are reactive blocks of code.** They re-synchronize when the values you read inside of them change. Unlike event handlers, which only run once per interaction, Effects run whenever synchronization is necessary.

**You can't "choose" your dependencies.** Your dependencies must include every [reactive value](#all-variables-declared-in-the-component-body-are-reactive) you read in the Effect. The linter enforces this. Sometimes this may lead to problems like infinite loops and to your Effect re-synchronizing too often. Don't fix these problems by suppressing the linter! Here's what to try instead:

- **Check that your Effect represents an independent synchronization process.** If your Effect doesn't synchronize anything, [it might be unnecessary.](/learn/you-might-not-need-an-effect) If it synchronizes several independent things, [split it up.](#each-effect-represents-a-separate-synchronization-process)

- **If you want to read the latest value of props or state without "reacting" to it and re-synchronizing the Effect,** you can split your Effect into a reactive part (which you'll keep in the Effect) and a non-reactive part (which you'll extract into something called an _Effect Event_). [Read about separating Events from Effects.](/learn/separating-events-from-effects)

- **Avoid relying on objects and functions as dependencies.** If you create objects and functions during rendering and then read them from an Effect, they will be different on every render. This will cause your Effect to re-synchronize every time. [Read more about removing unnecessary dependencies from Effects.](/learn/removing-effect-dependencies)

---

## Attention

The linter is your friend, but its powers are limited. The linter only knows when the dependencies are _wrong_. It doesn't know _the best_ way to solve each case. If the linter suggests a dependency, but adding it causes a loop, it doesn't mean the linter should be ignored. You need to change the code inside (or outside) the Effect so that that value isn't reactive and doesn't _need_ to be a dependency.

If you have an existing codebase, you might have some Effects that suppress the linter like this:

```js {3-4}
useEffect(() => {
  // ...
  // üî¥ Avoid suppressing the linter like this:
  // eslint-ignore-next-line react-hooks/exhaustive-deps
}, []);
```

On the [next](/learn/separating-events-from-effects) [pages](/learn/removing-effect-dependencies), you'll learn how to fix this code without breaking the rules. It's always worth fixing!

---

## En r√©sum√©

- Components can mount, update, and unmount.
- Each Effect has a separate lifecycle from the surrounding component.
- Each Effect describes a separate synchronization process that can _start_ and _stop_.
- When you write and read Effects, think from each individual Effect's perspective (how to start and stop synchronization) rather than from the component's perspective (how it mounts, updates, or unmounts).
- Values declared inside the component body are "reactive".
- Reactive values should re-synchronize the Effect because they can change over time.
- The linter verifies that all reactive values used inside the Effect are specified as dependencies.
- All errors flagged by the linter are legitimate. There's always a way to fix the code to not break the rules.

---

## D√©fis

#### √âviter la reconnexion √† chaque touche tap√©e

In this example, the `ChatRoom` component connects to the chat room when the component mounts, disconnects when it unmounts, and reconnects when you select a different chat room. This behavior is correct, so you need to keep it working.

However, there is a problem. Whenever you type into the message box input at the bottom, `ChatRoom` _also_ reconnects to the chat. (You can notice this by clearing the console and typing into the input.) Fix the issue so that this doesn't happen.

<Hint>

You might need to add a dependency array for this Effect. What dependencies should be there?

</Hint>

<Sandpack>

```js
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  });

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={(e) => setMessage(e.target.value)} />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select value={roomId} onChange={(e) => setRoomId(e.target.value)}>
          <option value='general'>general</option>
          <option value='travel'>travel</option>
          <option value='music'>music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

```js src/chat.js
export function createConnection(serverUrl, roomId) {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log(
        '‚úÖ Connecting to "' + roomId + '" room at ' + serverUrl + '...'
      );
    },
    disconnect() {
      console.log('‚ùå Disconnected from "' + roomId + '" room at ' + serverUrl);
    },
  };
}
```

```css
input {
  display: block;
  margin-bottom: 20px;
}
button {
  margin-left: 10px;
}
```

</Sandpack>

---

#### Switch synchronization on and off {/* switch-synchronization-on-and-off */}

In this example, an Effect subscribes to the window [`pointermove`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointermove_event) event to move a pink dot on the screen. Try hovering over the preview area (or touching the screen if you're on a mobile device), and see how the pink dot follows your movement.

There is also a checkbox. Ticking the checkbox toggles the `canMove` state variable, but this state variable is not used anywhere in the code. Your task is to change the code so that when `canMove` is `false` (the checkbox is ticked off), the dot should stop moving. After you toggle the checkbox back on (and set `canMove` to `true`), the box should follow the movement again. In other words, whether the dot can move or not should stay synchronized to whether the checkbox is checked.

<Hint>

You can't declare an Effect conditionally. However, the code inside the Effect can use conditions!

</Hint>

<Sandpack>

```js
import { useState, useEffect } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  useEffect(() => {
    function handleMove(e) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
    window.addEventListener('pointermove', handleMove);
    return () => window.removeEventListener('pointermove', handleMove);
  }, []);

  return (
    <>
      <label>
        <input
          type='checkbox'
          checked={canMove}
          onChange={(e) => setCanMove(e.target.checked)}
        />
        The dot is allowed to move
      </label>
      <hr />
      <div
        style={{
          position: 'absolute',
          backgroundColor: 'pink',
          borderRadius: '50%',
          opacity: 0.6,
          transform: `translate(${position.x}px, ${position.y}px)`,
          pointerEvents: 'none',
          left: -20,
          top: -20,
          width: 40,
          height: 40,
        }}
      />
    </>
  );
}
```

```css
body {
  height: 200px;
}
```

</Sandpack>

---

#### Investigate a stale value bug {/* investigate-a-stale-value-bug */}

In this example, the pink dot should move when the checkbox is on, and should stop moving when the checkbox is off. The logic for this has already been implemented: the `handleMove` event handler checks the `canMove` state variable.

However, for some reason, the `canMove` state variable inside `handleMove` appears to be "stale": it's always `true`, even after you tick off the checkbox. How is this possible? Find the mistake in the code and fix it.

<Hint>

If you see a linter rule being suppressed, remove the suppression! That's where the mistakes usually are.

</Hint>

<Sandpack>

```js
import { useState, useEffect } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  function handleMove(e) {
    if (canMove) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
  }

  useEffect(() => {
    window.addEventListener('pointermove', handleMove);
    return () => window.removeEventListener('pointermove', handleMove);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <>
      <label>
        <input
          type='checkbox'
          checked={canMove}
          onChange={(e) => setCanMove(e.target.checked)}
        />
        The dot is allowed to move
      </label>
      <hr />
      <div
        style={{
          position: 'absolute',
          backgroundColor: 'pink',
          borderRadius: '50%',
          opacity: 0.6,
          transform: `translate(${position.x}px, ${position.y}px)`,
          pointerEvents: 'none',
          left: -20,
          top: -20,
          width: 40,
          height: 40,
        }}
      />
    </>
  );
}
```

```css
body {
  height: 200px;
}
```

</Sandpack>

---

#### Fix a connection switch {/* fix-a-connection-switch */}

In this example, the chat service in `chat.js` exposes two different APIs: `createEncryptedConnection` and `createUnencryptedConnection`. The root `App` component lets the user choose whether to use encryption or not, and then passes down the corresponding API method to the child `ChatRoom` component as the `createConnection` prop.

Notice that initially, the console logs say the connection is not encrypted. Try toggling the checkbox on: nothing will happen. However, if you change the selected room after that, then the chat will reconnect _and_ enable encryption (as you'll see from the console messages). This is a bug. Fix the bug so that toggling the checkbox _also_ causes the chat to reconnect.

<Hint>

Suppressing the linter is always suspicious. Could this be a bug?

</Hint>

<Sandpack>

```js src/App.js
import { useState } from 'react';
import ChatRoom from './ChatRoom.js';
import {
  createEncryptedConnection,
  createUnencryptedConnection,
} from './chat.js';

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isEncrypted, setIsEncrypted] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select value={roomId} onChange={(e) => setRoomId(e.target.value)}>
          <option value='general'>general</option>
          <option value='travel'>travel</option>
          <option value='music'>music</option>
        </select>
      </label>
      <label>
        <input
          type='checkbox'
          checked={isEncrypted}
          onChange={(e) => setIsEncrypted(e.target.checked)}
        />
        Enable encryption
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        createConnection={
          isEncrypted ? createEncryptedConnection : createUnencryptedConnection
        }
      />
    </>
  );
}
```

```js src/ChatRoom.js active
import { useState, useEffect } from 'react';

export default function ChatRoom({ roomId, createConnection }) {
  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();
    return () => connection.disconnect();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [roomId]);

  return <h1>Welcome to the {roomId} room!</h1>;
}
```

```js src/chat.js
export function createEncryptedConnection(roomId) {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log('‚úÖ üîê Connecting to "' + roomId + '... (encrypted)');
    },
    disconnect() {
      console.log('‚ùå üîê Disconnected from "' + roomId + '" room (encrypted)');
    },
  };
}

export function createUnencryptedConnection(roomId) {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log('‚úÖ Connecting to "' + roomId + '... (unencrypted)');
    },
    disconnect() {
      console.log('‚ùå Disconnected from "' + roomId + '" room (unencrypted)');
    },
  };
}
```

```css
label {
  display: block;
  margin-bottom: 10px;
}
```

</Sandpack>

---

#### Populate a chain of select boxes {/* populate-a-chain-of-select-boxes */}

In this example, there are two select boxes. One select box lets the user pick a planet. Another select box lets the user pick a place _on that planet._ The second box doesn't work yet. Your task is to make it show the places on the chosen planet.

Look at how the first select box works. It populates the `planetList` state with the result from the `"/planets"` API call. The currently selected planet's ID is kept in the `planetId` state variable. You need to find where to add some additional code so that the `placeList` state variable is populated with the result of the `"/planets/" + planetId + "/places"` API call.

If you implement this right, selecting a planet should populate the place list. Changing a planet should change the place list.

<Hint>

If you have two independent synchronization processes, you need to write two separate Effects.

</Hint>

<Sandpack>

```js src/App.js
import { useState, useEffect } from 'react';
import { fetchData } from './api.js';

export default function Page() {
  const [planetList, setPlanetList] = useState([]);
  const [planetId, setPlanetId] = useState('');

  const [placeList, setPlaceList] = useState([]);
  const [placeId, setPlaceId] = useState('');

  useEffect(() => {
    let ignore = false;
    fetchData('/planets').then((result) => {
      if (!ignore) {
        console.log('Fetched a list of planets.');
        setPlanetList(result);
        setPlanetId(result[0].id); // Select the first planet
      }
    });
    return () => {
      ignore = true;
    };
  }, []);

  return (
    <>
      <label>
        Pick a planet:{' '}
        <select
          value={planetId}
          onChange={(e) => {
            setPlanetId(e.target.value);
          }}
        >
          {planetList.map((planet) => (
            <option key={planet.id} value={planet.id}>
              {planet.name}
            </option>
          ))}
        </select>
      </label>
      <label>
        Pick a place:{' '}
        <select
          value={placeId}
          onChange={(e) => {
            setPlaceId(e.target.value);
          }}
        >
          {placeList.map((place) => (
            <option key={place.id} value={place.id}>
              {place.name}
            </option>
          ))}
        </select>
      </label>
      <hr />
      <p>
        You are going to: {placeId || '???'} on {planetId || '???'}{' '}
      </p>
    </>
  );
}
```

```js src/api.js hidden
export function fetchData(url) {
  if (url === '/planets') {
    return fetchPlanets();
  } else if (url.startsWith('/planets/')) {
    const match = url.match(/^\/planets\/([\w-]+)\/places(\/)?$/);
    if (!match || !match[1] || !match[1].length) {
      throw Error(
        'Expected URL like "/planets/earth/places". Received: "' + url + '".'
      );
    }
    return fetchPlaces(match[1]);
  } else
    throw Error(
      'Expected URL like "/planets" or "/planets/earth/places". Received: "' +
        url +
        '".'
    );
}

async function fetchPlanets() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        {
          id: 'earth',
          name: 'Earth',
        },
        {
          id: 'venus',
          name: 'Venus',
        },
        {
          id: 'mars',
          name: 'Mars',
        },
      ]);
    }, 1000);
  });
}

async function fetchPlaces(planetId) {
  if (typeof planetId !== 'string') {
    throw Error(
      'fetchPlaces(planetId) expects a string argument. ' +
        'Instead received: ' +
        planetId +
        '.'
    );
  }
  return new Promise((resolve) => {
    setTimeout(() => {
      if (planetId === 'earth') {
        resolve([
          {
            id: 'laos',
            name: 'Laos',
          },
          {
            id: 'spain',
            name: 'Spain',
          },
          {
            id: 'vietnam',
            name: 'Vietnam',
          },
        ]);
      } else if (planetId === 'venus') {
        resolve([
          {
            id: 'aurelia',
            name: 'Aurelia',
          },
          {
            id: 'diana-chasma',
            name: 'Diana Chasma',
          },
          {
            id: 'kumsong-vallis',
            name: 'K≈≠ms≈èng Vallis',
          },
        ]);
      } else if (planetId === 'mars') {
        resolve([
          {
            id: 'aluminum-city',
            name: 'Aluminum City',
          },
          {
            id: 'new-new-york',
            name: 'New New York',
          },
          {
            id: 'vishniac',
            name: 'Vishniac',
          },
        ]);
      } else throw Error('Unknown planet ID: ' + planetId);
    }, 1000);
  });
}
```

```css
label {
  display: block;
  margin-bottom: 10px;
}
```

</Sandpack>
