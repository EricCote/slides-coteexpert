---
title: Optimisation
---

import nameGen from './18-optimize/nameGen.js';

# Optimisation et performance

---

## Optimisation

Il y a plusieurs approches pour optimiser la performace des applications React.

- Utiliser le mode "production" plut√¥t que "d√©veloppement"
- Utiliser les bonnes pratiques du web
- R√©duire le nombre de rendus n√©cessaires

---

## Mode Prduction

- Le mode Production est plus performant
- On minifie le code
- On √©limine le code non-n√©cessaire (tree-shaking)
- React r√©duit le nombre de 'warnings' envoy√©s √† la console
- React d√©sactive le `StrictMode`
  - Le `StrictMode` g√©n√®re deux rendus et deux effets pour chque rendu demand√©
    <hr />

---

## Bonnes pratiques du web

- R√©duire la taille du t√©l√©chargement
  - Utiliser le bon type d'image (jpeg, png, web, svg)
  - Uiliser la bonne taille d'image (largeur x hauteur)
  - Ne conserver que les classes CSS n√©cessaires
  - Activer la compression GZIP sur http

---

## Bonne pratiques React Server

- Permettre de pr√©-g√©n√©rer le html sur le serveur
- √âvite la "page blanche initiale" pendant le chargement du JS

- Client-Side Rendering (CSR) g√©n√®re le html sur le navigateur (Page blanche)
- Static-Side Generation (SSG) pr√©-g√©n√®re le html au moment du build
- Server-Side Rendering (SSR) g√©n√®re le html sur le serveur au moment de la requ√™te
- Mod√®les hybrides, certaines pages sont SSG et d'autres sont SSR
- React Server Component (RSC) permet une architecture o√π certains composants sont serveurs, d'autres sont clients, d'autres sont les deux.

---

## R√©duire le nombre de composants rendus

- Utiliser des formulaires avec des composants "non-controll√©s"
  - Les composants "controll√©s" sont g√©r√©s par des props et state
  - Il faut c√©duler un rendu pour qu'un composant controll√© puisse afficher sa modification
  - Le composant non-controll√© n'a pas besoin de React pour r√©agir
- Optimiser le rendu des listes
  - Ne pas oublier d'utiliser `key`
- Virtualiser les longues listes
  - Permet d'afficher qu'un petit fragment d'une longue liste
  - Ex: React-Window et React-Virtualized
- **Memoization**: Sauter le rendu des composants quand les propri√©t√©s ne changent pas
  - On conserve le r√©sultat d'un rendu pour un ensemble de props
  - Quand on rappelle le m√™me rendu √† nouveau
    - On recycle le _Virtual DOM_ pr√©c√©dent
    - Sinon, on reg√©n√®re des nouveau √©l√©ments dans le _Virtual DOM_

---

## Composants controll√©s

- Un composant controll√© est g√©r√© par React
  - Provoque un re-rendu √† chaque lettre tap√©e
- Un composant non-controll√© n'est pas g√©r√© par React
- Ici, chaque rendu change la couleur du fond

<Sandpack>

```js
import { useState, useRef, useEffect } from 'react';

export default function App() {
  const [name, setName] = useState('Controlled');
  const myRef = useRef();

  useEffect(() => {
    document.body.style.backgroundColor = rndColor();
  }); //runs after every render

  return (
    <div>
      <label>
        Controlled input:{' '}
        <input value={name} onChange={(e) => setName(e.target.value)} />
      </label>

      <label>
        Uncontrolled input: <input ref={myRef} defaultValue='Uncontrolled' />
      </label>

      <button
        onClick={() =>
          alert(`
    controlled: ${name}
    uncontrolled: ${myRef.current.value}
    `)
        }
      >
        Submit Values
      </button>
    </div>
  );
}

function rndColor() {
  return `rgb(${rndNb()}, ${rndNb()}, ${rndNb()})`;
}

function rndNb() {
  return Math.floor(Math.random() * 128 + 128);
}
```

```css
div {
  display: flex;
  flex-direction: column;
  gap: 2em;
}

button {
  margin-right: auto;
}
```

</Sandpack>

---

## Liste avec "memoization"

Quand on appelle un composant m√©mo√Øs√© avec:

- Les m√™mes props:
  - On retourne le virtual DOM pr√©c√©dent
- De nouvelles props:
  - On ex√©cute le rendu et on le sauvegarde
    <hr /> {/* */}
- √Ä tester avec Dev tools:
  - Avec et sans `Memoization`
  - Avec et sans `key`

<Sandpack  files={{'src/nameGen.js': nameGen}}>

```js
import { useState, useRef, useEffect, memo } from 'react';
import { getRandomName } from './nameGen';

const initialList = ['Bob', 'Mary', 'Joe'];

export default function App() {
  const [authors, setAuthors] = useState(initialList);
  const insertNameRef = useRef();

  return (
    <div>
      <label>
        Name: <input ref={insertNameRef} defaultValue={getRandomName()} />
      </label>
      <button
        onClick={() => {
          setAuthors([insertNameRef.current.value, ...authors]);
          insertNameRef.current.value = getRandomName();
        }}
      >
        Insert at beginning
      </button>
      <button
        onClick={() => {
          setAuthors([...authors, insertNameRef.current.value]);
          insertNameRef.current.value = getRandomName();
        }}
      >
        Insert at end
      </button>
      <table>
        <tbody>
          {authors.map((a) => (
            <Author name={a} key={a} />
          ))}
        </tbody>
      </table>
    </div>
  );
}

//Memoize Person
//When we call Author with the same props (name),
//then no need to render,
//just return the previous output
//----------------------------------
//if different props, then render Person
//and memoize it for the next time
const Author = memo(Person);

function Person({ name }) {
  //slow down rendering for dev tools
  //with console.log
  console.log(name);
  return (
    <tr>
      <td>{name}</td>
    </tr>
  );
}
```

```css
div {
  display: flex;
  flex-direction: column;
  gap: 2em;
}

button {
  margin-right: auto;
}
```

</Sandpack>

---

## Liste avec useCallback

- Pour conserver l'identit√© d'un callback, on utilise useCallback
- Avec Dev Tools
  - Tester avec et sans `useCallBack`

<Sandpack  files={{'src/nameGen.js': nameGen}}>

```js
import { useState, useRef, useEffect, memo, useCallback } from 'react';
import { getRandomName } from './nameGen';

const initialList = ['Bob', 'Mary', 'Joe'];

export default function App() {
  const [authors, setAuthors] = useState(initialList);
  const insertNameRef = useRef();
  const deleteHandler = useCallback(deleteHandle, []);

  function deleteHandle(name) {
    setAuthors((authors) => authors.filter((n) => n !== name));
  }

  return (
    <div>
      <label>
        Name: <input ref={insertNameRef} defaultValue={getRandomName()} />
      </label>
      <button
        onClick={() => {
          setAuthors([insertNameRef.current.value, ...authors]);
          insertNameRef.current.value = getRandomName();
        }}
      >
        Insert at beginning
      </button>
      <button
        onClick={() => {
          setAuthors([...authors, insertNameRef.current.value]);
          insertNameRef.current.value = getRandomName();
        }}
      >
        Insert at end
      </button>
      <table>
        <tbody>
          {authors.map((a) => (
            <Author name={a} key={a} onDelete={deleteHandler} />
          ))}
        </tbody>
      </table>
    </div>
  );
}

//Memoize Person
//When we call Author with the same props (name),
//then no need to render,
//just return the previous output
//----------------------------------
//if different props, then render Person
//and memoize it for the next time
const Author = memo(Person);

function Person({ name, onDelete }) {
  //slow down rendering for dev tools
  //with console.log
  console.log(name);
  return (
    <tr>
      <td>{name}</td>
      <td>
        <button onClick={(e) => onDelete(name)}>üóëÔ∏è</button>
      </td>
    </tr>
  );
}
```

```css
div {
  display: flex;
  flex-direction: column;
  gap: 2em;
}

button {
  margin-right: auto;
}
```

</Sandpack>

---

## Pourquoi useCallback

- Une fonction au top-niveau est persistante
  - Sa port√©e est au niveau du module
- Une fonction imbriqu√©e (dans une autre fonction) est reg√©n√©r√©e √† chaque appel
  - Sa port√©e est limit√©e √† l'appel de la fonction englobante (ou closure)
- `useCallback` permet de conserver une r√©f√©rence √† une fonction imbriqu√©e
  - Sa port√©e est au niveau du composant (Hook) et du tableau de d√©pendances
- Sans `useCallback`, la `m√©mo√Øsation` √©choue dans les sc√©narios avec callback

---

## Difficult√©s de useCallback

- S'il y a du code pour modifier un √©tat, il faut r√©√©crire le setState avec une fonction _updater_. (Sinon, le callback est reg√©n√©r√© √† chaque modification d'√©tat)

```js
const [list, setList] = useState([]);

// good ‚úÖ
const removeMessage = useCallback((message) => {
  setList((list) => list.filter((x) => x.message !== message));
}, []);

// bad üö´
const removeMessage = useCallback(
  (message) => {
    setList(list.filter((x) => x.message !== message));
  },
  [list]
);
```

- Ne pas oublier les bonnes d√©pendances dans le tableau de d√©pendances.
- C'est complexe √† g√©rer partout.

---

## useMemo

- Permet de m√©mo√Øser le r√©sultat d'une fonction
- Tant que les d√©pendances ne changent pas, on utilise le r√©sultat en cache
- Permet de r√©duire le temps d'√©x√©cution quand le r√©sultat est cach√©
- Permet d'√©viter des re-rendus quand on utilise avec `React.memo`
- R√©-ex√©cute le code quand les d√©pendances changent

  <hr />

- Similaire √† `useCallback`, mais ce dernier m√©mo√Øse la fonction (pas le r√©sultat de l'ex√©cution)
- Permet d'√©viter des re-rendus quand on passe des fonctions √† des composants m√©mo√Øs√©s
- Dans les coulisses, l'implantation de `useCallback` d√©pend de `useMemo`

```js
// Simplified implementation (inside React)
function useCallback(fn, dependencies) {
  return useMemo(() => fn, dependencies);
}
```

## Fonctionalit√© Future

**React-Compiler** va automatiquement g√©n√©rer de la _m√©mo√Øsation_ ainsi que les `useCallbacks`.

- Pr√©vu en 2025
- Poss√®de aussi des optimisations additionnelles pour le code
- Une fois adopt√©, on recommande de ne plus appeler `Memo`, `useMemo` et `useCallback` dans notre code.
