---
Title: Optimisation
---

import nameGen from './18-optimize/nameGen.js';

# Optimisation et performance

---

## Optimisation

Il y a plusieurs approches pour optimiser la performace des applications React.

- Utiliser le mode "production" plut√¥t que "d√©veloppement"
- Utiliser les bonnes pratiques du web
- R√©duire le nombre de rendus n√©cessaires

---

## Mode Prduction

- Le mode Production est plus performant
- On minifie le code
- On √©limine le code non-n√©cessaire (tree-shaking)
- React r√©duit le nombre de 'warnings' envoy√©s √† la console
- React d√©sactive le `StrictMode`
  - Le `StrictMode`g√©n√®re deux rendus la premi√®re fois qu'un composant apparait
    <hr />

---

## Bonnes pratiques du web

- R√©duire la taille du t√©l√©chargement
  - Utiliser le bon type d'image (jpeg, png, web, svg)
  - Uiliser la bonne taille d'image
  - Ne conserver que les classes CSS n√©cessaires
  - Activer la compression GZIP sur http

---

## Bonne pratiques React Server

- Permettre de pr√©-g√©n√©rer le html sur le serveur
- √âvite la "page blanche initiale" pendant le chargement du JS

- Client-Side Rendering (CSR) g√©n√®re le html sur le navigateur (Page blanche)
- Static-Side Generation (SSG) pr√©-g√©n√®re le html au moment du build
- Server-Side Rendering (SSR) g√©n√®re le html sur le serveur au moment de la requ√™te
- Mod√®les hybrides, certaines pages sont SSG et d'autres sont SSR
- React Server Component (RSC) permet une architecture o√π certains composants sont serveurs, d'autres sont clients, d'autres sont les deux.

---

## R√©duire le nombre de composants rendus

- Utiliser des formulaires avec des composants "non-controll√©s"
  - Les composants "controll√©s" sont g√©r√©s par des props et state
  - Il faut c√©duler un rendu pour qu'un composant controll√© puisse afficher sa modification
  - Le composant non-controll√© n'a pas besoin de React pour r√©agir
- Optimiser le rendu des listes
  - Ne pas oublier d'utiliser `key`
- Virtualiser les longues listes
  - Permet d'afficher qu'un petit fragment d'une longue liste
  - Ex: React-Window et React-Virtualized
- **Memoization**: Sauter le rendu des composants quand les propri√©t√©s ne changent pas
  - On conserve le r√©sultat d'un rendu pour un ensemble de props
  - Quand on rappelle le m√™me rendu √† nouveau
    - On recycle le _Virtual DOM_ pr√©c√©dent
    - Sinon, on reg√©n√®re des nouveau √©l√©ments dans le _Virtual DOM_

---

## Composants controll√©s

<Sandpack>

```js
import { useState, useRef, useEffect } from 'react';

export default function App() {
  const [name, setName] = useState('Controlled');
  const myRef = useRef();

  useEffect(() => {
    document.body.style.backgroundColor = rndColor();
  }); //runs after every render

  return (
    <div>
      <label>
        Controlled input:{' '}
        <input value={name} onChange={(e) => setName(e.target.value)} />
      </label>

      <label>
        Uncontrolled input: <input ref={myRef} defaultValue='Uncontrolled' />
      </label>

      <button
        onClick={() =>
          alert(`
    controlled: ${name}
    uncontrolled: ${myRef.current.value}
    `)
        }
      >
        Display
      </button>
    </div>
  );
}

function rndColor() {
  return `rgb(${rndNb()}, ${rndNb()}, ${rndNb()})`;
}

function rndNb() {
  return Math.floor(Math.random() * 128 + 128);
}
```

```css
div {
  display: flex;
  flex-direction: column;
  gap: 2em;
}

button {
  margin-right: auto;
}
```

</Sandpack>

---

## Liste avec "memoization"

<Sandpack  files={{'src/nameGen.js': nameGen}}>

```js
import { useState, useRef, useEffect, memo } from 'react';
import { getRandomName } from './nameGen';

const initialList = ['Bob', 'Mary', 'Joe'];

export default function App() {
  const [authors, setAuthors] = useState(initialList);
  const insertNameRef = useRef();

  return (
    <div>
      <label>
        Name: <input ref={insertNameRef} defaultValue={getRandomName()} />
      </label>
      <button
        onClick={() => {
          setAuthors([insertNameRef.current.value, ...authors]);
          insertNameRef.current.value = getRandomName();
        }}
      >
        Insert at beginning
      </button>
      <button
        onClick={() => {
          setAuthors([...authors, insertNameRef.current.value]);
          insertNameRef.current.value = getRandomName();
        }}
      >
        Insert at end
      </button>
      <table>
        <tbody>
          {authors.map((a) => (
            <Author name={a} key={a} />
          ))}
        </tbody>
      </table>
    </div>
  );
}

//Memoize Person
//When we call Author with the same props (name),
//then no need to render,
//just return the previous output
//----------------------------------
//if different props, then render Person
//and memoize it for the next time
const Author = memo(Person);

function Person({ name }) {
  //slow down rendering for dev tools
  //with console.log
  console.log(name);
  return (
    <tr>
      <td>{name}</td>
    </tr>
  );
}
```

```css
div {
  display: flex;
  flex-direction: column;
  gap: 2em;
}

button {
  margin-right: auto;
}
```

</Sandpack>

<br />√Ä tester avec Dev tools:

- Avec et sans `Memoization`
- Avec et sans `key`

---

## Liste avec useCallback

<Sandpack  files={{'src/nameGen.js': nameGen}}>

```js
import { useState, useRef, useEffect, memo, useCallback } from 'react';
import { getRandomName } from './nameGen';

const initialList = ['Bob', 'Mary', 'Joe'];

export default function App() {
  const [authors, setAuthors] = useState(initialList);
  const insertNameRef = useRef();
  const deleteHandler = useCallback(deleteHandle, []);

  function deleteHandle(name) {
    setAuthors((authors) => authors.filter((n) => n !== name));
  }

  return (
    <div>
      <label>
        Name: <input ref={insertNameRef} defaultValue={getRandomName()} />
      </label>
      <button
        onClick={() => {
          setAuthors([insertNameRef.current.value, ...authors]);
          insertNameRef.current.value = getRandomName();
        }}
      >
        Insert at beginning
      </button>
      <button
        onClick={() => {
          setAuthors([...authors, insertNameRef.current.value]);
          insertNameRef.current.value = getRandomName();
        }}
      >
        Insert at end
      </button>
      <table>
        <tbody>
          {authors.map((a) => (
            <Author name={a} key={a} onDelete={deleteHandler} />
          ))}
        </tbody>
      </table>
    </div>
  );
}

//Memoize Person
//When we call Author with the same props (name),
//then no need to render,
//just return the previous output
//----------------------------------
//if different props, then render Person
//and memoize it for the next time
const Author = memo(Person);

function Person({ name, onDelete }) {
  //slow down rendering for dev tools
  //with console.log
  console.log(name);
  return (
    <tr>
      <td>{name}</td>
      <td>
        <button onClick={(e) => onDelete(name)}>üóëÔ∏è</button>
      </td>
    </tr>
  );
}
```

```css
div {
  display: flex;
  flex-direction: column;
  gap: 2em;
}

button {
  margin-right: auto;
}
```

</Sandpack>
<br/>
Avec Dev Tools

- tester avec et sans `useCallBack`

---

## Pourquoi useCallback

- Une fonction au top-niveau est persistante
  - Sa port√©e est au niveau du module
- Une fonction imbriqu√©e (dans une autre fonction) est reg√©n√©r√©e √† chaque appel
  - Sa port√©e est limit√©e √† l'appel de la fonction englobante (ou closure)
- `useCallback` permet de conserver une r√©f√©rence √† une fonction imbriqu√©e
  - Sa port√©e est au niveau du composant (Hook) et du tableau de d√©pendances

---

## Difficult√©s de useCallback

- Si c'est pour modifier un state, il faut r√©√©crire le setState avec une fonction _setter_.
- Il faut mettre les bonnes d√©pendances dans le tableau de d√©pendances.
- C'est complexe √† g√©rer partout.

---

## Fonctionalit√© Future

**React-Compiler** va automatiquement g√©n√©rer de la _m√©moization_ ainsi que les `useCallbacks`.

- Pr√©vu en 2025
- Poss√®de aussi des optimisations additionnelles pour le code
- Une fois adopt√©, on recommande de ne plus appeler `Memo`, `useMemo` et `useCallback` dans notre code.
