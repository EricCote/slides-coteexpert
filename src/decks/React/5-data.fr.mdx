---
title: Donn√©es et Effets
description: other
---

# Donn√©es et Effets

---

import Demo1 from './5-data/demo1.mdx';

<Demo1 components={props.components} />

---

import Demo2 from './5-data/demo2.mdx';

<Demo2 components={props.components} />

---

import Demo3 from './5-data/demo3.mdx';

<Demo3 components={props.components} />

---

import Demo4 from './5-data/demo4.mdx';

<Demo4 components={props.components} />

---

## Pourquoi un effet

- Certains composants doivent se synchroniser avec des syst√®mes externes
- Voici quelques exemples:
  - Contr√¥ler un composant non-React, bas√© sur un √©tat React
  - Ouvrir une connexion au server
  - Envoyer de la t√©l√©m√©trie quand un composant affiche √† l'√©cran
- Un effet permet de rouler du code apr√®s le rendu et commit.

---

## Les 2 types de code

Le code d'un composant est soit:

- **Code de rendu** (rendering code)
  - Situ√© au top niveau du composant.
  - On prend l'√©tat et les props, on les transforme, et on retourne du JSX
  - Le code doit demeurer pur
  - Ce code "calcule" le r√©sultat, sans effet de bord, comme une formule math√©matique

<hr />

- **Gestionnaires d'√©v√©nements** (Event handler)
  - Ce sont des fonctions imbriqu√©es dans le composant
  - Font des choses plut√¥t que simplement calculer
  - Ex: Modifier un champ de saisie, soumettre un POST HTTP, naviguer vers un autre √©cran.
  - Peut modifier l'√©tat avec setState, provoquant un nouveau rendu

---

## Effect

Que faire s'il y a un effet de bord, mais qu'il n'y a pas d'√©v√©nement sp√©cifique associ√©?

- Un _Effect_ permet de coder des effets de bord suite √† un rendu
- Un _Effect_ roule suite √† la phase "commit", suite √† l'affichage des modifications du DOM

**On n'a pas toujours besoin d'un _Effect_**

- C'est utile pour se synchroniser avec un syst√®me externe
- Mais c'est trop si c'est pour modifier le state en fonction d'un autre state

**Note:** On utilisera _Effect_ pour parler de la fonctionalit√© offerte par `useEffect`.

---

## √âcrire un Effect

1. **D√©clarer un Effect** Par d√©faut, un _Effect_ ex√©cute apr√®s chaque rendu
2. **Sp√©cifier les d√©pendances** Les _Effects_ ne devraient r√©-ex√©cuter qu'au besoin, plut√¥t qu'apr√®s chaque rendu
3. **Ajouter une fonction de cleanup, au besoin** Certains _Effects_ doivent indiquer comment arr√™ter ce qu'ils font. Ex: `connect` et `disconnect`, `subscribe` et `unsubscribe`, `fetch` et `cancel`

Regardons ces √©tapes en d√©tail :

---

### √âtape 1: Declarer un Effect

Pour d√©clarer un _Effect_, on utilise le `useEffect`

```js
import { useEffect } from 'react';
```

On appelle `useEffect` au "top niveau" du composant.

```js {2-4}
function MyComponent() {
  useEffect(() => {
    // Ce code ex√©cute apr√®s chaque rendu
  });
  return <div />;
}
```

Apr√®s chaque rendu, React met d'abord l'√©cran √† jour, et ensuite ex√©cute le code dans `useEffect`. On attend donc que le rendu soit affich√© √† l'√©cran pour ex√©cuter un _Effect_

---

## Exemple VideoPlayer

Imaginons le composant `<VideoPlayer>`, et une prop `isPlaying`, pour d√©marrer ou arr√™ter la vid√©o:

```js
<VideoPlayer isPlaying={isPlaying} />
```

`VideoPlayer` g√©n√®re la balise `<video>` au rendu :

```js
function VideoPlayer({ src, isPlaying }) {
  // TODO: Ajouter du code pour g√©rer isPlaying
  return <video src={src} />;
}
```

- `<video>` n'a pas de prop `isPlaying`
- Par contre, elle poss√®de des m√©thodes `play()` et `pause()`
- Il faut donc synchroniser `isPlaying` avec les appels `play()` et `pause()`
- Un `ref` permet de r√©f√©rer la balise `<video>` dans le DOM

---

## Ne pas r√©f√©rer au DOM pendant le render

On serait tent√© d'appeler `play()` ou `pause()` pendant le render, mais √ßa ne fonctionne pas:

<Sandpack >

```js
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  if (isPlaying) {
    ref.current.play(); // plante dans le rendu
  } else {
    ref.current.pause(); // plante dans le rendu
  }

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src='https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4'
      />
    </>
  );
}
```

```css
button {
  display: block;
  margin-bottom: 20px;
}
video {
  width: 250px;
}
```

</Sandpack>

---

## Explications de l'√©chec

- Il ne faut pas manipuler le DOM pendant le rendu
- Un composant React devrait √™tre pur, sans effets de bords
- Quand `VideoPlayer` est appel√© la premi√®re fois, son DOM n'existe pas encore
  - Pas d'√©l√©ment sur lequel appeler `play()` ou `pause()`

---

## La solution

D√©placer les effets de bords dans `useEffect`, (plut√¥t que les garder dans le rendu)

```js {6,12}
import { useEffect, useRef } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}
```

---

## Explications de la solution

- En pla√ßant les manipulation du DOM dans _Effect_, React affiche son r√©sultat avant que _l'Effect_ ne roule.
- Suite au rendu de `VideoPlayer`, une balise `<video>` est g√©n√©r√©e dans le DOM (√©tape Commit).
- Ensuite, _l'Effect_ est appel√©e, permettant l'appel de `play()` ou `pause()` sans erreur

---

## Exemple avec la solution

<Sandpack>

```js
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src='https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4'
      />
    </>
  );
}
```

```css
button {
  display: block;
  margin-bottom: 20px;
}
video {
  width: 250px;
}
```

</Sandpack>

---

## Synchroniser avec un syst√®me externe

- Ici, le "syst√®me externe" est le _Media API_ du navigateur.
- La m√™me approche pourrait √™tre utilis√©e pour g√©rer du code non-React (ex: plugin jQuery).
- Notons que l'exemple pr√©c√©dent est plus complexe si on veut g√©rer toutes les subtilit√©s
  - Ex: L'usager qui utilise les raccourcis navigateurs pour d√©marrer/arr√™ter la vid√©o

---

## Attention

- Par d√©faut, les _Effects_ roulent apr√®s chaque rendu.
- C'est facile de g√©n√©rer une boucle infinie accidentellement.

```js
const [count, setCount] = useState(0);
useEffect(() => {
  setCount(count + 1);
});
```

- Effect ex√©cute suite au rendu
- Modifier le state provoque un rendu

<hr />

- Si on veut modifier l'√©tat bas√© sur un autre √©tat, Effect n'est pas le bon endroit
- Effect existe pour synchroniser un composant √† un syst√®me externe

---

## √âtape 2: Sp√©cifier les d√©pendances

- Par d√©faut, Effect ex√©cute apr√®s chaque rendu
- C'est souvent ind√©sirable

  - C'est parfois lent, et c'est le genre d'impact qu'on veut minimiser. Par exemple, on ne voudrait pas provoquer une connexion au serveur de clavardage √† chaque lettre tap√©e.
  - D'autres fois, c'est de trop. Par exemple, on ne voudrait pas jouer une animation de transition √† chaque lettre tap√©e. (Seulement √† l'apparition originale du composant)

---

## Effect ex√©cute trop souvent

Voici un exemple avec `console.log()`. √Ä chaque lettre tap√©e, l'Effect r√©-ex√©cute.

<Sandpack s="60" >

```js
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      console.log('Calling video.play()');
      ref.current.play();
    } else {
      console.log('Calling video.pause()');
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [text, setText] = useState('');
  return (
    <>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src='https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4'
      />
    </>
  );
}
```

```css
input,
button {
  display: block;
  margin-bottom: 20px;
}
video {
  width: 250px;
}
```

</Sandpack>

---

## Sauter des Effects

On peut sauter des rendus en sp√©cifiant un tableau de _d√©pendances_ comme second argument √† `useEffect()`.

Ajoutons un tableau vide `[]`.

```js {3}
useEffect(() => {
  // ...
}, []);
```

---

## Effect ex√©cute une seule fois

esLint indique que `React Hook useEffect has a missing dependency: 'isPlaying'`:

<Sandpack>

```js
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      console.log('Calling video.play()');
      ref.current.play();
    } else {
      console.log('Calling video.pause()');
      ref.current.pause();
    }
  }, []); // This causes an error

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [text, setText] = useState('');
  return (
    <>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src='https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4'
      />
    </>
  );
}
```

```css
input,
button {
  display: block;
  margin-bottom: 20px;
}
video {
  width: 250px;
}
```

</Sandpack>

---

## Tableau de d√©pendances

Le code Effect d√©pend de la prop `isPlaying`, mais cette d√©pendance n'est pas d√©clar√©e explicitement. Il faut donc ajouter `isPlaying` au tableau de d√©pendances.

```js {2,7}
useEffect(() => {
  if (isPlaying) {
    // c'est utilis√© ici
    // ...
  } else {
    // ...
  }
}, [isPlaying]); // ...il faut le d√©clarer ici!
```

React sait maintenant qu'il doit sauter l'Effect quand `isPlaying` conserve la m√™me valeur que le rendu pr√©c√©dent. Maintenant, taper des lettres ne r√©-ex√©cute plus l'Effect, alors que "Play/Pause" r√©-ex√©cute l'Effect.

---

## Exemple r√©par√©

<Sandpack>

```js
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      console.log('Calling video.play()');
      ref.current.play();
    } else {
      console.log('Calling video.pause()');
      ref.current.pause();
    }
  }, [isPlaying]);

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [text, setText] = useState('');
  return (
    <>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src='https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4'
      />
    </>
  );
}
```

```css
input,
button {
  display: block;
  margin-bottom: 20px;
}
video {
  width: 250px;
}
```

</Sandpack>

---

## Explications

- Le tableau de d√©pendance peut contenir plusieurs d√©pendances
- React saute l'ex√©cution de l'effet quand _toutes_ les valeurs courantes sont √©quivalentes aux valeurs du rendu pr√©c√©dent.
- React utilise `Object.is()` pour comparer les valeurs.
- React ne d√©tecte donc pas les mutationss d'un tableau ou objet.
- L'outil de _Lint_ retourne une erreur quand le code d'Effect et les d√©pendances ne correspondent pas.

---

## Comportements du tableau de d√©pendances

```js {3,7,11}
useEffect(() => {
  // Ex√©cute apr√®s chaque rendu
});

useEffect(() => {
  // Ex√©cute uniquement au montage (apparition du composant)
}, []);

useEffect(() => {
  // Ex√©cute au montage ainsi quand a ou b changent depuis le rendu pr√©c√©dent
}, [a, b]);
```

---

## Pourquoi omettre _ref_ du tableau de d√©pendance

```js {9}
function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);
  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  }, [isPlaying]); //[isPlaying, ref] ??
```

- L'objet `ref` a une identit√© stable.
- React garanti que `useRef()` retourne toujours le m√™me objet.
- On pourrait ajouter `ref` au tableau de d√©pendance, mais cela n'affecte pas le comportement du composant
- Les fonctions `set` ou `setState` ont aussi un identit√© stable.
- Si le linter permet d'omettre une d√©pendance sans erreur, c'est correct de l'√©liminer du tableau.

---

### √âtape 3: Ajouter une fonction de cleanup, au besoin

Imaginons un composant `Chatroom` qui se connecte √† un serveur de clavardage. Il y a un API `createConnection()` qui retourne un objet avec les m√©thodes `connect()` et `disconnect()`. Comment ouvrir la connexion quand le composant est affich√© √† l'usager?

<TwoColumns >
```js
useEffect(() => {
  const connection = createConnection();
  connection.connect();
});
```

Ce code se (re)connecte apr√®s chaque re-rendu (c'est lent). Il faut ajouter un tableau de d√©pendance.

```js {4}
useEffect(() => {
  const connection = createConnection();
  connection.connect();
}, []);
```

Ce code ne roule qu'apr√®s le montage initial, quand le composant appara√Æt √† l'√©cran la premi√®re fois.

</TwoColumns>

---

## Exemple

<Sandpack>

```js
import { useEffect } from 'react';
import { createConnection } from './chat.js';

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}
```

```js src/chat.js
export function createConnection() {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log('‚úÖ Connecting...');
    },
    disconnect() {
      console.log('‚ùå Disconnected.');
    },
  };
}
```

```css
input {
  display: block;
  margin-bottom: 20px;
}
```

</Sandpack>

`Connecting...` appara√Æt deux fois car, en mode _dev_ avec `<StrictMode>`, le rendu initial roule deux fois, **incluant** les _Effects_.

---

## Probl√®me avec sc√©nario plus complexe

- Dans une application avec routage, on pourrait naviguer entre `ChatRoom` et d'autres routes.
- On navigue vers `ChatRoom`, cela monte (mount) le composant, et appelle le `connection.connect()`.
- Quand on navigue vers une autre route, cela d√©monte (unmount) le composant.
- Quand on re-navigue vers `ChatRoom`, cela monte le composant, appelant `connection.connect()` √† nouveau.
- Ceci cr√©√© une nouvelle connexion, mais la premi√®re connexion n'a jamais √©t√© d√©truite.
- √Ä mesure qu'on navigue, on accumule les connexions.

<hr />

- Ce bogue est subtil et difficile √† trouver.
- Mais en mode `<StrictMode>`, c'est plus facile: √ßa monte le composant deux fois successivement.
- √áa afficher `"‚úÖ Connecting..."` deux fois de suite, permettant de saisir qu'on a oubli√© de fermer la connexion au d√©montage.

---

## Solution: Fonction de cleanup (nettoyage)

- Il faut cr√©er une fonction de cleanup (nettoyage) dans l'Effet, et la retourner

```js {4-6}
useEffect(() => {
  const connection = createConnection();
  connection.connect();
  return () => {
    connection.disconnect();
  };
}, []);
```

- React appelle la fonction _cleanup_ juste avant que le prochain Effect n'ex√©cute
- React appelle aussi _cleanup_ une derni√®re fois, avant que le composant ne soit d√©mont√© (au rendu o√π l'on retire celui-ci de l'affichage.)

---

## Exemple r√©par√©

<Sandpack>

```js
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    return () => connection.disconnect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}
```

```js src/chat.js
export function createConnection() {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log('‚úÖ Connecting...');
    },
    disconnect() {
      console.log('‚ùå Disconnected.');
    },
  };
}
```

```css
input {
  display: block;
  margin-bottom: 20px;
}
```

</Sandpack>

---

### R√©sultat

Les logs sont maintenant:

1. `"‚úÖ Connecting..."`
2. `"‚ùå Disconnected."`
3. `"‚úÖ Connecting..."`

- **C'est le comportement attendu en d√©veloppement.**
- Il y a une paire extra d'appels pour se connecter/d√©connecter.
- On pourrait d√©sactiver `<StrictMode>`, mais on recommande de le conserver.
- √áa aide √† trouver les bogues.
- **En production, `"‚úÖ Connecting..."` n'affiche qu'une fois.**

---

## Les diff√©rentes fa√ßons de traiter les effets appel√©s deux fois

- React remonte les composants en d√©veloppement pour aider √† trouver les bogues.
- La question n'est pas "comment ex√©cuter l'effet qu'une fois?"
- Mais plut√¥t **"comment coder l'Effect pour qu'il fonctionne avec le remontage?"**
- La r√©ponse, c'est de coder une fonction _Cleanup_
- Elle doit arr√™ter, annuler ou compenser ce que fait l'Effect
- Le but, c'est que l'on ne puisse pas distinguer entre:
  - ex√©cuter l'Effect une fois (en production)
  - ex√©cuter une s√©quence _Effect ‚Üí Cleanup ‚Üí Effect_ (en dev)

<hr />

- La plupart des Effects utilisent un des patrons suivants:

---

## Controller des widgets non-React

- Imaginons une composante non-React affichant une carte routi√®re, avec une m√©thode `setZoomLevel()`.
- Pour garder la carte synchronis√©e avec l'√©tat `zoomLevel`, il faut le code suivant:

```js
useEffect(() => {
  const map = mapRef.current;
  map.setZoomLevel(zoomLevel);
}, [zoomLevel]);
```

- Pas besoin de Cleanup
- Appeler `setZoomLevel` deux fois avec la m√™me valeur n'affecte pas le r√©sultat final.
- C'est possiblement l√©g√®rement plus lent, √† cause du second appel.
- Mais ce co√ªt n'affecte pas le mode production.

---

## Controller des widgets non-React

- Certains API ne permettent pas de les appeler deux fois de suite.
- Par exemple, la m√©thode `showModal` provenant de l'√©l√©ment `<dialog>`
- Elle lance une exception quand c'est appel√© deux fois.
- La m√©thode cleanup doit fermer la bo√Æte de dialogue.

```js {4}
useEffect(() => {
  const dialog = dialogRef.current;
  dialog.showModal();
  return () => dialog.close();
}, []);
```

- Ce comportement aura le m√™me effet final en dev qu'en production.

---

## S'abonner aux √©v√©nements

Si l'Effect s'abonne, alors le Cleanup se d√©sabonne:

```js {6}
useEffect(() => {
  function handleScroll(e) {
    console.log(window.scrollX, window.scrollY);
  }
  window.addEventListener('scroll', handleScroll);
  return () => window.removeEventListener('scroll', handleScroll);
}, []);
```

- On aura le m√™me nombre d'abonnement en dev qu'en production.

---

## Activer des animations

Si Effect d√©marre une animation, le cleanup ram√®ne les valeurs initiales

```js {4-6}
useEffect(() => {
  const node = ref.current;
  node.style.opacity = 1; // Trigger the animation
  return () => {
    node.style.opacity = 0; // Reset to the initial value
  };
}, []);
```

En d√©veloppement, l'opacit√© passe de `1` √† `0` √† `1`. C'est similaire √† le mettre √† `1` directement, comme on le fait en production.

Si on utilise une librairie en animation qui supporte le tweening, le cleanup doit ramener le `timeline` √† son √©tat initial.

---

### Obtenir des donn√©es (Fetching data)

If your Effect fetches something, the cleanup function should either [abort the fetch](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) or ignore its result:

```js {2,6,13-15}
useEffect(() => {
  let ignore = false;

  async function startFetching() {
    const json = await fetchTodos(userId);
    if (!ignore) {
      setTodos(json);
    }
  }

  startFetching();

  return () => {
    ignore = true;
  };
}, [userId]);
```

You can't "undo" a network request that already happened, but your cleanup function should ensure that the fetch that's _not relevant anymore_ does not keep affecting your application. If the `userId` changes from `'Alice'` to `'Bob'`, cleanup ensures that the `'Alice'` response is ignored even if it arrives after `'Bob'`.

**In development, you will see two fetches in the Network tab.** There is nothing wrong with that. With the approach above, the first Effect will immediately get cleaned up so its copy of the `ignore` variable will be set to `true`. So even though there is an extra request, it won't affect the state thanks to the `if (!ignore)` check.

**In production, there will only be one request.** If the second request in development is bothering you, the best approach is to use a solution that deduplicates requests and caches their responses between components:

```js
function TodoList() {
  const todos = useSomeDataLibrary(`/api/user/${userId}/todos`);
  // ...
```

This will not only improve the development experience, but also make your application feel faster. For example, the user pressing the Back button won't have to wait for some data to load again because it will be cached. You can either build such a cache yourself or use one of the many alternatives to manual fetching in Effects.

---

## Deep Dive

#### What are good alternatives to data fetching in Effects? {/* what-are-good-alternatives-to-data-fetching-in-effects */}

Writing `fetch` calls inside Effects is a [popular way to fetch data](https://www.robinwieruch.de/react-hooks-fetch-data/), especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:

- **Effects don't run on the server.** This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.
- **Fetching directly in Effects makes it easy to create "network waterfalls".** You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.
- **Fetching directly in Effects usually means you don't preload or cache data.** For example, if the component unmounts and then mounts again, it would have to fetch the data again.
- **It's not very ergonomic.** There's quite a bit of boilerplate code involved when writing `fetch` calls in a way that doesn't suffer from bugs like [race conditions.](https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect)

This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:

- **If you use a [framework](/learn/start-a-new-react-project#production-grade-react-frameworks), use its built-in data fetching mechanism.** Modern React frameworks have integrated data fetching mechanisms that are efficient and don't suffer from the above pitfalls.
- **Otherwise, consider using or building a client-side cache.** Popular open source solutions include [React Query](https://tanstack.com/query/latest), [useSWR](https://swr.vercel.app/), and [React Router 6.4+.](https://beta.reactrouter.com/en/main/start/overview) You can build your own solution too, in which case you would use Effects under the hood, but add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).

You can continue fetching data directly in Effects if neither of these approaches suit you.

---

### Sending analytics {/* sending-analytics */}

Consider this code that sends an analytics event on the page visit:

```js
useEffect(() => {
  logVisit(url); // Sends a POST request
}, [url]);
```

In development, `logVisit` will be called twice for every URL, so you might be tempted to try to fix that. **We recommend keeping this code as is.** Like with earlier examples, there is no _user-visible_ behavior difference between running it once and running it twice. From a practical point of view, `logVisit` should not do anything in development because you don't want the logs from the development machines to skew the production metrics. Your component remounts every time you save its file, so it logs extra visits in development anyway.

**In production, there will be no duplicate visit logs.**

To debug the analytics events you're sending, you can deploy your app to a staging environment (which runs in production mode) or temporarily opt out of [Strict Mode](/reference/react/StrictMode) and its development-only remounting checks. You may also send analytics from the route change event handlers instead of Effects. For more precise analytics, [intersection observers](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) can help track which components are in the viewport and how long they remain visible.

---

### Not an Effect: Initializing the application {/* not-an-effect-initializing-the-application */}

Some logic should only run once when the application starts. You can put it outside your components:

```js {2-3}
if (typeof window !== 'undefined') {
  // Check if we're running in the browser.
  checkAuthToken();
  loadDataFromLocalStorage();
}

function App() {
  // ...
}
```

This guarantees that such logic only runs once after the browser loads the page.

---

### Not an Effect: Buying a product {/* not-an-effect-buying-a-product */}

Sometimes, even if you write a cleanup function, there's no way to prevent user-visible consequences of running the Effect twice. For example, maybe your Effect sends a POST request like buying a product:

```js {2-3}
useEffect(() => {
  // üî¥ Wrong: This Effect fires twice in development, exposing a problem in the code.
  fetch('/api/buy', { method: 'POST' });
}, []);
```

You wouldn't want to buy the product twice. However, this is also why you shouldn't put this logic in an Effect. What if the user goes to another page and then presses Back? Your Effect would run again. You don't want to buy the product when the user _visits_ a page; you want to buy it when the user _clicks_ the Buy button.

Buying is not caused by rendering; it's caused by a specific interaction. It should run only when the user presses the button. **Delete the Effect and move your `/api/buy` request into the Buy button event handler:**

```js {2-3}
function handleClick() {
  // ‚úÖ Buying is an event because it is caused by a particular interaction.
  fetch('/api/buy', { method: 'POST' });
}
```

**This illustrates that if remounting breaks the logic of your application, this usually uncovers existing bugs.** From a user's perspective, visiting a page shouldn't be different from visiting it, clicking a link, then pressing Back to view the page again. React verifies that your components abide by this principle by remounting them once in development.

---

## Putting it all together {/* putting-it-all-together */}

This playground can help you "get a feel" for how Effects work in practice.

This example uses [`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout) to schedule a console log with the input text to appear three seconds after the Effect runs. The cleanup function cancels the pending timeout. Start by pressing "Mount the component":

<Sandpack>

```js
import { useState, useEffect } from 'react';

function Playground() {
  const [text, setText] = useState('a');

  useEffect(() => {
    function onTimeout() {
      console.log('‚è∞ ' + text);
    }

    console.log('üîµ Schedule "' + text + '" log');
    const timeoutId = setTimeout(onTimeout, 3000);

    return () => {
      console.log('üü° Cancel "' + text + '" log');
      clearTimeout(timeoutId);
    };
  }, [text]);

  return (
    <>
      <label>
        What to log:{' '}
        <input value={text} onChange={(e) => setText(e.target.value)} />
      </label>
      <h1>{text}</h1>
    </>
  );
}

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(!show)}>
        {show ? 'Unmount' : 'Mount'} the component
      </button>
      {show && <hr />}
      {show && <Playground />}
    </>
  );
}
```

</Sandpack>

You will see three logs at first: `Schedule "a" log`, `Cancel "a" log`, and `Schedule "a" log` again. Three second later there will also be a log saying `a`. As you learned earlier, the extra schedule/cancel pair is because React remounts the component once in development to verify that you've implemented cleanup well.

Now edit the input to say `abc`. If you do it fast enough, you'll see `Schedule "ab" log` immediately followed by `Cancel "ab" log` and `Schedule "abc" log`. **React always cleans up the previous render's Effect before the next render's Effect.** This is why even if you type into the input fast, there is at most one timeout scheduled at a time. Edit the input a few times and watch the console to get a feel for how Effects get cleaned up.

Type something into the input and then immediately press "Unmount the component". Notice how unmounting cleans up the last render's Effect. Here, it clears the last timeout before it has a chance to fire.

Finally, edit the component above and comment out the cleanup function so that the timeouts don't get cancelled. Try typing `abcde` fast. What do you expect to happen in three seconds? Will `console.log(text)` inside the timeout print the _latest_ `text` and produce five `abcde` logs? Give it a try to check your intuition!

Three seconds later, you should see a sequence of logs (`a`, `ab`, `abc`, `abcd`, and `abcde`) rather than five `abcde` logs. **Each Effect "captures" the `text` value from its corresponding render.** It doesn't matter that the `text` state changed: an Effect from the render with `text = 'ab'` will always see `'ab'`. In other words, Effects from each render are isolated from each other. If you're curious how this works, you can read about [closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures).

---

## DeepDive

#### Each render has its own Effects {/* each-render-has-its-own-effects */}

You can think of `useEffect` as "attaching" a piece of behavior to the render output. Consider this Effect:

```js
export default function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Welcome to {roomId}!</h1>;
}
```

Let's see what exactly happens as the user navigates around the app.

---

#### Initial render {/* initial-render */}

The user visits `<ChatRoom roomId="general" />`. Let's [mentally substitute](/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time) `roomId` with `'general'`:

```js
// JSX for the first render (roomId = "general")
return <h1>Welcome to general!</h1>;
```

**The Effect is _also_ a part of the rendering output.** The first render's Effect becomes:

```js
// Effect for the first render (roomId = "general")
() => {
  const connection = createConnection('general');
  connection.connect();
  return () => connection.disconnect();
},
  // Dependencies for the first render (roomId = "general")
  ['general'];
```

React runs this Effect, which connects to the `'general'` chat room.√†

---

#### Re-render with same dependencies {/* re-render-with-same-dependencies */}

Let's say `<ChatRoom roomId="general" />` re-renders. The JSX output is the same:

```js
// JSX for the second render (roomId = "general")
return <h1>Welcome to general!</h1>;
```

React sees that the rendering output has not changed, so it doesn't update the DOM.

The Effect from the second render looks like this:

```js
// Effect for the second render (roomId = "general")
() => {
  const connection = createConnection('general');
  connection.connect();
  return () => connection.disconnect();
},
  // Dependencies for the second render (roomId = "general")
  ['general'];
```

React compares `['general']` from the second render with `['general']` from the first render. **Because all dependencies are the same, React _ignores_ the Effect from the second render.** It never gets called.

---

#### Re-render with different dependencies {/* re-render-with-different-dependencies */}

Then, the user visits `<ChatRoom roomId="travel" />`. This time, the component returns different JSX:

```js
// JSX for the third render (roomId = "travel")
return <h1>Welcome to travel!</h1>;
```

React updates the DOM to change `"Welcome to general"` into `"Welcome to travel"`.

The Effect from the third render looks like this:

```js
// Effect for the third render (roomId = "travel")
() => {
  const connection = createConnection('travel');
  connection.connect();
  return () => connection.disconnect();
},
  // Dependencies for the third render (roomId = "travel")
  ['travel'];
```

React compares `['travel']` from the third render with `['general']` from the second render. One dependency is different: `Object.is('travel', 'general')` is `false`. The Effect can't be skipped.

**Before React can apply the Effect from the third render, it needs to clean up the last Effect that _did_ run.** The second render's Effect was skipped, so React needs to clean up the first render's Effect. If you scroll up to the first render, you'll see that its cleanup calls `disconnect()` on the connection that was created with `createConnection('general')`. This disconnects the app from the `'general'` chat room.

After that, React runs the third render's Effect. It connects to the `'travel'` chat room.

---

#### Unmount {/* unmount */}

Finally, let's say the user navigates away, and the `ChatRoom` component unmounts. React runs the last Effect's cleanup function. The last Effect was from the third render. The third render's cleanup destroys the `createConnection('travel')` connection. So the app disconnects from the `'travel'` room.

---

#### Development-only behaviors {/* development-only-behaviors */}

When [Strict Mode](/reference/react/StrictMode) is on, React remounts every component once after mount (state and DOM are preserved). This [helps you find Effects that need cleanup](#step-3-add-cleanup-if-needed) and exposes bugs like race conditions early. Additionally, React will remount the Effects whenever you save a file in development. Both of these behaviors are development-only.

---

## R√©sum√©

- Unlike events, Effects are caused by rendering itself rather than a particular interaction.
- Effects let you synchronize a component with some external system (third-party API, network, etc).
- By default, Effects run after every render (including the initial one).
- React will skip the Effect if all of its dependencies have the same values as during the last render.
- You can't "choose" your dependencies. They are determined by the code inside the Effect.
- Empty dependency array (`[]`) corresponds to the component "mounting", i.e. being added to the screen.
- In Strict Mode, React mounts components twice (in development only!) to stress-test your Effects.
- If your Effect breaks because of remounting, you need to implement a cleanup function.
- React will call your cleanup function before the Effect runs next time, and during the unmount.

---

## D√©fi

#### Focus a field on mount {/* focus-a-field-on-mount */}

In this example, the form renders a `<MyInput />` component.

Use the input's [`focus()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus) method to make `MyInput` automatically focus when it appears on the screen. There is already a commented out implementation, but it doesn't quite work. Figure out why it doesn't work, and fix it. (If you're familiar with the `autoFocus` attribute, pretend that it does not exist: we are reimplementing the same functionality from scratch.)

<Sandpack>

```js src/MyInput.js active
import { useEffect, useRef } from 'react';

export default function MyInput({ value, onChange }) {
  const ref = useRef(null);

  // TODO: This doesn't quite work. Fix it.
  // ref.current.focus()

  return <input ref={ref} value={value} onChange={onChange} />;
}
```

```js src/App.js hidden
import { useState } from 'react';
import MyInput from './MyInput.js';

export default function Form() {
  const [show, setShow] = useState(false);
  const [name, setName] = useState('Taylor');
  const [upper, setUpper] = useState(false);
  return (
    <>
      <button onClick={() => setShow((s) => !s)}>
        {show ? 'Hide' : 'Show'} form
      </button>
      <br />
      <hr />
      {show && (
        <>
          <label>
            Enter your name:
            <MyInput value={name} onChange={(e) => setName(e.target.value)} />
          </label>
          <label>
            <input
              type='checkbox'
              checked={upper}
              onChange={(e) => setUpper(e.target.checked)}
            />
            Make it uppercase
          </label>
          <p>
            Hello, <b>{upper ? name.toUpperCase() : name}</b>
          </p>
        </>
      )}
    </>
  );
}
```

```css
label {
  display: block;
  margin-top: 20px;
  margin-bottom: 20px;
}

body {
  min-height: 150px;
}
```

</Sandpack>

To verify that your solution works, press "Show form" and verify that the input receives focus (becomes highlighted and the cursor is placed inside). Press "Hide form" and "Show form" again. Verify the input is highlighted again.

`MyInput` should only focus _on mount_ rather than after every render. To verify that the behavior is right, press "Show form" and then repeatedly press the "Make it uppercase" checkbox. Clicking the checkbox should _not_ focus the input above it.

---

## d√©fi

#### Focus a field conditionally {/* focus-a-field-conditionally */}

This form renders two `<MyInput />` components.

Press "Show form" and notice that the second field automatically gets focused. This is because both of the `<MyInput />` components try to focus the field inside. When you call `focus()` for two input fields in a row, the last one always "wins".

Let's say you want to focus the first field. The first `MyInput` component now receives a boolean `shouldFocus` prop set to `true`. Change the logic so that `focus()` is only called if the `shouldFocus` prop received by `MyInput` is `true`.

<Sandpack>

```js src/MyInput.js active
import { useEffect, useRef } from 'react';

export default function MyInput({ shouldFocus, value, onChange }) {
  const ref = useRef(null);

  // TODO: call focus() only if shouldFocus is true.
  useEffect(() => {
    ref.current.focus();
  }, []);

  return <input ref={ref} value={value} onChange={onChange} />;
}
```

```js src/App.js hidden
import { useState } from 'react';
import MyInput from './MyInput.js';

export default function Form() {
  const [show, setShow] = useState(false);
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');
  const [upper, setUpper] = useState(false);
  const name = firstName + ' ' + lastName;
  return (
    <>
      <button onClick={() => setShow((s) => !s)}>
        {show ? 'Hide' : 'Show'} form
      </button>
      <br />
      <hr />
      {show && (
        <>
          <label>
            Enter your first name:
            <MyInput
              value={firstName}
              onChange={(e) => setFirstName(e.target.value)}
              shouldFocus={true}
            />
          </label>
          <label>
            Enter your last name:
            <MyInput
              value={lastName}
              onChange={(e) => setLastName(e.target.value)}
              shouldFocus={false}
            />
          </label>
          <p>
            Hello, <b>{upper ? name.toUpperCase() : name}</b>
          </p>
        </>
      )}
    </>
  );
}
```

```css
label {
  display: block;
  margin-top: 20px;
  margin-bottom: 20px;
}

body {
  min-height: 150px;
}
```

</Sandpack>

To verify your solution, press "Show form" and "Hide form" repeatedly. When the form appears, only the _first_ input should get focused. This is because the parent component renders the first input with `shouldFocus={true}` and the second input with `shouldFocus={false}`. Also check that both inputs still work and you can type into both of them.

<Hint>

You can't declare an Effect conditionally, but your Effect can include conditional logic.

</Hint>

---

## D√©fi

#### Fix an interval that fires twice {/* fix-an-interval-that-fires-twice */}

This `Counter` component displays a counter that should increment every second. On mount, it calls [`setInterval`.](https://developer.mozilla.org/en-US/docs/Web/API/setInterval) This causes `onTick` to run every second. The `onTick` function increments the counter.

However, instead of incrementing once per second, it increments twice. Why is that? Find the cause of the bug and fix it.

<Hint>

Keep in mind that `setInterval` returns an interval ID, which you can pass to [`clearInterval`](https://developer.mozilla.org/en-US/docs/Web/API/clearInterval) to stop the interval.

</Hint>

<Sandpack>

```js src/Counter.js active
import { useState, useEffect } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    function onTick() {
      setCount((c) => c + 1);
    }

    setInterval(onTick, 1000);
  }, []);

  return <h1>{count}</h1>;
}
```

```js src/App.js hidden
import { useState } from 'react';
import Counter from './Counter.js';

export default function Form() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow((s) => !s)}>
        {show ? 'Hide' : 'Show'} counter
      </button>
      <br />
      <hr />
      {show && <Counter />}
    </>
  );
}
```

```css
label {
  display: block;
  margin-top: 20px;
  margin-bottom: 20px;
}

body {
  min-height: 150px;
}
```

</Sandpack>

---

## d√©fi

#### Fix fetching inside an Effect {/* fix-fetching-inside-an-effect */}

This component shows the biography for the selected person. It loads the biography by calling an asynchronous function `fetchBio(person)` on mount and whenever `person` changes. That asynchronous function returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) which eventually resolves to a string. When fetching is done, it calls `setBio` to display that string under the select box.

<Sandpack>

```js src/App.js active
import { useState, useEffect } from 'react';
import { fetchBio } from './api.js';

export default function Page() {
  const [person, setPerson] = useState('Alice');
  const [bio, setBio] = useState(null);

  useEffect(() => {
    setBio(null);
    fetchBio(person).then((result) => {
      setBio(result);
    });
  }, [person]);

  return (
    <>
      <select
        value={person}
        onChange={(e) => {
          setPerson(e.target.value);
        }}
      >
        <option value='Alice'>Alice</option>
        <option value='Bob'>Bob</option>
        <option value='Taylor'>Taylor</option>
      </select>
      <hr />
      <p>
        <i>{bio ?? 'Loading...'}</i>
      </p>
    </>
  );
}
```

```js src/api.js hidden
export async function fetchBio(person) {
  const delay = person === 'Bob' ? 2000 : 200;
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve('This is ' + person + '‚Äôs bio.');
    }, delay);
  });
}
```

</Sandpack>

There is a bug in this code. Start by selecting "Alice". Then select "Bob" and then immediately after that select "Taylor". If you do this fast enough, you will notice that bug: Taylor is selected, but the paragraph below says "This is Bob's bio."

Why does this happen? Fix the bug inside this Effect.

<Hint>

If an Effect fetches something asynchronously, it usually needs cleanup.

</Hint>

---
