---
title: "Patrons d'architecture React"
date: '2024-09-17'
---

# Patrons d'architecture React

---

import cat from './15-patterns/cat.jsx';

import display from './15-patterns/displayMouse.jsx';

## Composant Monolithique

<Sandpack  files={{
    "src/Cat.js": cat
  }}  
>

```js
import { useState } from 'react';
//import Cat from './Cat';

export default function ParentRoot() {
  return <DisplayMouse />;
}

//--------------------------------

function DisplayMouse() {
  const [mousePos, setMousePos] = useState({
    x: 0,
    y: 0,
  });

  function handleMouseMove(evt) {
    setMousePos({ x: evt.clientX, y: evt.clientY });
  }

  return (
    <div style={{ height: '500px' }} onMouseMove={handleMouseMove}>
      <h1>
        The mouse position is: ({mousePos.x}, {mousePos.y})
      </h1>
    </div>
  );
}

//Everything in a single component.
//Hard to reuse this elsewhere (Need to copy paste some parts of the code)
```

</Sandpack>

---

## Composants top-down

<Sandpack  files={{
    "src/Cat.js": cat,
    "src/DisplayMouse.js": display
  }}  
>

```js
import { useState } from 'react';
import DisplayMouse from './DisplayMouse';
//import Cat from './Cat';

export default function ParentRoot() {
  return <MouseProvider />;
}

//---------------------------

function MouseProvider() {
  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });

  function handleMouseMove(evt) {
    setMousePos({ x: evt.clientX, y: evt.clientY });
  }

  return (
    <div style={{ height: '500px' }} onMouseMove={handleMouseMove}>
      <DisplayMouse mouse={mousePos} />
    </div>
  );
}

// A provider (container) and a child (presentation).

//Problem:
//This is strong coupling.
//If we must use another child component, we need to
//reprogram the provider.
//This is far from perfect.

//Solution:
//We want this kind of root, which would make weak coupling (good):
//<MouseProvider>
//  <DisplayMouse mouse={mouseState} />
//</MouseProvider>
```

</Sandpack>

---

## Containment

<Sandpack  files={{
    "src/Cat.js": cat,
    "src/DisplayMouse.js": display
  }}  
>

```js
import { useState } from 'react';
import DisplayMouse from './DisplayMouse';
//import Cat from './Cat';

export default function ParentRoot() {
  return (
    <MouseProvider>
      <DisplayMouse />
    </MouseProvider>
  );
}

//---------------------------

function MouseProvider({ children }) {
  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
  const child = children;
  const ChildElement = child.type;
  const childProps = child.props;

  function handleMouseMove(evt) {
    setMousePos({ x: evt.clientX, y: evt.clientY });
  }

  return (
    <div style={{ height: '500px' }} onMouseMove={handleMouseMove}>
      <ChildElement {...childProps} mouse={mousePos} />
    </div>
  );
}

//Functionality is now split in two components.  This is called containment.

//problem 1:
//using JSX, "key" and "ref" are not passed down to props.

//Solution
//use the following call to solve the problem
//{React.cloneElement(props.children, { mouse: mouseState })}
//

//problem 2:
//can handle only one child.

//Solution
//If we must handle an array of children,
//we must modify the code to wrap each item in the array:
//
//   React.Children.map(props.children, (child) =>
//     React.cloneElement(child, { mouse: mouseState })
//   );
//

//Problem 3:
//What happens if the child needs the prop to be named
//mousePos instead of mouse?

//Solution:
//Render Props  (see step 5)
```

</Sandpack>
